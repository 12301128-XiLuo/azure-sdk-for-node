<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>operations/webApps.js - Documentation</title>
    <meta name="viewport" content="initial-scale=.75">
    <script src="../../scripts/prettify/prettify.js"></script>
    <script src="../../scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="../../styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="../../styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><span><a href="../../index.html">Home</a> <span class="github-short">| <a href="https://github.com/azure/azure-sdk-for-node.git">GitHub</a></span></span></h2><h3>Classes</h3><ul><li><a href="AppServiceCertificateOrders.html">AppServiceCertificateOrders</a><ul class='methods'><li data-type='method'><a href="AppServiceCertificateOrders.html#beginCreateOrUpdate">beginCreateOrUpdate</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#beginCreateOrUpdateCertificate">beginCreateOrUpdateCertificate</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#beginCreateOrUpdateCertificateWithHttpOperationResponse">beginCreateOrUpdateCertificateWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#beginCreateOrUpdateWithHttpOperationResponse">beginCreateOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#createOrUpdate">createOrUpdate</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#createOrUpdateCertificate">createOrUpdateCertificate</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#createOrUpdateCertificateWithHttpOperationResponse">createOrUpdateCertificateWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#createOrUpdateWithHttpOperationResponse">createOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#deleteCertificate">deleteCertificate</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#deleteCertificateWithHttpOperationResponse">deleteCertificateWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#deleteMethod">deleteMethod</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#deleteMethodWithHttpOperationResponse">deleteMethodWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#get">get</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#getCertificate">getCertificate</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#getCertificateWithHttpOperationResponse">getCertificateWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#getWithHttpOperationResponse">getWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#list">list</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listByResourceGroup">listByResourceGroup</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listByResourceGroupNext">listByResourceGroupNext</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listByResourceGroupNextWithHttpOperationResponse">listByResourceGroupNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listByResourceGroupWithHttpOperationResponse">listByResourceGroupWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listCertificates">listCertificates</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listCertificatesNext">listCertificatesNext</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listCertificatesNextWithHttpOperationResponse">listCertificatesNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listCertificatesWithHttpOperationResponse">listCertificatesWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listNext">listNext</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listNextWithHttpOperationResponse">listNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#listWithHttpOperationResponse">listWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#reissue">reissue</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#reissueWithHttpOperationResponse">reissueWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#renew">renew</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#renewWithHttpOperationResponse">renewWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#resendEmail">resendEmail</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#resendEmailWithHttpOperationResponse">resendEmailWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#resendRequestEmails">resendRequestEmails</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#resendRequestEmailsWithHttpOperationResponse">resendRequestEmailsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#retrieveCertificateActions">retrieveCertificateActions</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#retrieveCertificateActionsWithHttpOperationResponse">retrieveCertificateActionsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#retrieveCertificateEmailHistory">retrieveCertificateEmailHistory</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#retrieveCertificateEmailHistoryWithHttpOperationResponse">retrieveCertificateEmailHistoryWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#retrieveSiteSeal">retrieveSiteSeal</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#retrieveSiteSealWithHttpOperationResponse">retrieveSiteSealWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#validatePurchaseInformation">validatePurchaseInformation</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#validatePurchaseInformationWithHttpOperationResponse">validatePurchaseInformationWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#verifyDomainOwnership">verifyDomainOwnership</a></li><li data-type='method'><a href="AppServiceCertificateOrders.html#verifyDomainOwnershipWithHttpOperationResponse">verifyDomainOwnershipWithHttpOperationResponse</a></li></ul></li><li><a href="AppServiceEnvironments.html">AppServiceEnvironments</a><ul class='methods'><li data-type='method'><a href="AppServiceEnvironments.html#beginCreateOrUpdate">beginCreateOrUpdate</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginCreateOrUpdateMultiRolePool">beginCreateOrUpdateMultiRolePool</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginCreateOrUpdateMultiRolePoolWithHttpOperationResponse">beginCreateOrUpdateMultiRolePoolWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginCreateOrUpdateWithHttpOperationResponse">beginCreateOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginCreateOrUpdateWorkerPool">beginCreateOrUpdateWorkerPool</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginCreateOrUpdateWorkerPoolWithHttpOperationResponse">beginCreateOrUpdateWorkerPoolWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginDeleteMethod">beginDeleteMethod</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginDeleteMethodWithHttpOperationResponse">beginDeleteMethodWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginResume">beginResume</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginResumeNext">beginResumeNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginResumeNextWithHttpOperationResponse">beginResumeNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginResumeWithHttpOperationResponse">beginResumeWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginSuspend">beginSuspend</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginSuspendNext">beginSuspendNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginSuspendNextWithHttpOperationResponse">beginSuspendNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#beginSuspendWithHttpOperationResponse">beginSuspendWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#createOrUpdate">createOrUpdate</a></li><li data-type='method'><a href="AppServiceEnvironments.html#createOrUpdateMultiRolePool">createOrUpdateMultiRolePool</a></li><li data-type='method'><a href="AppServiceEnvironments.html#createOrUpdateMultiRolePoolWithHttpOperationResponse">createOrUpdateMultiRolePoolWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#createOrUpdateWithHttpOperationResponse">createOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#createOrUpdateWorkerPool">createOrUpdateWorkerPool</a></li><li data-type='method'><a href="AppServiceEnvironments.html#createOrUpdateWorkerPoolWithHttpOperationResponse">createOrUpdateWorkerPoolWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#deleteMethod">deleteMethod</a></li><li data-type='method'><a href="AppServiceEnvironments.html#deleteMethodWithHttpOperationResponse">deleteMethodWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#get">get</a></li><li data-type='method'><a href="AppServiceEnvironments.html#getDiagnosticsItem">getDiagnosticsItem</a></li><li data-type='method'><a href="AppServiceEnvironments.html#getDiagnosticsItemWithHttpOperationResponse">getDiagnosticsItemWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#getMultiRolePool">getMultiRolePool</a></li><li data-type='method'><a href="AppServiceEnvironments.html#getMultiRolePoolWithHttpOperationResponse">getMultiRolePoolWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#getWithHttpOperationResponse">getWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#getWorkerPool">getWorkerPool</a></li><li data-type='method'><a href="AppServiceEnvironments.html#getWorkerPoolWithHttpOperationResponse">getWorkerPoolWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#list">list</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listAppServicePlans">listAppServicePlans</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listAppServicePlansNext">listAppServicePlansNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listAppServicePlansNextWithHttpOperationResponse">listAppServicePlansNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listAppServicePlansWithHttpOperationResponse">listAppServicePlansWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listByResourceGroup">listByResourceGroup</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listByResourceGroupNext">listByResourceGroupNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listByResourceGroupNextWithHttpOperationResponse">listByResourceGroupNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listByResourceGroupWithHttpOperationResponse">listByResourceGroupWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listCapacities">listCapacities</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listCapacitiesNext">listCapacitiesNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listCapacitiesNextWithHttpOperationResponse">listCapacitiesNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listCapacitiesWithHttpOperationResponse">listCapacitiesWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listDiagnostics">listDiagnostics</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listDiagnosticsWithHttpOperationResponse">listDiagnosticsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMetricDefinitions">listMetricDefinitions</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMetricDefinitionsWithHttpOperationResponse">listMetricDefinitionsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMetrics">listMetrics</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMetricsNext">listMetricsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMetricsNextWithHttpOperationResponse">listMetricsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMetricsWithHttpOperationResponse">listMetricsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleMetricDefinitions">listMultiRoleMetricDefinitions</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleMetricDefinitionsNext">listMultiRoleMetricDefinitionsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleMetricDefinitionsNextWithHttpOperationResponse">listMultiRoleMetricDefinitionsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleMetricDefinitionsWithHttpOperationResponse">listMultiRoleMetricDefinitionsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleMetrics">listMultiRoleMetrics</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleMetricsNext">listMultiRoleMetricsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleMetricsNextWithHttpOperationResponse">listMultiRoleMetricsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleMetricsWithHttpOperationResponse">listMultiRoleMetricsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolInstanceMetricDefinitions">listMultiRolePoolInstanceMetricDefinitions</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolInstanceMetricDefinitionsNext">listMultiRolePoolInstanceMetricDefinitionsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolInstanceMetricDefinitionsNextWithHttpOperationResponse">listMultiRolePoolInstanceMetricDefinitionsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolInstanceMetricDefinitionsWithHttpOperationResponse">listMultiRolePoolInstanceMetricDefinitionsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolInstanceMetrics">listMultiRolePoolInstanceMetrics</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolInstanceMetricsNext">listMultiRolePoolInstanceMetricsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolInstanceMetricsNextWithHttpOperationResponse">listMultiRolePoolInstanceMetricsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolInstanceMetricsWithHttpOperationResponse">listMultiRolePoolInstanceMetricsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePools">listMultiRolePools</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolSkus">listMultiRolePoolSkus</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolSkusNext">listMultiRolePoolSkusNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolSkusNextWithHttpOperationResponse">listMultiRolePoolSkusNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolSkusWithHttpOperationResponse">listMultiRolePoolSkusWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolsNext">listMultiRolePoolsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolsNextWithHttpOperationResponse">listMultiRolePoolsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRolePoolsWithHttpOperationResponse">listMultiRolePoolsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleUsages">listMultiRoleUsages</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleUsagesNext">listMultiRoleUsagesNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleUsagesNextWithHttpOperationResponse">listMultiRoleUsagesNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listMultiRoleUsagesWithHttpOperationResponse">listMultiRoleUsagesWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listNext">listNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listNextWithHttpOperationResponse">listNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listOperations">listOperations</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listOperationsWithHttpOperationResponse">listOperationsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listUsages">listUsages</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listUsagesNext">listUsagesNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listUsagesNextWithHttpOperationResponse">listUsagesNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listUsagesWithHttpOperationResponse">listUsagesWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listVips">listVips</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listVipsWithHttpOperationResponse">listVipsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebApps">listWebApps</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebAppsNext">listWebAppsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebAppsNextWithHttpOperationResponse">listWebAppsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebAppsWithHttpOperationResponse">listWebAppsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerMetricDefinitions">listWebWorkerMetricDefinitions</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerMetricDefinitionsNext">listWebWorkerMetricDefinitionsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerMetricDefinitionsNextWithHttpOperationResponse">listWebWorkerMetricDefinitionsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerMetricDefinitionsWithHttpOperationResponse">listWebWorkerMetricDefinitionsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerMetrics">listWebWorkerMetrics</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerMetricsNext">listWebWorkerMetricsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerMetricsNextWithHttpOperationResponse">listWebWorkerMetricsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerMetricsWithHttpOperationResponse">listWebWorkerMetricsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerUsages">listWebWorkerUsages</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerUsagesNext">listWebWorkerUsagesNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerUsagesNextWithHttpOperationResponse">listWebWorkerUsagesNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWebWorkerUsagesWithHttpOperationResponse">listWebWorkerUsagesWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWithHttpOperationResponse">listWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolInstanceMetricDefinitions">listWorkerPoolInstanceMetricDefinitions</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolInstanceMetricDefinitionsNext">listWorkerPoolInstanceMetricDefinitionsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolInstanceMetricDefinitionsNextWithHttpOperationResponse">listWorkerPoolInstanceMetricDefinitionsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolInstanceMetricDefinitionsWithHttpOperationResponse">listWorkerPoolInstanceMetricDefinitionsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolInstanceMetrics">listWorkerPoolInstanceMetrics</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolInstanceMetricsNext">listWorkerPoolInstanceMetricsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolInstanceMetricsNextWithHttpOperationResponse">listWorkerPoolInstanceMetricsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolInstanceMetricsWithHttpOperationResponse">listWorkerPoolInstanceMetricsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPools">listWorkerPools</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolSkus">listWorkerPoolSkus</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolSkusNext">listWorkerPoolSkusNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolSkusNextWithHttpOperationResponse">listWorkerPoolSkusNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolSkusWithHttpOperationResponse">listWorkerPoolSkusWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolsNext">listWorkerPoolsNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolsNextWithHttpOperationResponse">listWorkerPoolsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#listWorkerPoolsWithHttpOperationResponse">listWorkerPoolsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#reboot">reboot</a></li><li data-type='method'><a href="AppServiceEnvironments.html#rebootWithHttpOperationResponse">rebootWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#resume">resume</a></li><li data-type='method'><a href="AppServiceEnvironments.html#resumeNext">resumeNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#resumeNextWithHttpOperationResponse">resumeNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#resumeWithHttpOperationResponse">resumeWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#suspend">suspend</a></li><li data-type='method'><a href="AppServiceEnvironments.html#suspendNext">suspendNext</a></li><li data-type='method'><a href="AppServiceEnvironments.html#suspendNextWithHttpOperationResponse">suspendNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServiceEnvironments.html#suspendWithHttpOperationResponse">suspendWithHttpOperationResponse</a></li></ul></li><li><a href="AppServicePlans.html">AppServicePlans</a><ul class='methods'><li data-type='method'><a href="AppServicePlans.html#beginCreateOrUpdate">beginCreateOrUpdate</a></li><li data-type='method'><a href="AppServicePlans.html#beginCreateOrUpdateWithHttpOperationResponse">beginCreateOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#createOrUpdate">createOrUpdate</a></li><li data-type='method'><a href="AppServicePlans.html#createOrUpdateVnetRoute">createOrUpdateVnetRoute</a></li><li data-type='method'><a href="AppServicePlans.html#createOrUpdateVnetRouteWithHttpOperationResponse">createOrUpdateVnetRouteWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#createOrUpdateWithHttpOperationResponse">createOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#deleteHybridConnection">deleteHybridConnection</a></li><li data-type='method'><a href="AppServicePlans.html#deleteHybridConnectionWithHttpOperationResponse">deleteHybridConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#deleteMethod">deleteMethod</a></li><li data-type='method'><a href="AppServicePlans.html#deleteMethodWithHttpOperationResponse">deleteMethodWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#deleteVnetRoute">deleteVnetRoute</a></li><li data-type='method'><a href="AppServicePlans.html#deleteVnetRouteWithHttpOperationResponse">deleteVnetRouteWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#get">get</a></li><li data-type='method'><a href="AppServicePlans.html#getHybridConnection">getHybridConnection</a></li><li data-type='method'><a href="AppServicePlans.html#getHybridConnectionPlanLimit">getHybridConnectionPlanLimit</a></li><li data-type='method'><a href="AppServicePlans.html#getHybridConnectionPlanLimitWithHttpOperationResponse">getHybridConnectionPlanLimitWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#getHybridConnectionWithHttpOperationResponse">getHybridConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#getRouteForVnet">getRouteForVnet</a></li><li data-type='method'><a href="AppServicePlans.html#getRouteForVnetWithHttpOperationResponse">getRouteForVnetWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#getVnetFromServerFarm">getVnetFromServerFarm</a></li><li data-type='method'><a href="AppServicePlans.html#getVnetFromServerFarmWithHttpOperationResponse">getVnetFromServerFarmWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#getVnetGateway">getVnetGateway</a></li><li data-type='method'><a href="AppServicePlans.html#getVnetGatewayWithHttpOperationResponse">getVnetGatewayWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#getWithHttpOperationResponse">getWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#list">list</a></li><li data-type='method'><a href="AppServicePlans.html#listByResourceGroup">listByResourceGroup</a></li><li data-type='method'><a href="AppServicePlans.html#listByResourceGroupNext">listByResourceGroupNext</a></li><li data-type='method'><a href="AppServicePlans.html#listByResourceGroupNextWithHttpOperationResponse">listByResourceGroupNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listByResourceGroupWithHttpOperationResponse">listByResourceGroupWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listCapabilities">listCapabilities</a></li><li data-type='method'><a href="AppServicePlans.html#listCapabilitiesWithHttpOperationResponse">listCapabilitiesWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listHybridConnectionKeys">listHybridConnectionKeys</a></li><li data-type='method'><a href="AppServicePlans.html#listHybridConnectionKeysWithHttpOperationResponse">listHybridConnectionKeysWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listHybridConnections">listHybridConnections</a></li><li data-type='method'><a href="AppServicePlans.html#listHybridConnectionsNext">listHybridConnectionsNext</a></li><li data-type='method'><a href="AppServicePlans.html#listHybridConnectionsNextWithHttpOperationResponse">listHybridConnectionsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listHybridConnectionsWithHttpOperationResponse">listHybridConnectionsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listMetricDefintions">listMetricDefintions</a></li><li data-type='method'><a href="AppServicePlans.html#listMetricDefintionsNext">listMetricDefintionsNext</a></li><li data-type='method'><a href="AppServicePlans.html#listMetricDefintionsNextWithHttpOperationResponse">listMetricDefintionsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listMetricDefintionsWithHttpOperationResponse">listMetricDefintionsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listMetrics">listMetrics</a></li><li data-type='method'><a href="AppServicePlans.html#listMetricsNext">listMetricsNext</a></li><li data-type='method'><a href="AppServicePlans.html#listMetricsNextWithHttpOperationResponse">listMetricsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listMetricsWithHttpOperationResponse">listMetricsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listNext">listNext</a></li><li data-type='method'><a href="AppServicePlans.html#listNextWithHttpOperationResponse">listNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listRoutesForVnet">listRoutesForVnet</a></li><li data-type='method'><a href="AppServicePlans.html#listRoutesForVnetWithHttpOperationResponse">listRoutesForVnetWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listVnets">listVnets</a></li><li data-type='method'><a href="AppServicePlans.html#listVnetsWithHttpOperationResponse">listVnetsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listWebApps">listWebApps</a></li><li data-type='method'><a href="AppServicePlans.html#listWebAppsByHybridConnection">listWebAppsByHybridConnection</a></li><li data-type='method'><a href="AppServicePlans.html#listWebAppsByHybridConnectionNext">listWebAppsByHybridConnectionNext</a></li><li data-type='method'><a href="AppServicePlans.html#listWebAppsByHybridConnectionNextWithHttpOperationResponse">listWebAppsByHybridConnectionNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listWebAppsByHybridConnectionWithHttpOperationResponse">listWebAppsByHybridConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listWebAppsNext">listWebAppsNext</a></li><li data-type='method'><a href="AppServicePlans.html#listWebAppsNextWithHttpOperationResponse">listWebAppsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listWebAppsWithHttpOperationResponse">listWebAppsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#listWithHttpOperationResponse">listWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#rebootWorker">rebootWorker</a></li><li data-type='method'><a href="AppServicePlans.html#rebootWorkerWithHttpOperationResponse">rebootWorkerWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#restartWebApps">restartWebApps</a></li><li data-type='method'><a href="AppServicePlans.html#restartWebAppsWithHttpOperationResponse">restartWebAppsWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#updateVnetGateway">updateVnetGateway</a></li><li data-type='method'><a href="AppServicePlans.html#updateVnetGatewayWithHttpOperationResponse">updateVnetGatewayWithHttpOperationResponse</a></li><li data-type='method'><a href="AppServicePlans.html#updateVnetRoute">updateVnetRoute</a></li><li data-type='method'><a href="AppServicePlans.html#updateVnetRouteWithHttpOperationResponse">updateVnetRouteWithHttpOperationResponse</a></li></ul></li><li><a href="Certificates.html">Certificates</a><ul class='methods'><li data-type='method'><a href="Certificates.html#createOrUpdate">createOrUpdate</a></li><li data-type='method'><a href="Certificates.html#createOrUpdateSigningRequest">createOrUpdateSigningRequest</a></li><li data-type='method'><a href="Certificates.html#createOrUpdateSigningRequestWithHttpOperationResponse">createOrUpdateSigningRequestWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#createOrUpdateWithHttpOperationResponse">createOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#deleteMethod">deleteMethod</a></li><li data-type='method'><a href="Certificates.html#deleteMethodWithHttpOperationResponse">deleteMethodWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#deleteSigningRequest">deleteSigningRequest</a></li><li data-type='method'><a href="Certificates.html#deleteSigningRequestWithHttpOperationResponse">deleteSigningRequestWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#get">get</a></li><li data-type='method'><a href="Certificates.html#getSigningRequest">getSigningRequest</a></li><li data-type='method'><a href="Certificates.html#getSigningRequestWithHttpOperationResponse">getSigningRequestWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#getWithHttpOperationResponse">getWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#list">list</a></li><li data-type='method'><a href="Certificates.html#listByResourceGroup">listByResourceGroup</a></li><li data-type='method'><a href="Certificates.html#listByResourceGroupNext">listByResourceGroupNext</a></li><li data-type='method'><a href="Certificates.html#listByResourceGroupNextWithHttpOperationResponse">listByResourceGroupNextWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#listByResourceGroupWithHttpOperationResponse">listByResourceGroupWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#listNext">listNext</a></li><li data-type='method'><a href="Certificates.html#listNextWithHttpOperationResponse">listNextWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#listSigningRequestByResourceGroup">listSigningRequestByResourceGroup</a></li><li data-type='method'><a href="Certificates.html#listSigningRequestByResourceGroupNext">listSigningRequestByResourceGroupNext</a></li><li data-type='method'><a href="Certificates.html#listSigningRequestByResourceGroupNextWithHttpOperationResponse">listSigningRequestByResourceGroupNextWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#listSigningRequestByResourceGroupWithHttpOperationResponse">listSigningRequestByResourceGroupWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#listWithHttpOperationResponse">listWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#update">update</a></li><li data-type='method'><a href="Certificates.html#updateSigningRequest">updateSigningRequest</a></li><li data-type='method'><a href="Certificates.html#updateSigningRequestWithHttpOperationResponse">updateSigningRequestWithHttpOperationResponse</a></li><li data-type='method'><a href="Certificates.html#updateWithHttpOperationResponse">updateWithHttpOperationResponse</a></li></ul></li><li><a href="DeletedWebApps.html">DeletedWebApps</a><ul class='methods'><li data-type='method'><a href="DeletedWebApps.html#list">list</a></li><li data-type='method'><a href="DeletedWebApps.html#listByResourceGroup">listByResourceGroup</a></li><li data-type='method'><a href="DeletedWebApps.html#listByResourceGroupNext">listByResourceGroupNext</a></li><li data-type='method'><a href="DeletedWebApps.html#listByResourceGroupNextWithHttpOperationResponse">listByResourceGroupNextWithHttpOperationResponse</a></li><li data-type='method'><a href="DeletedWebApps.html#listByResourceGroupWithHttpOperationResponse">listByResourceGroupWithHttpOperationResponse</a></li><li data-type='method'><a href="DeletedWebApps.html#listNext">listNext</a></li><li data-type='method'><a href="DeletedWebApps.html#listNextWithHttpOperationResponse">listNextWithHttpOperationResponse</a></li><li data-type='method'><a href="DeletedWebApps.html#listWithHttpOperationResponse">listWithHttpOperationResponse</a></li></ul></li><li><a href="Domains.html">Domains</a><ul class='methods'><li data-type='method'><a href="Domains.html#beginCreateOrUpdate">beginCreateOrUpdate</a></li><li data-type='method'><a href="Domains.html#beginCreateOrUpdateWithHttpOperationResponse">beginCreateOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#checkAvailability">checkAvailability</a></li><li data-type='method'><a href="Domains.html#checkAvailabilityWithHttpOperationResponse">checkAvailabilityWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#createOrUpdate">createOrUpdate</a></li><li data-type='method'><a href="Domains.html#createOrUpdateOwnershipIdentifier">createOrUpdateOwnershipIdentifier</a></li><li data-type='method'><a href="Domains.html#createOrUpdateOwnershipIdentifierWithHttpOperationResponse">createOrUpdateOwnershipIdentifierWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#createOrUpdateWithHttpOperationResponse">createOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#deleteMethod">deleteMethod</a></li><li data-type='method'><a href="Domains.html#deleteMethodWithHttpOperationResponse">deleteMethodWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#deleteOwnershipIdentifier">deleteOwnershipIdentifier</a></li><li data-type='method'><a href="Domains.html#deleteOwnershipIdentifierWithHttpOperationResponse">deleteOwnershipIdentifierWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#get">get</a></li><li data-type='method'><a href="Domains.html#getControlCenterSsoRequest">getControlCenterSsoRequest</a></li><li data-type='method'><a href="Domains.html#getControlCenterSsoRequestWithHttpOperationResponse">getControlCenterSsoRequestWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#getOwnershipIdentifier">getOwnershipIdentifier</a></li><li data-type='method'><a href="Domains.html#getOwnershipIdentifierWithHttpOperationResponse">getOwnershipIdentifierWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#getWithHttpOperationResponse">getWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#list">list</a></li><li data-type='method'><a href="Domains.html#listByResourceGroup">listByResourceGroup</a></li><li data-type='method'><a href="Domains.html#listByResourceGroupNext">listByResourceGroupNext</a></li><li data-type='method'><a href="Domains.html#listByResourceGroupNextWithHttpOperationResponse">listByResourceGroupNextWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#listByResourceGroupWithHttpOperationResponse">listByResourceGroupWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#listNext">listNext</a></li><li data-type='method'><a href="Domains.html#listNextWithHttpOperationResponse">listNextWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#listOwnershipIdentifiers">listOwnershipIdentifiers</a></li><li data-type='method'><a href="Domains.html#listOwnershipIdentifiersNext">listOwnershipIdentifiersNext</a></li><li data-type='method'><a href="Domains.html#listOwnershipIdentifiersNextWithHttpOperationResponse">listOwnershipIdentifiersNextWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#listOwnershipIdentifiersWithHttpOperationResponse">listOwnershipIdentifiersWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#listRecommendations">listRecommendations</a></li><li data-type='method'><a href="Domains.html#listRecommendationsNext">listRecommendationsNext</a></li><li data-type='method'><a href="Domains.html#listRecommendationsNextWithHttpOperationResponse">listRecommendationsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#listRecommendationsWithHttpOperationResponse">listRecommendationsWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#listWithHttpOperationResponse">listWithHttpOperationResponse</a></li><li data-type='method'><a href="Domains.html#updateOwnershipIdentifier">updateOwnershipIdentifier</a></li><li data-type='method'><a href="Domains.html#updateOwnershipIdentifierWithHttpOperationResponse">updateOwnershipIdentifierWithHttpOperationResponse</a></li></ul></li><li><a href="Recommendations.html">Recommendations</a><ul class='methods'><li data-type='method'><a href="Recommendations.html#disableAllForWebApp">disableAllForWebApp</a></li><li data-type='method'><a href="Recommendations.html#disableAllForWebAppWithHttpOperationResponse">disableAllForWebAppWithHttpOperationResponse</a></li><li data-type='method'><a href="Recommendations.html#getRuleDetailsByWebApp">getRuleDetailsByWebApp</a></li><li data-type='method'><a href="Recommendations.html#getRuleDetailsByWebAppWithHttpOperationResponse">getRuleDetailsByWebAppWithHttpOperationResponse</a></li><li data-type='method'><a href="Recommendations.html#list">list</a></li><li data-type='method'><a href="Recommendations.html#listHistoryForWebApp">listHistoryForWebApp</a></li><li data-type='method'><a href="Recommendations.html#listHistoryForWebAppWithHttpOperationResponse">listHistoryForWebAppWithHttpOperationResponse</a></li><li data-type='method'><a href="Recommendations.html#listRecommendedRulesForWebApp">listRecommendedRulesForWebApp</a></li><li data-type='method'><a href="Recommendations.html#listRecommendedRulesForWebAppWithHttpOperationResponse">listRecommendedRulesForWebAppWithHttpOperationResponse</a></li><li data-type='method'><a href="Recommendations.html#listWithHttpOperationResponse">listWithHttpOperationResponse</a></li><li data-type='method'><a href="Recommendations.html#resetAllFilters">resetAllFilters</a></li><li data-type='method'><a href="Recommendations.html#resetAllFiltersForWebApp">resetAllFiltersForWebApp</a></li><li data-type='method'><a href="Recommendations.html#resetAllFiltersForWebAppWithHttpOperationResponse">resetAllFiltersForWebAppWithHttpOperationResponse</a></li><li data-type='method'><a href="Recommendations.html#resetAllFiltersWithHttpOperationResponse">resetAllFiltersWithHttpOperationResponse</a></li></ul></li><li><a href="TopLevelDomains.html">TopLevelDomains</a><ul class='methods'><li data-type='method'><a href="TopLevelDomains.html#get">get</a></li><li data-type='method'><a href="TopLevelDomains.html#getWithHttpOperationResponse">getWithHttpOperationResponse</a></li><li data-type='method'><a href="TopLevelDomains.html#list">list</a></li><li data-type='method'><a href="TopLevelDomains.html#listAgreements">listAgreements</a></li><li data-type='method'><a href="TopLevelDomains.html#listAgreementsNext">listAgreementsNext</a></li><li data-type='method'><a href="TopLevelDomains.html#listAgreementsNextWithHttpOperationResponse">listAgreementsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="TopLevelDomains.html#listAgreementsWithHttpOperationResponse">listAgreementsWithHttpOperationResponse</a></li><li data-type='method'><a href="TopLevelDomains.html#listNext">listNext</a></li><li data-type='method'><a href="TopLevelDomains.html#listNextWithHttpOperationResponse">listNextWithHttpOperationResponse</a></li><li data-type='method'><a href="TopLevelDomains.html#listWithHttpOperationResponse">listWithHttpOperationResponse</a></li></ul></li><li><a href="WebApps.html">WebApps</a><ul class='methods'><li data-type='method'><a href="WebApps.html#addPremierAddOn">addPremierAddOn</a></li><li data-type='method'><a href="WebApps.html#addPremierAddOnSlot">addPremierAddOnSlot</a></li><li data-type='method'><a href="WebApps.html#addPremierAddOnSlotWithHttpOperationResponse">addPremierAddOnSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#addPremierAddOnWithHttpOperationResponse">addPremierAddOnWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#analyzeCustomHostname">analyzeCustomHostname</a></li><li data-type='method'><a href="WebApps.html#analyzeCustomHostnameSlot">analyzeCustomHostnameSlot</a></li><li data-type='method'><a href="WebApps.html#analyzeCustomHostnameSlotWithHttpOperationResponse">analyzeCustomHostnameSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#analyzeCustomHostnameWithHttpOperationResponse">analyzeCustomHostnameWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#applySlotConfigToProduction">applySlotConfigToProduction</a></li><li data-type='method'><a href="WebApps.html#applySlotConfigToProductionWithHttpOperationResponse">applySlotConfigToProductionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#applySlotConfigurationSlot">applySlotConfigurationSlot</a></li><li data-type='method'><a href="WebApps.html#applySlotConfigurationSlotWithHttpOperationResponse">applySlotConfigurationSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#backup">backup</a></li><li data-type='method'><a href="WebApps.html#backupSlot">backupSlot</a></li><li data-type='method'><a href="WebApps.html#backupSlotWithHttpOperationResponse">backupSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#backupWithHttpOperationResponse">backupWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginCreateOrUpdate">beginCreateOrUpdate</a></li><li data-type='method'><a href="WebApps.html#beginCreateOrUpdateSlot">beginCreateOrUpdateSlot</a></li><li data-type='method'><a href="WebApps.html#beginCreateOrUpdateSlotWithHttpOperationResponse">beginCreateOrUpdateSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginCreateOrUpdateSourceControl">beginCreateOrUpdateSourceControl</a></li><li data-type='method'><a href="WebApps.html#beginCreateOrUpdateSourceControlSlot">beginCreateOrUpdateSourceControlSlot</a></li><li data-type='method'><a href="WebApps.html#beginCreateOrUpdateSourceControlSlotWithHttpOperationResponse">beginCreateOrUpdateSourceControlSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginCreateOrUpdateSourceControlWithHttpOperationResponse">beginCreateOrUpdateSourceControlWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginCreateOrUpdateWithHttpOperationResponse">beginCreateOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginListPublishingCredentials">beginListPublishingCredentials</a></li><li data-type='method'><a href="WebApps.html#beginListPublishingCredentialsSlot">beginListPublishingCredentialsSlot</a></li><li data-type='method'><a href="WebApps.html#beginListPublishingCredentialsSlotWithHttpOperationResponse">beginListPublishingCredentialsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginListPublishingCredentialsWithHttpOperationResponse">beginListPublishingCredentialsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginMigrateMySql">beginMigrateMySql</a></li><li data-type='method'><a href="WebApps.html#beginMigrateMySqlWithHttpOperationResponse">beginMigrateMySqlWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginMigrateStorage">beginMigrateStorage</a></li><li data-type='method'><a href="WebApps.html#beginMigrateStorageWithHttpOperationResponse">beginMigrateStorageWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginRecover">beginRecover</a></li><li data-type='method'><a href="WebApps.html#beginRecoverSlot">beginRecoverSlot</a></li><li data-type='method'><a href="WebApps.html#beginRecoverSlotWithHttpOperationResponse">beginRecoverSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginRecoverWithHttpOperationResponse">beginRecoverWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginRestore">beginRestore</a></li><li data-type='method'><a href="WebApps.html#beginRestoreSlot">beginRestoreSlot</a></li><li data-type='method'><a href="WebApps.html#beginRestoreSlotWithHttpOperationResponse">beginRestoreSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginRestoreWithHttpOperationResponse">beginRestoreWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginSwapSlotSlot">beginSwapSlotSlot</a></li><li data-type='method'><a href="WebApps.html#beginSwapSlotSlotWithHttpOperationResponse">beginSwapSlotSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#beginSwapSlotWithProduction">beginSwapSlotWithProduction</a></li><li data-type='method'><a href="WebApps.html#beginSwapSlotWithProductionWithHttpOperationResponse">beginSwapSlotWithProductionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createDeployment">createDeployment</a></li><li data-type='method'><a href="WebApps.html#createDeploymentSlot">createDeploymentSlot</a></li><li data-type='method'><a href="WebApps.html#createDeploymentSlotWithHttpOperationResponse">createDeploymentSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createDeploymentWithHttpOperationResponse">createDeploymentWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createInstanceDeployment">createInstanceDeployment</a></li><li data-type='method'><a href="WebApps.html#createInstanceDeploymentSlot">createInstanceDeploymentSlot</a></li><li data-type='method'><a href="WebApps.html#createInstanceDeploymentSlotWithHttpOperationResponse">createInstanceDeploymentSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createInstanceDeploymentWithHttpOperationResponse">createInstanceDeploymentWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdate">createOrUpdate</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateConfiguration">createOrUpdateConfiguration</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateConfigurationSlot">createOrUpdateConfigurationSlot</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateConfigurationSlotWithHttpOperationResponse">createOrUpdateConfigurationSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateConfigurationWithHttpOperationResponse">createOrUpdateConfigurationWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateDomainOwnershipIdentifier">createOrUpdateDomainOwnershipIdentifier</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateDomainOwnershipIdentifierSlot">createOrUpdateDomainOwnershipIdentifierSlot</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateDomainOwnershipIdentifierSlotWithHttpOperationResponse">createOrUpdateDomainOwnershipIdentifierSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateDomainOwnershipIdentifierWithHttpOperationResponse">createOrUpdateDomainOwnershipIdentifierWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateHostNameBinding">createOrUpdateHostNameBinding</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateHostNameBindingSlot">createOrUpdateHostNameBindingSlot</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateHostNameBindingSlotWithHttpOperationResponse">createOrUpdateHostNameBindingSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateHostNameBindingWithHttpOperationResponse">createOrUpdateHostNameBindingWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateHybridConnection">createOrUpdateHybridConnection</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateHybridConnectionSlot">createOrUpdateHybridConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateHybridConnectionSlotWithHttpOperationResponse">createOrUpdateHybridConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateHybridConnectionWithHttpOperationResponse">createOrUpdateHybridConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateRelayServiceConnection">createOrUpdateRelayServiceConnection</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateRelayServiceConnectionSlot">createOrUpdateRelayServiceConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateRelayServiceConnectionSlotWithHttpOperationResponse">createOrUpdateRelayServiceConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateRelayServiceConnectionWithHttpOperationResponse">createOrUpdateRelayServiceConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateSlot">createOrUpdateSlot</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateSlotWithHttpOperationResponse">createOrUpdateSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateSourceControl">createOrUpdateSourceControl</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateSourceControlSlot">createOrUpdateSourceControlSlot</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateSourceControlSlotWithHttpOperationResponse">createOrUpdateSourceControlSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateSourceControlWithHttpOperationResponse">createOrUpdateSourceControlWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateVnetConnection">createOrUpdateVnetConnection</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateVnetConnectionGateway">createOrUpdateVnetConnectionGateway</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateVnetConnectionGatewaySlot">createOrUpdateVnetConnectionGatewaySlot</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateVnetConnectionGatewaySlotWithHttpOperationResponse">createOrUpdateVnetConnectionGatewaySlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateVnetConnectionGatewayWithHttpOperationResponse">createOrUpdateVnetConnectionGatewayWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateVnetConnectionSlot">createOrUpdateVnetConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateVnetConnectionSlotWithHttpOperationResponse">createOrUpdateVnetConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateVnetConnectionWithHttpOperationResponse">createOrUpdateVnetConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#createOrUpdateWithHttpOperationResponse">createOrUpdateWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteBackup">deleteBackup</a></li><li data-type='method'><a href="WebApps.html#deleteBackupConfiguration">deleteBackupConfiguration</a></li><li data-type='method'><a href="WebApps.html#deleteBackupConfigurationSlot">deleteBackupConfigurationSlot</a></li><li data-type='method'><a href="WebApps.html#deleteBackupConfigurationSlotWithHttpOperationResponse">deleteBackupConfigurationSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteBackupConfigurationWithHttpOperationResponse">deleteBackupConfigurationWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteBackupSlot">deleteBackupSlot</a></li><li data-type='method'><a href="WebApps.html#deleteBackupSlotWithHttpOperationResponse">deleteBackupSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteBackupWithHttpOperationResponse">deleteBackupWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteDeployment">deleteDeployment</a></li><li data-type='method'><a href="WebApps.html#deleteDeploymentSlot">deleteDeploymentSlot</a></li><li data-type='method'><a href="WebApps.html#deleteDeploymentSlotWithHttpOperationResponse">deleteDeploymentSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteDeploymentWithHttpOperationResponse">deleteDeploymentWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteDomainOwnershipIdentifier">deleteDomainOwnershipIdentifier</a></li><li data-type='method'><a href="WebApps.html#deleteDomainOwnershipIdentifierSlot">deleteDomainOwnershipIdentifierSlot</a></li><li data-type='method'><a href="WebApps.html#deleteDomainOwnershipIdentifierSlotWithHttpOperationResponse">deleteDomainOwnershipIdentifierSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteDomainOwnershipIdentifierWithHttpOperationResponse">deleteDomainOwnershipIdentifierWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteHostNameBinding">deleteHostNameBinding</a></li><li data-type='method'><a href="WebApps.html#deleteHostNameBindingSlot">deleteHostNameBindingSlot</a></li><li data-type='method'><a href="WebApps.html#deleteHostNameBindingSlotWithHttpOperationResponse">deleteHostNameBindingSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteHostNameBindingWithHttpOperationResponse">deleteHostNameBindingWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteHybridConnection">deleteHybridConnection</a></li><li data-type='method'><a href="WebApps.html#deleteHybridConnectionSlot">deleteHybridConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#deleteHybridConnectionSlotWithHttpOperationResponse">deleteHybridConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteHybridConnectionWithHttpOperationResponse">deleteHybridConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteInstanceDeployment">deleteInstanceDeployment</a></li><li data-type='method'><a href="WebApps.html#deleteInstanceDeploymentSlot">deleteInstanceDeploymentSlot</a></li><li data-type='method'><a href="WebApps.html#deleteInstanceDeploymentSlotWithHttpOperationResponse">deleteInstanceDeploymentSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteInstanceDeploymentWithHttpOperationResponse">deleteInstanceDeploymentWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteMethod">deleteMethod</a></li><li data-type='method'><a href="WebApps.html#deleteMethodWithHttpOperationResponse">deleteMethodWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deletePremierAddOn">deletePremierAddOn</a></li><li data-type='method'><a href="WebApps.html#deletePremierAddOnSlot">deletePremierAddOnSlot</a></li><li data-type='method'><a href="WebApps.html#deletePremierAddOnSlotWithHttpOperationResponse">deletePremierAddOnSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deletePremierAddOnWithHttpOperationResponse">deletePremierAddOnWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteRelayServiceConnection">deleteRelayServiceConnection</a></li><li data-type='method'><a href="WebApps.html#deleteRelayServiceConnectionSlot">deleteRelayServiceConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#deleteRelayServiceConnectionSlotWithHttpOperationResponse">deleteRelayServiceConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteRelayServiceConnectionWithHttpOperationResponse">deleteRelayServiceConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteSlot">deleteSlot</a></li><li data-type='method'><a href="WebApps.html#deleteSlotWithHttpOperationResponse">deleteSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteSourceControl">deleteSourceControl</a></li><li data-type='method'><a href="WebApps.html#deleteSourceControlSlot">deleteSourceControlSlot</a></li><li data-type='method'><a href="WebApps.html#deleteSourceControlSlotWithHttpOperationResponse">deleteSourceControlSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteSourceControlWithHttpOperationResponse">deleteSourceControlWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteVnetConnection">deleteVnetConnection</a></li><li data-type='method'><a href="WebApps.html#deleteVnetConnectionSlot">deleteVnetConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#deleteVnetConnectionSlotWithHttpOperationResponse">deleteVnetConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#deleteVnetConnectionWithHttpOperationResponse">deleteVnetConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#discoverRestore">discoverRestore</a></li><li data-type='method'><a href="WebApps.html#discoverRestoreSlot">discoverRestoreSlot</a></li><li data-type='method'><a href="WebApps.html#discoverRestoreSlotWithHttpOperationResponse">discoverRestoreSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#discoverRestoreWithHttpOperationResponse">discoverRestoreWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#generateNewSitePublishingPassword">generateNewSitePublishingPassword</a></li><li data-type='method'><a href="WebApps.html#generateNewSitePublishingPasswordSlot">generateNewSitePublishingPasswordSlot</a></li><li data-type='method'><a href="WebApps.html#generateNewSitePublishingPasswordSlotWithHttpOperationResponse">generateNewSitePublishingPasswordSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#generateNewSitePublishingPasswordWithHttpOperationResponse">generateNewSitePublishingPasswordWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#get">get</a></li><li data-type='method'><a href="WebApps.html#getAuthSettings">getAuthSettings</a></li><li data-type='method'><a href="WebApps.html#getAuthSettingsSlot">getAuthSettingsSlot</a></li><li data-type='method'><a href="WebApps.html#getAuthSettingsSlotWithHttpOperationResponse">getAuthSettingsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getAuthSettingsWithHttpOperationResponse">getAuthSettingsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getBackupConfiguration">getBackupConfiguration</a></li><li data-type='method'><a href="WebApps.html#getBackupConfigurationSlot">getBackupConfigurationSlot</a></li><li data-type='method'><a href="WebApps.html#getBackupConfigurationSlotWithHttpOperationResponse">getBackupConfigurationSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getBackupConfigurationWithHttpOperationResponse">getBackupConfigurationWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getBackupStatus">getBackupStatus</a></li><li data-type='method'><a href="WebApps.html#getBackupStatusSlot">getBackupStatusSlot</a></li><li data-type='method'><a href="WebApps.html#getBackupStatusSlotWithHttpOperationResponse">getBackupStatusSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getBackupStatusWithHttpOperationResponse">getBackupStatusWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getConfiguration">getConfiguration</a></li><li data-type='method'><a href="WebApps.html#getConfigurationSlot">getConfigurationSlot</a></li><li data-type='method'><a href="WebApps.html#getConfigurationSlotWithHttpOperationResponse">getConfigurationSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getConfigurationSnapshot">getConfigurationSnapshot</a></li><li data-type='method'><a href="WebApps.html#getConfigurationSnapshotSlot">getConfigurationSnapshotSlot</a></li><li data-type='method'><a href="WebApps.html#getConfigurationSnapshotSlotWithHttpOperationResponse">getConfigurationSnapshotSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getConfigurationSnapshotWithHttpOperationResponse">getConfigurationSnapshotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getConfigurationWithHttpOperationResponse">getConfigurationWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getDeployment">getDeployment</a></li><li data-type='method'><a href="WebApps.html#getDeploymentSlot">getDeploymentSlot</a></li><li data-type='method'><a href="WebApps.html#getDeploymentSlotWithHttpOperationResponse">getDeploymentSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getDeploymentWithHttpOperationResponse">getDeploymentWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getDiagnosticLogsConfiguration">getDiagnosticLogsConfiguration</a></li><li data-type='method'><a href="WebApps.html#getDiagnosticLogsConfigurationSlot">getDiagnosticLogsConfigurationSlot</a></li><li data-type='method'><a href="WebApps.html#getDiagnosticLogsConfigurationSlotWithHttpOperationResponse">getDiagnosticLogsConfigurationSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getDiagnosticLogsConfigurationWithHttpOperationResponse">getDiagnosticLogsConfigurationWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getDomainOwnershipIdentifier">getDomainOwnershipIdentifier</a></li><li data-type='method'><a href="WebApps.html#getDomainOwnershipIdentifierSlot">getDomainOwnershipIdentifierSlot</a></li><li data-type='method'><a href="WebApps.html#getDomainOwnershipIdentifierSlotWithHttpOperationResponse">getDomainOwnershipIdentifierSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getDomainOwnershipIdentifierWithHttpOperationResponse">getDomainOwnershipIdentifierWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getHostNameBinding">getHostNameBinding</a></li><li data-type='method'><a href="WebApps.html#getHostNameBindingSlot">getHostNameBindingSlot</a></li><li data-type='method'><a href="WebApps.html#getHostNameBindingSlotWithHttpOperationResponse">getHostNameBindingSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getHostNameBindingWithHttpOperationResponse">getHostNameBindingWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getHybridConnection">getHybridConnection</a></li><li data-type='method'><a href="WebApps.html#getHybridConnectionSlot">getHybridConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#getHybridConnectionSlotWithHttpOperationResponse">getHybridConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getHybridConnectionWithHttpOperationResponse">getHybridConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getInstanceDeployment">getInstanceDeployment</a></li><li data-type='method'><a href="WebApps.html#getInstanceDeploymentSlot">getInstanceDeploymentSlot</a></li><li data-type='method'><a href="WebApps.html#getInstanceDeploymentSlotWithHttpOperationResponse">getInstanceDeploymentSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getInstanceDeploymentWithHttpOperationResponse">getInstanceDeploymentWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getMigrateMySqlStatus">getMigrateMySqlStatus</a></li><li data-type='method'><a href="WebApps.html#getMigrateMySqlStatusSlot">getMigrateMySqlStatusSlot</a></li><li data-type='method'><a href="WebApps.html#getMigrateMySqlStatusSlotWithHttpOperationResponse">getMigrateMySqlStatusSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getMigrateMySqlStatusWithHttpOperationResponse">getMigrateMySqlStatusWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getPremierAddOn">getPremierAddOn</a></li><li data-type='method'><a href="WebApps.html#getPremierAddOnSlot">getPremierAddOnSlot</a></li><li data-type='method'><a href="WebApps.html#getPremierAddOnSlotWithHttpOperationResponse">getPremierAddOnSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getPremierAddOnWithHttpOperationResponse">getPremierAddOnWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getRelayServiceConnection">getRelayServiceConnection</a></li><li data-type='method'><a href="WebApps.html#getRelayServiceConnectionSlot">getRelayServiceConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#getRelayServiceConnectionSlotWithHttpOperationResponse">getRelayServiceConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getRelayServiceConnectionWithHttpOperationResponse">getRelayServiceConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getSitePhpErrorLogFlag">getSitePhpErrorLogFlag</a></li><li data-type='method'><a href="WebApps.html#getSitePhpErrorLogFlagSlot">getSitePhpErrorLogFlagSlot</a></li><li data-type='method'><a href="WebApps.html#getSitePhpErrorLogFlagSlotWithHttpOperationResponse">getSitePhpErrorLogFlagSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getSitePhpErrorLogFlagWithHttpOperationResponse">getSitePhpErrorLogFlagWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getSlot">getSlot</a></li><li data-type='method'><a href="WebApps.html#getSlotWithHttpOperationResponse">getSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getSourceControl">getSourceControl</a></li><li data-type='method'><a href="WebApps.html#getSourceControlSlot">getSourceControlSlot</a></li><li data-type='method'><a href="WebApps.html#getSourceControlSlotWithHttpOperationResponse">getSourceControlSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getSourceControlWithHttpOperationResponse">getSourceControlWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getVnetConnection">getVnetConnection</a></li><li data-type='method'><a href="WebApps.html#getVnetConnectionGateway">getVnetConnectionGateway</a></li><li data-type='method'><a href="WebApps.html#getVnetConnectionGatewaySlot">getVnetConnectionGatewaySlot</a></li><li data-type='method'><a href="WebApps.html#getVnetConnectionGatewaySlotWithHttpOperationResponse">getVnetConnectionGatewaySlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getVnetConnectionGatewayWithHttpOperationResponse">getVnetConnectionGatewayWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getVnetConnectionSlot">getVnetConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#getVnetConnectionSlotWithHttpOperationResponse">getVnetConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getVnetConnectionWithHttpOperationResponse">getVnetConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#getWithHttpOperationResponse">getWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#isCloneable">isCloneable</a></li><li data-type='method'><a href="WebApps.html#isCloneableSlot">isCloneableSlot</a></li><li data-type='method'><a href="WebApps.html#isCloneableSlotWithHttpOperationResponse">isCloneableSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#isCloneableWithHttpOperationResponse">isCloneableWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#list">list</a></li><li data-type='method'><a href="WebApps.html#listApplicationSettings">listApplicationSettings</a></li><li data-type='method'><a href="WebApps.html#listApplicationSettingsSlot">listApplicationSettingsSlot</a></li><li data-type='method'><a href="WebApps.html#listApplicationSettingsSlotWithHttpOperationResponse">listApplicationSettingsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listApplicationSettingsWithHttpOperationResponse">listApplicationSettingsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listBackups">listBackups</a></li><li data-type='method'><a href="WebApps.html#listBackupsNext">listBackupsNext</a></li><li data-type='method'><a href="WebApps.html#listBackupsNextWithHttpOperationResponse">listBackupsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listBackupsSlot">listBackupsSlot</a></li><li data-type='method'><a href="WebApps.html#listBackupsSlotNext">listBackupsSlotNext</a></li><li data-type='method'><a href="WebApps.html#listBackupsSlotNextWithHttpOperationResponse">listBackupsSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listBackupsSlotWithHttpOperationResponse">listBackupsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listBackupStatusSecrets">listBackupStatusSecrets</a></li><li data-type='method'><a href="WebApps.html#listBackupStatusSecretsSlot">listBackupStatusSecretsSlot</a></li><li data-type='method'><a href="WebApps.html#listBackupStatusSecretsSlotWithHttpOperationResponse">listBackupStatusSecretsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listBackupStatusSecretsWithHttpOperationResponse">listBackupStatusSecretsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listBackupsWithHttpOperationResponse">listBackupsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listByResourceGroup">listByResourceGroup</a></li><li data-type='method'><a href="WebApps.html#listByResourceGroupNext">listByResourceGroupNext</a></li><li data-type='method'><a href="WebApps.html#listByResourceGroupNextWithHttpOperationResponse">listByResourceGroupNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listByResourceGroupWithHttpOperationResponse">listByResourceGroupWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listConfigurationSnapshotInfo">listConfigurationSnapshotInfo</a></li><li data-type='method'><a href="WebApps.html#listConfigurationSnapshotInfoSlot">listConfigurationSnapshotInfoSlot</a></li><li data-type='method'><a href="WebApps.html#listConfigurationSnapshotInfoSlotWithHttpOperationResponse">listConfigurationSnapshotInfoSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listConfigurationSnapshotInfoWithHttpOperationResponse">listConfigurationSnapshotInfoWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listConnectionStrings">listConnectionStrings</a></li><li data-type='method'><a href="WebApps.html#listConnectionStringsSlot">listConnectionStringsSlot</a></li><li data-type='method'><a href="WebApps.html#listConnectionStringsSlotWithHttpOperationResponse">listConnectionStringsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listConnectionStringsWithHttpOperationResponse">listConnectionStringsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listDeployments">listDeployments</a></li><li data-type='method'><a href="WebApps.html#listDeploymentsNext">listDeploymentsNext</a></li><li data-type='method'><a href="WebApps.html#listDeploymentsNextWithHttpOperationResponse">listDeploymentsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listDeploymentsSlot">listDeploymentsSlot</a></li><li data-type='method'><a href="WebApps.html#listDeploymentsSlotNext">listDeploymentsSlotNext</a></li><li data-type='method'><a href="WebApps.html#listDeploymentsSlotNextWithHttpOperationResponse">listDeploymentsSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listDeploymentsSlotWithHttpOperationResponse">listDeploymentsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listDeploymentsWithHttpOperationResponse">listDeploymentsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listDomainOwnershipIdentifiers">listDomainOwnershipIdentifiers</a></li><li data-type='method'><a href="WebApps.html#listDomainOwnershipIdentifiersNext">listDomainOwnershipIdentifiersNext</a></li><li data-type='method'><a href="WebApps.html#listDomainOwnershipIdentifiersNextWithHttpOperationResponse">listDomainOwnershipIdentifiersNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listDomainOwnershipIdentifiersSlot">listDomainOwnershipIdentifiersSlot</a></li><li data-type='method'><a href="WebApps.html#listDomainOwnershipIdentifiersSlotNext">listDomainOwnershipIdentifiersSlotNext</a></li><li data-type='method'><a href="WebApps.html#listDomainOwnershipIdentifiersSlotNextWithHttpOperationResponse">listDomainOwnershipIdentifiersSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listDomainOwnershipIdentifiersSlotWithHttpOperationResponse">listDomainOwnershipIdentifiersSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listDomainOwnershipIdentifiersWithHttpOperationResponse">listDomainOwnershipIdentifiersWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listHostNameBindings">listHostNameBindings</a></li><li data-type='method'><a href="WebApps.html#listHostNameBindingsNext">listHostNameBindingsNext</a></li><li data-type='method'><a href="WebApps.html#listHostNameBindingsNextWithHttpOperationResponse">listHostNameBindingsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listHostNameBindingsSlot">listHostNameBindingsSlot</a></li><li data-type='method'><a href="WebApps.html#listHostNameBindingsSlotNext">listHostNameBindingsSlotNext</a></li><li data-type='method'><a href="WebApps.html#listHostNameBindingsSlotNextWithHttpOperationResponse">listHostNameBindingsSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listHostNameBindingsSlotWithHttpOperationResponse">listHostNameBindingsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listHostNameBindingsWithHttpOperationResponse">listHostNameBindingsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listHybridConnectionKeys">listHybridConnectionKeys</a></li><li data-type='method'><a href="WebApps.html#listHybridConnectionKeysSlot">listHybridConnectionKeysSlot</a></li><li data-type='method'><a href="WebApps.html#listHybridConnectionKeysSlotWithHttpOperationResponse">listHybridConnectionKeysSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listHybridConnectionKeysWithHttpOperationResponse">listHybridConnectionKeysWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listHybridConnections">listHybridConnections</a></li><li data-type='method'><a href="WebApps.html#listHybridConnectionsSlot">listHybridConnectionsSlot</a></li><li data-type='method'><a href="WebApps.html#listHybridConnectionsSlotWithHttpOperationResponse">listHybridConnectionsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listHybridConnectionsWithHttpOperationResponse">listHybridConnectionsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listInstanceDeployments">listInstanceDeployments</a></li><li data-type='method'><a href="WebApps.html#listInstanceDeploymentsNext">listInstanceDeploymentsNext</a></li><li data-type='method'><a href="WebApps.html#listInstanceDeploymentsNextWithHttpOperationResponse">listInstanceDeploymentsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listInstanceDeploymentsSlot">listInstanceDeploymentsSlot</a></li><li data-type='method'><a href="WebApps.html#listInstanceDeploymentsSlotNext">listInstanceDeploymentsSlotNext</a></li><li data-type='method'><a href="WebApps.html#listInstanceDeploymentsSlotNextWithHttpOperationResponse">listInstanceDeploymentsSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listInstanceDeploymentsSlotWithHttpOperationResponse">listInstanceDeploymentsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listInstanceDeploymentsWithHttpOperationResponse">listInstanceDeploymentsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listInstanceIdentifiers">listInstanceIdentifiers</a></li><li data-type='method'><a href="WebApps.html#listInstanceIdentifiersNext">listInstanceIdentifiersNext</a></li><li data-type='method'><a href="WebApps.html#listInstanceIdentifiersNextWithHttpOperationResponse">listInstanceIdentifiersNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listInstanceIdentifiersSlot">listInstanceIdentifiersSlot</a></li><li data-type='method'><a href="WebApps.html#listInstanceIdentifiersSlotNext">listInstanceIdentifiersSlotNext</a></li><li data-type='method'><a href="WebApps.html#listInstanceIdentifiersSlotNextWithHttpOperationResponse">listInstanceIdentifiersSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listInstanceIdentifiersSlotWithHttpOperationResponse">listInstanceIdentifiersSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listInstanceIdentifiersWithHttpOperationResponse">listInstanceIdentifiersWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listMetadata">listMetadata</a></li><li data-type='method'><a href="WebApps.html#listMetadataSlot">listMetadataSlot</a></li><li data-type='method'><a href="WebApps.html#listMetadataSlotWithHttpOperationResponse">listMetadataSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listMetadataWithHttpOperationResponse">listMetadataWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listMetricDefinitions">listMetricDefinitions</a></li><li data-type='method'><a href="WebApps.html#listMetricDefinitionsNext">listMetricDefinitionsNext</a></li><li data-type='method'><a href="WebApps.html#listMetricDefinitionsNextWithHttpOperationResponse">listMetricDefinitionsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listMetricDefinitionsSlot">listMetricDefinitionsSlot</a></li><li data-type='method'><a href="WebApps.html#listMetricDefinitionsSlotNext">listMetricDefinitionsSlotNext</a></li><li data-type='method'><a href="WebApps.html#listMetricDefinitionsSlotNextWithHttpOperationResponse">listMetricDefinitionsSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listMetricDefinitionsSlotWithHttpOperationResponse">listMetricDefinitionsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listMetricDefinitionsWithHttpOperationResponse">listMetricDefinitionsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listMetrics">listMetrics</a></li><li data-type='method'><a href="WebApps.html#listMetricsNext">listMetricsNext</a></li><li data-type='method'><a href="WebApps.html#listMetricsNextWithHttpOperationResponse">listMetricsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listMetricsSlot">listMetricsSlot</a></li><li data-type='method'><a href="WebApps.html#listMetricsSlotNext">listMetricsSlotNext</a></li><li data-type='method'><a href="WebApps.html#listMetricsSlotNextWithHttpOperationResponse">listMetricsSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listMetricsSlotWithHttpOperationResponse">listMetricsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listMetricsWithHttpOperationResponse">listMetricsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listNetworkFeatures">listNetworkFeatures</a></li><li data-type='method'><a href="WebApps.html#listNetworkFeaturesSlot">listNetworkFeaturesSlot</a></li><li data-type='method'><a href="WebApps.html#listNetworkFeaturesSlotWithHttpOperationResponse">listNetworkFeaturesSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listNetworkFeaturesWithHttpOperationResponse">listNetworkFeaturesWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listNext">listNext</a></li><li data-type='method'><a href="WebApps.html#listNextWithHttpOperationResponse">listNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listPerfMonCounters">listPerfMonCounters</a></li><li data-type='method'><a href="WebApps.html#listPerfMonCountersNext">listPerfMonCountersNext</a></li><li data-type='method'><a href="WebApps.html#listPerfMonCountersNextWithHttpOperationResponse">listPerfMonCountersNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listPerfMonCountersSlot">listPerfMonCountersSlot</a></li><li data-type='method'><a href="WebApps.html#listPerfMonCountersSlotNext">listPerfMonCountersSlotNext</a></li><li data-type='method'><a href="WebApps.html#listPerfMonCountersSlotNextWithHttpOperationResponse">listPerfMonCountersSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listPerfMonCountersSlotWithHttpOperationResponse">listPerfMonCountersSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listPerfMonCountersWithHttpOperationResponse">listPerfMonCountersWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listPremierAddOns">listPremierAddOns</a></li><li data-type='method'><a href="WebApps.html#listPremierAddOnsSlot">listPremierAddOnsSlot</a></li><li data-type='method'><a href="WebApps.html#listPremierAddOnsSlotWithHttpOperationResponse">listPremierAddOnsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listPremierAddOnsWithHttpOperationResponse">listPremierAddOnsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listPublishingCredentials">listPublishingCredentials</a></li><li data-type='method'><a href="WebApps.html#listPublishingCredentialsSlot">listPublishingCredentialsSlot</a></li><li data-type='method'><a href="WebApps.html#listPublishingCredentialsSlotWithHttpOperationResponse">listPublishingCredentialsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listPublishingCredentialsWithHttpOperationResponse">listPublishingCredentialsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listPublishingProfileXmlWithSecrets">listPublishingProfileXmlWithSecrets</a></li><li data-type='method'><a href="WebApps.html#listPublishingProfileXmlWithSecretsSlot">listPublishingProfileXmlWithSecretsSlot</a></li><li data-type='method'><a href="WebApps.html#listPublishingProfileXmlWithSecretsSlotWithHttpOperationResponse">listPublishingProfileXmlWithSecretsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listPublishingProfileXmlWithSecretsWithHttpOperationResponse">listPublishingProfileXmlWithSecretsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listRelayServiceConnections">listRelayServiceConnections</a></li><li data-type='method'><a href="WebApps.html#listRelayServiceConnectionsSlot">listRelayServiceConnectionsSlot</a></li><li data-type='method'><a href="WebApps.html#listRelayServiceConnectionsSlotWithHttpOperationResponse">listRelayServiceConnectionsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listRelayServiceConnectionsWithHttpOperationResponse">listRelayServiceConnectionsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSitePushSettings">listSitePushSettings</a></li><li data-type='method'><a href="WebApps.html#listSitePushSettingsSlot">listSitePushSettingsSlot</a></li><li data-type='method'><a href="WebApps.html#listSitePushSettingsSlotWithHttpOperationResponse">listSitePushSettingsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSitePushSettingsWithHttpOperationResponse">listSitePushSettingsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSlotConfigurationNames">listSlotConfigurationNames</a></li><li data-type='method'><a href="WebApps.html#listSlotConfigurationNamesWithHttpOperationResponse">listSlotConfigurationNamesWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSlotDifferencesFromProduction">listSlotDifferencesFromProduction</a></li><li data-type='method'><a href="WebApps.html#listSlotDifferencesFromProductionNext">listSlotDifferencesFromProductionNext</a></li><li data-type='method'><a href="WebApps.html#listSlotDifferencesFromProductionNextWithHttpOperationResponse">listSlotDifferencesFromProductionNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSlotDifferencesFromProductionWithHttpOperationResponse">listSlotDifferencesFromProductionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSlotDifferencesSlot">listSlotDifferencesSlot</a></li><li data-type='method'><a href="WebApps.html#listSlotDifferencesSlotNext">listSlotDifferencesSlotNext</a></li><li data-type='method'><a href="WebApps.html#listSlotDifferencesSlotNextWithHttpOperationResponse">listSlotDifferencesSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSlotDifferencesSlotWithHttpOperationResponse">listSlotDifferencesSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSlots">listSlots</a></li><li data-type='method'><a href="WebApps.html#listSlotsNext">listSlotsNext</a></li><li data-type='method'><a href="WebApps.html#listSlotsNextWithHttpOperationResponse">listSlotsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSlotsWithHttpOperationResponse">listSlotsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSnapshots">listSnapshots</a></li><li data-type='method'><a href="WebApps.html#listSnapshotsNext">listSnapshotsNext</a></li><li data-type='method'><a href="WebApps.html#listSnapshotsNextWithHttpOperationResponse">listSnapshotsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSnapshotsSlot">listSnapshotsSlot</a></li><li data-type='method'><a href="WebApps.html#listSnapshotsSlotNext">listSnapshotsSlotNext</a></li><li data-type='method'><a href="WebApps.html#listSnapshotsSlotNextWithHttpOperationResponse">listSnapshotsSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSnapshotsSlotWithHttpOperationResponse">listSnapshotsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listSnapshotsWithHttpOperationResponse">listSnapshotsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listUsages">listUsages</a></li><li data-type='method'><a href="WebApps.html#listUsagesNext">listUsagesNext</a></li><li data-type='method'><a href="WebApps.html#listUsagesNextWithHttpOperationResponse">listUsagesNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listUsagesSlot">listUsagesSlot</a></li><li data-type='method'><a href="WebApps.html#listUsagesSlotNext">listUsagesSlotNext</a></li><li data-type='method'><a href="WebApps.html#listUsagesSlotNextWithHttpOperationResponse">listUsagesSlotNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listUsagesSlotWithHttpOperationResponse">listUsagesSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listUsagesWithHttpOperationResponse">listUsagesWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listVnetConnections">listVnetConnections</a></li><li data-type='method'><a href="WebApps.html#listVnetConnectionsSlot">listVnetConnectionsSlot</a></li><li data-type='method'><a href="WebApps.html#listVnetConnectionsSlotWithHttpOperationResponse">listVnetConnectionsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listVnetConnectionsWithHttpOperationResponse">listVnetConnectionsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#listWithHttpOperationResponse">listWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#migrateMySql">migrateMySql</a></li><li data-type='method'><a href="WebApps.html#migrateMySqlWithHttpOperationResponse">migrateMySqlWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#migrateStorage">migrateStorage</a></li><li data-type='method'><a href="WebApps.html#migrateStorageWithHttpOperationResponse">migrateStorageWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#recover">recover</a></li><li data-type='method'><a href="WebApps.html#recoverSiteConfigurationSnapshot">recoverSiteConfigurationSnapshot</a></li><li data-type='method'><a href="WebApps.html#recoverSiteConfigurationSnapshotSlot">recoverSiteConfigurationSnapshotSlot</a></li><li data-type='method'><a href="WebApps.html#recoverSiteConfigurationSnapshotSlotWithHttpOperationResponse">recoverSiteConfigurationSnapshotSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#recoverSiteConfigurationSnapshotWithHttpOperationResponse">recoverSiteConfigurationSnapshotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#recoverSlot">recoverSlot</a></li><li data-type='method'><a href="WebApps.html#recoverSlotWithHttpOperationResponse">recoverSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#recoverWithHttpOperationResponse">recoverWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#resetProductionSlotConfig">resetProductionSlotConfig</a></li><li data-type='method'><a href="WebApps.html#resetProductionSlotConfigWithHttpOperationResponse">resetProductionSlotConfigWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#resetSlotConfigurationSlot">resetSlotConfigurationSlot</a></li><li data-type='method'><a href="WebApps.html#resetSlotConfigurationSlotWithHttpOperationResponse">resetSlotConfigurationSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#restart">restart</a></li><li data-type='method'><a href="WebApps.html#restartSlot">restartSlot</a></li><li data-type='method'><a href="WebApps.html#restartSlotWithHttpOperationResponse">restartSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#restartWithHttpOperationResponse">restartWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#restore">restore</a></li><li data-type='method'><a href="WebApps.html#restoreSlot">restoreSlot</a></li><li data-type='method'><a href="WebApps.html#restoreSlotWithHttpOperationResponse">restoreSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#restoreWithHttpOperationResponse">restoreWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#start">start</a></li><li data-type='method'><a href="WebApps.html#startSlot">startSlot</a></li><li data-type='method'><a href="WebApps.html#startSlotWithHttpOperationResponse">startSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#startWebSiteNetworkTrace">startWebSiteNetworkTrace</a></li><li data-type='method'><a href="WebApps.html#startWebSiteNetworkTraceSlot">startWebSiteNetworkTraceSlot</a></li><li data-type='method'><a href="WebApps.html#startWebSiteNetworkTraceSlotWithHttpOperationResponse">startWebSiteNetworkTraceSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#startWebSiteNetworkTraceWithHttpOperationResponse">startWebSiteNetworkTraceWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#startWithHttpOperationResponse">startWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#stop">stop</a></li><li data-type='method'><a href="WebApps.html#stopSlot">stopSlot</a></li><li data-type='method'><a href="WebApps.html#stopSlotWithHttpOperationResponse">stopSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#stopWebSiteNetworkTrace">stopWebSiteNetworkTrace</a></li><li data-type='method'><a href="WebApps.html#stopWebSiteNetworkTraceSlot">stopWebSiteNetworkTraceSlot</a></li><li data-type='method'><a href="WebApps.html#stopWebSiteNetworkTraceSlotWithHttpOperationResponse">stopWebSiteNetworkTraceSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#stopWebSiteNetworkTraceWithHttpOperationResponse">stopWebSiteNetworkTraceWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#stopWithHttpOperationResponse">stopWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#swapSlotSlot">swapSlotSlot</a></li><li data-type='method'><a href="WebApps.html#swapSlotSlotWithHttpOperationResponse">swapSlotSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#swapSlotWithProduction">swapSlotWithProduction</a></li><li data-type='method'><a href="WebApps.html#swapSlotWithProductionWithHttpOperationResponse">swapSlotWithProductionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#syncRepository">syncRepository</a></li><li data-type='method'><a href="WebApps.html#syncRepositorySlot">syncRepositorySlot</a></li><li data-type='method'><a href="WebApps.html#syncRepositorySlotWithHttpOperationResponse">syncRepositorySlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#syncRepositoryWithHttpOperationResponse">syncRepositoryWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateApplicationSettings">updateApplicationSettings</a></li><li data-type='method'><a href="WebApps.html#updateApplicationSettingsSlot">updateApplicationSettingsSlot</a></li><li data-type='method'><a href="WebApps.html#updateApplicationSettingsSlotWithHttpOperationResponse">updateApplicationSettingsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateApplicationSettingsWithHttpOperationResponse">updateApplicationSettingsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateAuthSettings">updateAuthSettings</a></li><li data-type='method'><a href="WebApps.html#updateAuthSettingsSlot">updateAuthSettingsSlot</a></li><li data-type='method'><a href="WebApps.html#updateAuthSettingsSlotWithHttpOperationResponse">updateAuthSettingsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateAuthSettingsWithHttpOperationResponse">updateAuthSettingsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateBackupConfiguration">updateBackupConfiguration</a></li><li data-type='method'><a href="WebApps.html#updateBackupConfigurationSlot">updateBackupConfigurationSlot</a></li><li data-type='method'><a href="WebApps.html#updateBackupConfigurationSlotWithHttpOperationResponse">updateBackupConfigurationSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateBackupConfigurationWithHttpOperationResponse">updateBackupConfigurationWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateConfiguration">updateConfiguration</a></li><li data-type='method'><a href="WebApps.html#updateConfigurationSlot">updateConfigurationSlot</a></li><li data-type='method'><a href="WebApps.html#updateConfigurationSlotWithHttpOperationResponse">updateConfigurationSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateConfigurationWithHttpOperationResponse">updateConfigurationWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateConnectionStrings">updateConnectionStrings</a></li><li data-type='method'><a href="WebApps.html#updateConnectionStringsSlot">updateConnectionStringsSlot</a></li><li data-type='method'><a href="WebApps.html#updateConnectionStringsSlotWithHttpOperationResponse">updateConnectionStringsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateConnectionStringsWithHttpOperationResponse">updateConnectionStringsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateDiagnosticLogsConfig">updateDiagnosticLogsConfig</a></li><li data-type='method'><a href="WebApps.html#updateDiagnosticLogsConfigSlot">updateDiagnosticLogsConfigSlot</a></li><li data-type='method'><a href="WebApps.html#updateDiagnosticLogsConfigSlotWithHttpOperationResponse">updateDiagnosticLogsConfigSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateDiagnosticLogsConfigWithHttpOperationResponse">updateDiagnosticLogsConfigWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateDomainOwnershipIdentifier">updateDomainOwnershipIdentifier</a></li><li data-type='method'><a href="WebApps.html#updateDomainOwnershipIdentifierSlot">updateDomainOwnershipIdentifierSlot</a></li><li data-type='method'><a href="WebApps.html#updateDomainOwnershipIdentifierSlotWithHttpOperationResponse">updateDomainOwnershipIdentifierSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateDomainOwnershipIdentifierWithHttpOperationResponse">updateDomainOwnershipIdentifierWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateHybridConnection">updateHybridConnection</a></li><li data-type='method'><a href="WebApps.html#updateHybridConnectionSlot">updateHybridConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#updateHybridConnectionSlotWithHttpOperationResponse">updateHybridConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateHybridConnectionWithHttpOperationResponse">updateHybridConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateMetadata">updateMetadata</a></li><li data-type='method'><a href="WebApps.html#updateMetadataSlot">updateMetadataSlot</a></li><li data-type='method'><a href="WebApps.html#updateMetadataSlotWithHttpOperationResponse">updateMetadataSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateMetadataWithHttpOperationResponse">updateMetadataWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateRelayServiceConnection">updateRelayServiceConnection</a></li><li data-type='method'><a href="WebApps.html#updateRelayServiceConnectionSlot">updateRelayServiceConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#updateRelayServiceConnectionSlotWithHttpOperationResponse">updateRelayServiceConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateRelayServiceConnectionWithHttpOperationResponse">updateRelayServiceConnectionWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateSitePushSettings">updateSitePushSettings</a></li><li data-type='method'><a href="WebApps.html#updateSitePushSettingsSlot">updateSitePushSettingsSlot</a></li><li data-type='method'><a href="WebApps.html#updateSitePushSettingsSlotWithHttpOperationResponse">updateSitePushSettingsSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateSitePushSettingsWithHttpOperationResponse">updateSitePushSettingsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateSlotConfigurationNames">updateSlotConfigurationNames</a></li><li data-type='method'><a href="WebApps.html#updateSlotConfigurationNamesWithHttpOperationResponse">updateSlotConfigurationNamesWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateVnetConnection">updateVnetConnection</a></li><li data-type='method'><a href="WebApps.html#updateVnetConnectionGateway">updateVnetConnectionGateway</a></li><li data-type='method'><a href="WebApps.html#updateVnetConnectionGatewaySlot">updateVnetConnectionGatewaySlot</a></li><li data-type='method'><a href="WebApps.html#updateVnetConnectionGatewaySlotWithHttpOperationResponse">updateVnetConnectionGatewaySlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateVnetConnectionGatewayWithHttpOperationResponse">updateVnetConnectionGatewayWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateVnetConnectionSlot">updateVnetConnectionSlot</a></li><li data-type='method'><a href="WebApps.html#updateVnetConnectionSlotWithHttpOperationResponse">updateVnetConnectionSlotWithHttpOperationResponse</a></li><li data-type='method'><a href="WebApps.html#updateVnetConnectionWithHttpOperationResponse">updateVnetConnectionWithHttpOperationResponse</a></li></ul></li><li><a href="WebSiteManagementClient.html">WebSiteManagementClient</a><ul class='methods'><li data-type='method'><a href="WebSiteManagementClient.html#checkNameAvailability">checkNameAvailability</a></li><li data-type='method'><a href="WebSiteManagementClient.html#checkNameAvailabilityWithHttpOperationResponse">checkNameAvailabilityWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#getPublishingUser">getPublishingUser</a></li><li data-type='method'><a href="WebSiteManagementClient.html#getPublishingUserWithHttpOperationResponse">getPublishingUserWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listGeoRegions">listGeoRegions</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listGeoRegionsNext">listGeoRegionsNext</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listGeoRegionsNextWithHttpOperationResponse">listGeoRegionsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listGeoRegionsWithHttpOperationResponse">listGeoRegionsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listPremierAddOnOffers">listPremierAddOnOffers</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listPremierAddOnOffersNext">listPremierAddOnOffersNext</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listPremierAddOnOffersNextWithHttpOperationResponse">listPremierAddOnOffersNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listPremierAddOnOffersWithHttpOperationResponse">listPremierAddOnOffersWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listSkus">listSkus</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listSkusWithHttpOperationResponse">listSkusWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listSourceControls">listSourceControls</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listSourceControlsNext">listSourceControlsNext</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listSourceControlsNextWithHttpOperationResponse">listSourceControlsNextWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#listSourceControlsWithHttpOperationResponse">listSourceControlsWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#move">move</a></li><li data-type='method'><a href="WebSiteManagementClient.html#moveWithHttpOperationResponse">moveWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#updatePublishingUser">updatePublishingUser</a></li><li data-type='method'><a href="WebSiteManagementClient.html#updatePublishingUserWithHttpOperationResponse">updatePublishingUserWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#updateSourceControl">updateSourceControl</a></li><li data-type='method'><a href="WebSiteManagementClient.html#updateSourceControlWithHttpOperationResponse">updateSourceControlWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#validate">validate</a></li><li data-type='method'><a href="WebSiteManagementClient.html#validateMove">validateMove</a></li><li data-type='method'><a href="WebSiteManagementClient.html#validateMoveWithHttpOperationResponse">validateMoveWithHttpOperationResponse</a></li><li data-type='method'><a href="WebSiteManagementClient.html#validateWithHttpOperationResponse">validateWithHttpOperationResponse</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#_addPremierAddOn">_addPremierAddOn</a></li><li><a href="global.html#_addPremierAddOnSlot">_addPremierAddOnSlot</a></li><li><a href="global.html#_analyzeCustomHostname">_analyzeCustomHostname</a></li><li><a href="global.html#_analyzeCustomHostnameSlot">_analyzeCustomHostnameSlot</a></li><li><a href="global.html#_applySlotConfigToProduction">_applySlotConfigToProduction</a></li><li><a href="global.html#_applySlotConfigurationSlot">_applySlotConfigurationSlot</a></li><li><a href="global.html#_backup">_backup</a></li><li><a href="global.html#_backupSlot">_backupSlot</a></li><li><a href="global.html#_beginCreateOrUpdate">_beginCreateOrUpdate</a></li><li><a href="global.html#_beginCreateOrUpdateCertificate">_beginCreateOrUpdateCertificate</a></li><li><a href="global.html#_beginCreateOrUpdateMultiRolePool">_beginCreateOrUpdateMultiRolePool</a></li><li><a href="global.html#_beginCreateOrUpdateSlot">_beginCreateOrUpdateSlot</a></li><li><a href="global.html#_beginCreateOrUpdateSourceControl">_beginCreateOrUpdateSourceControl</a></li><li><a href="global.html#_beginCreateOrUpdateSourceControlSlot">_beginCreateOrUpdateSourceControlSlot</a></li><li><a href="global.html#_beginCreateOrUpdateWorkerPool">_beginCreateOrUpdateWorkerPool</a></li><li><a href="global.html#_beginDeleteMethod">_beginDeleteMethod</a></li><li><a href="global.html#_beginListPublishingCredentials">_beginListPublishingCredentials</a></li><li><a href="global.html#_beginListPublishingCredentialsSlot">_beginListPublishingCredentialsSlot</a></li><li><a href="global.html#_beginMigrateMySql">_beginMigrateMySql</a></li><li><a href="global.html#_beginMigrateStorage">_beginMigrateStorage</a></li><li><a href="global.html#_beginRecover">_beginRecover</a></li><li><a href="global.html#_beginRecoverSlot">_beginRecoverSlot</a></li><li><a href="global.html#_beginRestore">_beginRestore</a></li><li><a href="global.html#_beginRestoreSlot">_beginRestoreSlot</a></li><li><a href="global.html#_beginResume">_beginResume</a></li><li><a href="global.html#_beginResumeNext">_beginResumeNext</a></li><li><a href="global.html#_beginSuspend">_beginSuspend</a></li><li><a href="global.html#_beginSuspendNext">_beginSuspendNext</a></li><li><a href="global.html#_beginSwapSlotSlot">_beginSwapSlotSlot</a></li><li><a href="global.html#_beginSwapSlotWithProduction">_beginSwapSlotWithProduction</a></li><li><a href="global.html#_checkAvailability">_checkAvailability</a></li><li><a href="global.html#_checkNameAvailability">_checkNameAvailability</a></li><li><a href="global.html#_createDeployment">_createDeployment</a></li><li><a href="global.html#_createDeploymentSlot">_createDeploymentSlot</a></li><li><a href="global.html#_createInstanceDeployment">_createInstanceDeployment</a></li><li><a href="global.html#_createInstanceDeploymentSlot">_createInstanceDeploymentSlot</a></li><li><a href="global.html#_createOrUpdate">_createOrUpdate</a></li><li><a href="global.html#_createOrUpdateCertificate">_createOrUpdateCertificate</a></li><li><a href="global.html#_createOrUpdateConfiguration">_createOrUpdateConfiguration</a></li><li><a href="global.html#_createOrUpdateConfigurationSlot">_createOrUpdateConfigurationSlot</a></li><li><a href="global.html#_createOrUpdateDomainOwnershipIdentifier">_createOrUpdateDomainOwnershipIdentifier</a></li><li><a href="global.html#_createOrUpdateDomainOwnershipIdentifierSlot">_createOrUpdateDomainOwnershipIdentifierSlot</a></li><li><a href="global.html#_createOrUpdateHostNameBinding">_createOrUpdateHostNameBinding</a></li><li><a href="global.html#_createOrUpdateHostNameBindingSlot">_createOrUpdateHostNameBindingSlot</a></li><li><a href="global.html#_createOrUpdateHybridConnection">_createOrUpdateHybridConnection</a></li><li><a href="global.html#_createOrUpdateHybridConnectionSlot">_createOrUpdateHybridConnectionSlot</a></li><li><a href="global.html#_createOrUpdateMultiRolePool">_createOrUpdateMultiRolePool</a></li><li><a href="global.html#_createOrUpdateOwnershipIdentifier">_createOrUpdateOwnershipIdentifier</a></li><li><a href="global.html#_createOrUpdateRelayServiceConnection">_createOrUpdateRelayServiceConnection</a></li><li><a href="global.html#_createOrUpdateRelayServiceConnectionSlot">_createOrUpdateRelayServiceConnectionSlot</a></li><li><a href="global.html#_createOrUpdateSigningRequest">_createOrUpdateSigningRequest</a></li><li><a href="global.html#_createOrUpdateSlot">_createOrUpdateSlot</a></li><li><a href="global.html#_createOrUpdateSourceControl">_createOrUpdateSourceControl</a></li><li><a href="global.html#_createOrUpdateSourceControlSlot">_createOrUpdateSourceControlSlot</a></li><li><a href="global.html#_createOrUpdateVnetConnection">_createOrUpdateVnetConnection</a></li><li><a href="global.html#_createOrUpdateVnetConnectionGateway">_createOrUpdateVnetConnectionGateway</a></li><li><a href="global.html#_createOrUpdateVnetConnectionGatewaySlot">_createOrUpdateVnetConnectionGatewaySlot</a></li><li><a href="global.html#_createOrUpdateVnetConnectionSlot">_createOrUpdateVnetConnectionSlot</a></li><li><a href="global.html#_createOrUpdateVnetRoute">_createOrUpdateVnetRoute</a></li><li><a href="global.html#_createOrUpdateWorkerPool">_createOrUpdateWorkerPool</a></li><li><a href="global.html#_deleteBackup">_deleteBackup</a></li><li><a href="global.html#_deleteBackupConfiguration">_deleteBackupConfiguration</a></li><li><a href="global.html#_deleteBackupConfigurationSlot">_deleteBackupConfigurationSlot</a></li><li><a href="global.html#_deleteBackupSlot">_deleteBackupSlot</a></li><li><a href="global.html#_deleteCertificate">_deleteCertificate</a></li><li><a href="global.html#_deleteDeployment">_deleteDeployment</a></li><li><a href="global.html#_deleteDeploymentSlot">_deleteDeploymentSlot</a></li><li><a href="global.html#_deleteDomainOwnershipIdentifier">_deleteDomainOwnershipIdentifier</a></li><li><a href="global.html#_deleteDomainOwnershipIdentifierSlot">_deleteDomainOwnershipIdentifierSlot</a></li><li><a href="global.html#_deleteHostNameBinding">_deleteHostNameBinding</a></li><li><a href="global.html#_deleteHostNameBindingSlot">_deleteHostNameBindingSlot</a></li><li><a href="global.html#_deleteHybridConnection">_deleteHybridConnection</a></li><li><a href="global.html#_deleteHybridConnectionSlot">_deleteHybridConnectionSlot</a></li><li><a href="global.html#_deleteInstanceDeployment">_deleteInstanceDeployment</a></li><li><a href="global.html#_deleteInstanceDeploymentSlot">_deleteInstanceDeploymentSlot</a></li><li><a href="global.html#_deleteMethod">_deleteMethod</a></li><li><a href="global.html#_deleteOwnershipIdentifier">_deleteOwnershipIdentifier</a></li><li><a href="global.html#_deletePremierAddOn">_deletePremierAddOn</a></li><li><a href="global.html#_deletePremierAddOnSlot">_deletePremierAddOnSlot</a></li><li><a href="global.html#_deleteRelayServiceConnection">_deleteRelayServiceConnection</a></li><li><a href="global.html#_deleteRelayServiceConnectionSlot">_deleteRelayServiceConnectionSlot</a></li><li><a href="global.html#_deleteSigningRequest">_deleteSigningRequest</a></li><li><a href="global.html#_deleteSlot">_deleteSlot</a></li><li><a href="global.html#_deleteSourceControl">_deleteSourceControl</a></li><li><a href="global.html#_deleteSourceControlSlot">_deleteSourceControlSlot</a></li><li><a href="global.html#_deleteVnetConnection">_deleteVnetConnection</a></li><li><a href="global.html#_deleteVnetConnectionSlot">_deleteVnetConnectionSlot</a></li><li><a href="global.html#_deleteVnetRoute">_deleteVnetRoute</a></li><li><a href="global.html#_disableAllForWebApp">_disableAllForWebApp</a></li><li><a href="global.html#_discoverRestore">_discoverRestore</a></li><li><a href="global.html#_discoverRestoreSlot">_discoverRestoreSlot</a></li><li><a href="global.html#_generateNewSitePublishingPassword">_generateNewSitePublishingPassword</a></li><li><a href="global.html#_generateNewSitePublishingPasswordSlot">_generateNewSitePublishingPasswordSlot</a></li><li><a href="global.html#_get">_get</a></li><li><a href="global.html#_getAuthSettings">_getAuthSettings</a></li><li><a href="global.html#_getAuthSettingsSlot">_getAuthSettingsSlot</a></li><li><a href="global.html#_getBackupConfiguration">_getBackupConfiguration</a></li><li><a href="global.html#_getBackupConfigurationSlot">_getBackupConfigurationSlot</a></li><li><a href="global.html#_getBackupStatus">_getBackupStatus</a></li><li><a href="global.html#_getBackupStatusSlot">_getBackupStatusSlot</a></li><li><a href="global.html#_getCertificate">_getCertificate</a></li><li><a href="global.html#_getConfiguration">_getConfiguration</a></li><li><a href="global.html#_getConfigurationSlot">_getConfigurationSlot</a></li><li><a href="global.html#_getConfigurationSnapshot">_getConfigurationSnapshot</a></li><li><a href="global.html#_getConfigurationSnapshotSlot">_getConfigurationSnapshotSlot</a></li><li><a href="global.html#_getControlCenterSsoRequest">_getControlCenterSsoRequest</a></li><li><a href="global.html#_getDeployment">_getDeployment</a></li><li><a href="global.html#_getDeploymentSlot">_getDeploymentSlot</a></li><li><a href="global.html#_getDiagnosticLogsConfiguration">_getDiagnosticLogsConfiguration</a></li><li><a href="global.html#_getDiagnosticLogsConfigurationSlot">_getDiagnosticLogsConfigurationSlot</a></li><li><a href="global.html#_getDiagnosticsItem">_getDiagnosticsItem</a></li><li><a href="global.html#_getDomainOwnershipIdentifier">_getDomainOwnershipIdentifier</a></li><li><a href="global.html#_getDomainOwnershipIdentifierSlot">_getDomainOwnershipIdentifierSlot</a></li><li><a href="global.html#_getHostNameBinding">_getHostNameBinding</a></li><li><a href="global.html#_getHostNameBindingSlot">_getHostNameBindingSlot</a></li><li><a href="global.html#_getHybridConnection">_getHybridConnection</a></li><li><a href="global.html#_getHybridConnectionPlanLimit">_getHybridConnectionPlanLimit</a></li><li><a href="global.html#_getHybridConnectionSlot">_getHybridConnectionSlot</a></li><li><a href="global.html#_getInstanceDeployment">_getInstanceDeployment</a></li><li><a href="global.html#_getInstanceDeploymentSlot">_getInstanceDeploymentSlot</a></li><li><a href="global.html#_getMigrateMySqlStatus">_getMigrateMySqlStatus</a></li><li><a href="global.html#_getMigrateMySqlStatusSlot">_getMigrateMySqlStatusSlot</a></li><li><a href="global.html#_getMultiRolePool">_getMultiRolePool</a></li><li><a href="global.html#_getOwnershipIdentifier">_getOwnershipIdentifier</a></li><li><a href="global.html#_getPremierAddOn">_getPremierAddOn</a></li><li><a href="global.html#_getPremierAddOnSlot">_getPremierAddOnSlot</a></li><li><a href="global.html#_getPublishingUser">_getPublishingUser</a></li><li><a href="global.html#_getRelayServiceConnection">_getRelayServiceConnection</a></li><li><a href="global.html#_getRelayServiceConnectionSlot">_getRelayServiceConnectionSlot</a></li><li><a href="global.html#_getRouteForVnet">_getRouteForVnet</a></li><li><a href="global.html#_getRuleDetailsByWebApp">_getRuleDetailsByWebApp</a></li><li><a href="global.html#_getSigningRequest">_getSigningRequest</a></li><li><a href="global.html#_getSitePhpErrorLogFlag">_getSitePhpErrorLogFlag</a></li><li><a href="global.html#_getSitePhpErrorLogFlagSlot">_getSitePhpErrorLogFlagSlot</a></li><li><a href="global.html#_getSlot">_getSlot</a></li><li><a href="global.html#_getSourceControl">_getSourceControl</a></li><li><a href="global.html#_getSourceControlSlot">_getSourceControlSlot</a></li><li><a href="global.html#_getVnetConnection">_getVnetConnection</a></li><li><a href="global.html#_getVnetConnectionGateway">_getVnetConnectionGateway</a></li><li><a href="global.html#_getVnetConnectionGatewaySlot">_getVnetConnectionGatewaySlot</a></li><li><a href="global.html#_getVnetConnectionSlot">_getVnetConnectionSlot</a></li><li><a href="global.html#_getVnetFromServerFarm">_getVnetFromServerFarm</a></li><li><a href="global.html#_getVnetGateway">_getVnetGateway</a></li><li><a href="global.html#_getWorkerPool">_getWorkerPool</a></li><li><a href="global.html#_isCloneable">_isCloneable</a></li><li><a href="global.html#_isCloneableSlot">_isCloneableSlot</a></li><li><a href="global.html#_list">_list</a></li><li><a href="global.html#_listAgreements">_listAgreements</a></li><li><a href="global.html#_listAgreementsNext">_listAgreementsNext</a></li><li><a href="global.html#_listApplicationSettings">_listApplicationSettings</a></li><li><a href="global.html#_listApplicationSettingsSlot">_listApplicationSettingsSlot</a></li><li><a href="global.html#_listAppServicePlans">_listAppServicePlans</a></li><li><a href="global.html#_listAppServicePlansNext">_listAppServicePlansNext</a></li><li><a href="global.html#_listBackups">_listBackups</a></li><li><a href="global.html#_listBackupsNext">_listBackupsNext</a></li><li><a href="global.html#_listBackupsSlot">_listBackupsSlot</a></li><li><a href="global.html#_listBackupsSlotNext">_listBackupsSlotNext</a></li><li><a href="global.html#_listBackupStatusSecrets">_listBackupStatusSecrets</a></li><li><a href="global.html#_listBackupStatusSecretsSlot">_listBackupStatusSecretsSlot</a></li><li><a href="global.html#_listByResourceGroup">_listByResourceGroup</a></li><li><a href="global.html#_listByResourceGroupNext">_listByResourceGroupNext</a></li><li><a href="global.html#_listCapabilities">_listCapabilities</a></li><li><a href="global.html#_listCapacities">_listCapacities</a></li><li><a href="global.html#_listCapacitiesNext">_listCapacitiesNext</a></li><li><a href="global.html#_listCertificates">_listCertificates</a></li><li><a href="global.html#_listCertificatesNext">_listCertificatesNext</a></li><li><a href="global.html#_listConfigurationSnapshotInfo">_listConfigurationSnapshotInfo</a></li><li><a href="global.html#_listConfigurationSnapshotInfoSlot">_listConfigurationSnapshotInfoSlot</a></li><li><a href="global.html#_listConnectionStrings">_listConnectionStrings</a></li><li><a href="global.html#_listConnectionStringsSlot">_listConnectionStringsSlot</a></li><li><a href="global.html#_listDeployments">_listDeployments</a></li><li><a href="global.html#_listDeploymentsNext">_listDeploymentsNext</a></li><li><a href="global.html#_listDeploymentsSlot">_listDeploymentsSlot</a></li><li><a href="global.html#_listDeploymentsSlotNext">_listDeploymentsSlotNext</a></li><li><a href="global.html#_listDiagnostics">_listDiagnostics</a></li><li><a href="global.html#_listDomainOwnershipIdentifiers">_listDomainOwnershipIdentifiers</a></li><li><a href="global.html#_listDomainOwnershipIdentifiersNext">_listDomainOwnershipIdentifiersNext</a></li><li><a href="global.html#_listDomainOwnershipIdentifiersSlot">_listDomainOwnershipIdentifiersSlot</a></li><li><a href="global.html#_listDomainOwnershipIdentifiersSlotNext">_listDomainOwnershipIdentifiersSlotNext</a></li><li><a href="global.html#_listGeoRegions">_listGeoRegions</a></li><li><a href="global.html#_listGeoRegionsNext">_listGeoRegionsNext</a></li><li><a href="global.html#_listHistoryForWebApp">_listHistoryForWebApp</a></li><li><a href="global.html#_listHostNameBindings">_listHostNameBindings</a></li><li><a href="global.html#_listHostNameBindingsNext">_listHostNameBindingsNext</a></li><li><a href="global.html#_listHostNameBindingsSlot">_listHostNameBindingsSlot</a></li><li><a href="global.html#_listHostNameBindingsSlotNext">_listHostNameBindingsSlotNext</a></li><li><a href="global.html#_listHybridConnectionKeys">_listHybridConnectionKeys</a></li><li><a href="global.html#_listHybridConnectionKeysSlot">_listHybridConnectionKeysSlot</a></li><li><a href="global.html#_listHybridConnections">_listHybridConnections</a></li><li><a href="global.html#_listHybridConnectionsNext">_listHybridConnectionsNext</a></li><li><a href="global.html#_listHybridConnectionsSlot">_listHybridConnectionsSlot</a></li><li><a href="global.html#_listInstanceDeployments">_listInstanceDeployments</a></li><li><a href="global.html#_listInstanceDeploymentsNext">_listInstanceDeploymentsNext</a></li><li><a href="global.html#_listInstanceDeploymentsSlot">_listInstanceDeploymentsSlot</a></li><li><a href="global.html#_listInstanceDeploymentsSlotNext">_listInstanceDeploymentsSlotNext</a></li><li><a href="global.html#_listInstanceIdentifiers">_listInstanceIdentifiers</a></li><li><a href="global.html#_listInstanceIdentifiersNext">_listInstanceIdentifiersNext</a></li><li><a href="global.html#_listInstanceIdentifiersSlot">_listInstanceIdentifiersSlot</a></li><li><a href="global.html#_listInstanceIdentifiersSlotNext">_listInstanceIdentifiersSlotNext</a></li><li><a href="global.html#_listMetadata">_listMetadata</a></li><li><a href="global.html#_listMetadataSlot">_listMetadataSlot</a></li><li><a href="global.html#_listMetricDefinitions">_listMetricDefinitions</a></li><li><a href="global.html#_listMetricDefinitionsNext">_listMetricDefinitionsNext</a></li><li><a href="global.html#_listMetricDefinitionsSlot">_listMetricDefinitionsSlot</a></li><li><a href="global.html#_listMetricDefinitionsSlotNext">_listMetricDefinitionsSlotNext</a></li><li><a href="global.html#_listMetricDefintions">_listMetricDefintions</a></li><li><a href="global.html#_listMetricDefintionsNext">_listMetricDefintionsNext</a></li><li><a href="global.html#_listMetrics">_listMetrics</a></li><li><a href="global.html#_listMetricsNext">_listMetricsNext</a></li><li><a href="global.html#_listMetricsSlot">_listMetricsSlot</a></li><li><a href="global.html#_listMetricsSlotNext">_listMetricsSlotNext</a></li><li><a href="global.html#_listMultiRoleMetricDefinitions">_listMultiRoleMetricDefinitions</a></li><li><a href="global.html#_listMultiRoleMetricDefinitionsNext">_listMultiRoleMetricDefinitionsNext</a></li><li><a href="global.html#_listMultiRoleMetrics">_listMultiRoleMetrics</a></li><li><a href="global.html#_listMultiRoleMetricsNext">_listMultiRoleMetricsNext</a></li><li><a href="global.html#_listMultiRolePoolInstanceMetricDefinitions">_listMultiRolePoolInstanceMetricDefinitions</a></li><li><a href="global.html#_listMultiRolePoolInstanceMetricDefinitionsNext">_listMultiRolePoolInstanceMetricDefinitionsNext</a></li><li><a href="global.html#_listMultiRolePoolInstanceMetrics">_listMultiRolePoolInstanceMetrics</a></li><li><a href="global.html#_listMultiRolePoolInstanceMetricsNext">_listMultiRolePoolInstanceMetricsNext</a></li><li><a href="global.html#_listMultiRolePools">_listMultiRolePools</a></li><li><a href="global.html#_listMultiRolePoolSkus">_listMultiRolePoolSkus</a></li><li><a href="global.html#_listMultiRolePoolSkusNext">_listMultiRolePoolSkusNext</a></li><li><a href="global.html#_listMultiRolePoolsNext">_listMultiRolePoolsNext</a></li><li><a href="global.html#_listMultiRoleUsages">_listMultiRoleUsages</a></li><li><a href="global.html#_listMultiRoleUsagesNext">_listMultiRoleUsagesNext</a></li><li><a href="global.html#_listNetworkFeatures">_listNetworkFeatures</a></li><li><a href="global.html#_listNetworkFeaturesSlot">_listNetworkFeaturesSlot</a></li><li><a href="global.html#_listNext">_listNext</a></li><li><a href="global.html#_listOperations">_listOperations</a></li><li><a href="global.html#_listOwnershipIdentifiers">_listOwnershipIdentifiers</a></li><li><a href="global.html#_listOwnershipIdentifiersNext">_listOwnershipIdentifiersNext</a></li><li><a href="global.html#_listPerfMonCounters">_listPerfMonCounters</a></li><li><a href="global.html#_listPerfMonCountersNext">_listPerfMonCountersNext</a></li><li><a href="global.html#_listPerfMonCountersSlot">_listPerfMonCountersSlot</a></li><li><a href="global.html#_listPerfMonCountersSlotNext">_listPerfMonCountersSlotNext</a></li><li><a href="global.html#_listPremierAddOnOffers">_listPremierAddOnOffers</a></li><li><a href="global.html#_listPremierAddOnOffersNext">_listPremierAddOnOffersNext</a></li><li><a href="global.html#_listPremierAddOns">_listPremierAddOns</a></li><li><a href="global.html#_listPremierAddOnsSlot">_listPremierAddOnsSlot</a></li><li><a href="global.html#_listPublishingCredentials">_listPublishingCredentials</a></li><li><a href="global.html#_listPublishingCredentialsSlot">_listPublishingCredentialsSlot</a></li><li><a href="global.html#_listPublishingProfileXmlWithSecrets">_listPublishingProfileXmlWithSecrets</a></li><li><a href="global.html#_listPublishingProfileXmlWithSecretsSlot">_listPublishingProfileXmlWithSecretsSlot</a></li><li><a href="global.html#_listRecommendations">_listRecommendations</a></li><li><a href="global.html#_listRecommendationsNext">_listRecommendationsNext</a></li><li><a href="global.html#_listRecommendedRulesForWebApp">_listRecommendedRulesForWebApp</a></li><li><a href="global.html#_listRelayServiceConnections">_listRelayServiceConnections</a></li><li><a href="global.html#_listRelayServiceConnectionsSlot">_listRelayServiceConnectionsSlot</a></li><li><a href="global.html#_listRoutesForVnet">_listRoutesForVnet</a></li><li><a href="global.html#_listSigningRequestByResourceGroup">_listSigningRequestByResourceGroup</a></li><li><a href="global.html#_listSigningRequestByResourceGroupNext">_listSigningRequestByResourceGroupNext</a></li><li><a href="global.html#_listSitePushSettings">_listSitePushSettings</a></li><li><a href="global.html#_listSitePushSettingsSlot">_listSitePushSettingsSlot</a></li><li><a href="global.html#_listSkus">_listSkus</a></li><li><a href="global.html#_listSlotConfigurationNames">_listSlotConfigurationNames</a></li><li><a href="global.html#_listSlotDifferencesFromProduction">_listSlotDifferencesFromProduction</a></li><li><a href="global.html#_listSlotDifferencesFromProductionNext">_listSlotDifferencesFromProductionNext</a></li><li><a href="global.html#_listSlotDifferencesSlot">_listSlotDifferencesSlot</a></li><li><a href="global.html#_listSlotDifferencesSlotNext">_listSlotDifferencesSlotNext</a></li><li><a href="global.html#_listSlots">_listSlots</a></li><li><a href="global.html#_listSlotsNext">_listSlotsNext</a></li><li><a href="global.html#_listSnapshots">_listSnapshots</a></li><li><a href="global.html#_listSnapshotsNext">_listSnapshotsNext</a></li><li><a href="global.html#_listSnapshotsSlot">_listSnapshotsSlot</a></li><li><a href="global.html#_listSnapshotsSlotNext">_listSnapshotsSlotNext</a></li><li><a href="global.html#_listSourceControls">_listSourceControls</a></li><li><a href="global.html#_listSourceControlsNext">_listSourceControlsNext</a></li><li><a href="global.html#_listUsages">_listUsages</a></li><li><a href="global.html#_listUsagesNext">_listUsagesNext</a></li><li><a href="global.html#_listUsagesSlot">_listUsagesSlot</a></li><li><a href="global.html#_listUsagesSlotNext">_listUsagesSlotNext</a></li><li><a href="global.html#_listVips">_listVips</a></li><li><a href="global.html#_listVnetConnections">_listVnetConnections</a></li><li><a href="global.html#_listVnetConnectionsSlot">_listVnetConnectionsSlot</a></li><li><a href="global.html#_listVnets">_listVnets</a></li><li><a href="global.html#_listWebApps">_listWebApps</a></li><li><a href="global.html#_listWebAppsByHybridConnection">_listWebAppsByHybridConnection</a></li><li><a href="global.html#_listWebAppsByHybridConnectionNext">_listWebAppsByHybridConnectionNext</a></li><li><a href="global.html#_listWebAppsNext">_listWebAppsNext</a></li><li><a href="global.html#_listWebWorkerMetricDefinitions">_listWebWorkerMetricDefinitions</a></li><li><a href="global.html#_listWebWorkerMetricDefinitionsNext">_listWebWorkerMetricDefinitionsNext</a></li><li><a href="global.html#_listWebWorkerMetrics">_listWebWorkerMetrics</a></li><li><a href="global.html#_listWebWorkerMetricsNext">_listWebWorkerMetricsNext</a></li><li><a href="global.html#_listWebWorkerUsages">_listWebWorkerUsages</a></li><li><a href="global.html#_listWebWorkerUsagesNext">_listWebWorkerUsagesNext</a></li><li><a href="global.html#_listWorkerPoolInstanceMetricDefinitions">_listWorkerPoolInstanceMetricDefinitions</a></li><li><a href="global.html#_listWorkerPoolInstanceMetricDefinitionsNext">_listWorkerPoolInstanceMetricDefinitionsNext</a></li><li><a href="global.html#_listWorkerPoolInstanceMetrics">_listWorkerPoolInstanceMetrics</a></li><li><a href="global.html#_listWorkerPoolInstanceMetricsNext">_listWorkerPoolInstanceMetricsNext</a></li><li><a href="global.html#_listWorkerPools">_listWorkerPools</a></li><li><a href="global.html#_listWorkerPoolSkus">_listWorkerPoolSkus</a></li><li><a href="global.html#_listWorkerPoolSkusNext">_listWorkerPoolSkusNext</a></li><li><a href="global.html#_listWorkerPoolsNext">_listWorkerPoolsNext</a></li><li><a href="global.html#_migrateMySql">_migrateMySql</a></li><li><a href="global.html#_migrateStorage">_migrateStorage</a></li><li><a href="global.html#_move">_move</a></li><li><a href="global.html#_reboot">_reboot</a></li><li><a href="global.html#_rebootWorker">_rebootWorker</a></li><li><a href="global.html#_recover">_recover</a></li><li><a href="global.html#_recoverSiteConfigurationSnapshot">_recoverSiteConfigurationSnapshot</a></li><li><a href="global.html#_recoverSiteConfigurationSnapshotSlot">_recoverSiteConfigurationSnapshotSlot</a></li><li><a href="global.html#_recoverSlot">_recoverSlot</a></li><li><a href="global.html#_reissue">_reissue</a></li><li><a href="global.html#_renew">_renew</a></li><li><a href="global.html#_resendEmail">_resendEmail</a></li><li><a href="global.html#_resendRequestEmails">_resendRequestEmails</a></li><li><a href="global.html#_resetAllFilters">_resetAllFilters</a></li><li><a href="global.html#_resetAllFiltersForWebApp">_resetAllFiltersForWebApp</a></li><li><a href="global.html#_resetProductionSlotConfig">_resetProductionSlotConfig</a></li><li><a href="global.html#_resetSlotConfigurationSlot">_resetSlotConfigurationSlot</a></li><li><a href="global.html#_restart">_restart</a></li><li><a href="global.html#_restartSlot">_restartSlot</a></li><li><a href="global.html#_restartWebApps">_restartWebApps</a></li><li><a href="global.html#_restore">_restore</a></li><li><a href="global.html#_restoreSlot">_restoreSlot</a></li><li><a href="global.html#_resume">_resume</a></li><li><a href="global.html#_resumeNext">_resumeNext</a></li><li><a href="global.html#_retrieveCertificateActions">_retrieveCertificateActions</a></li><li><a href="global.html#_retrieveCertificateEmailHistory">_retrieveCertificateEmailHistory</a></li><li><a href="global.html#_retrieveSiteSeal">_retrieveSiteSeal</a></li><li><a href="global.html#_start">_start</a></li><li><a href="global.html#_startSlot">_startSlot</a></li><li><a href="global.html#_startWebSiteNetworkTrace">_startWebSiteNetworkTrace</a></li><li><a href="global.html#_startWebSiteNetworkTraceSlot">_startWebSiteNetworkTraceSlot</a></li><li><a href="global.html#_stop">_stop</a></li><li><a href="global.html#_stopSlot">_stopSlot</a></li><li><a href="global.html#_stopWebSiteNetworkTrace">_stopWebSiteNetworkTrace</a></li><li><a href="global.html#_stopWebSiteNetworkTraceSlot">_stopWebSiteNetworkTraceSlot</a></li><li><a href="global.html#_suspend">_suspend</a></li><li><a href="global.html#_suspendNext">_suspendNext</a></li><li><a href="global.html#_swapSlotSlot">_swapSlotSlot</a></li><li><a href="global.html#_swapSlotWithProduction">_swapSlotWithProduction</a></li><li><a href="global.html#_syncRepository">_syncRepository</a></li><li><a href="global.html#_syncRepositorySlot">_syncRepositorySlot</a></li><li><a href="global.html#_update">_update</a></li><li><a href="global.html#_updateApplicationSettings">_updateApplicationSettings</a></li><li><a href="global.html#_updateApplicationSettingsSlot">_updateApplicationSettingsSlot</a></li><li><a href="global.html#_updateAuthSettings">_updateAuthSettings</a></li><li><a href="global.html#_updateAuthSettingsSlot">_updateAuthSettingsSlot</a></li><li><a href="global.html#_updateBackupConfiguration">_updateBackupConfiguration</a></li><li><a href="global.html#_updateBackupConfigurationSlot">_updateBackupConfigurationSlot</a></li><li><a href="global.html#_updateConfiguration">_updateConfiguration</a></li><li><a href="global.html#_updateConfigurationSlot">_updateConfigurationSlot</a></li><li><a href="global.html#_updateConnectionStrings">_updateConnectionStrings</a></li><li><a href="global.html#_updateConnectionStringsSlot">_updateConnectionStringsSlot</a></li><li><a href="global.html#_updateDiagnosticLogsConfig">_updateDiagnosticLogsConfig</a></li><li><a href="global.html#_updateDiagnosticLogsConfigSlot">_updateDiagnosticLogsConfigSlot</a></li><li><a href="global.html#_updateDomainOwnershipIdentifier">_updateDomainOwnershipIdentifier</a></li><li><a href="global.html#_updateDomainOwnershipIdentifierSlot">_updateDomainOwnershipIdentifierSlot</a></li><li><a href="global.html#_updateHybridConnection">_updateHybridConnection</a></li><li><a href="global.html#_updateHybridConnectionSlot">_updateHybridConnectionSlot</a></li><li><a href="global.html#_updateMetadata">_updateMetadata</a></li><li><a href="global.html#_updateMetadataSlot">_updateMetadataSlot</a></li><li><a href="global.html#_updateOwnershipIdentifier">_updateOwnershipIdentifier</a></li><li><a href="global.html#_updatePublishingUser">_updatePublishingUser</a></li><li><a href="global.html#_updateRelayServiceConnection">_updateRelayServiceConnection</a></li><li><a href="global.html#_updateRelayServiceConnectionSlot">_updateRelayServiceConnectionSlot</a></li><li><a href="global.html#_updateSigningRequest">_updateSigningRequest</a></li><li><a href="global.html#_updateSitePushSettings">_updateSitePushSettings</a></li><li><a href="global.html#_updateSitePushSettingsSlot">_updateSitePushSettingsSlot</a></li><li><a href="global.html#_updateSlotConfigurationNames">_updateSlotConfigurationNames</a></li><li><a href="global.html#_updateSourceControl">_updateSourceControl</a></li><li><a href="global.html#_updateVnetConnection">_updateVnetConnection</a></li><li><a href="global.html#_updateVnetConnectionGateway">_updateVnetConnectionGateway</a></li><li><a href="global.html#_updateVnetConnectionGatewaySlot">_updateVnetConnectionGatewaySlot</a></li><li><a href="global.html#_updateVnetConnectionSlot">_updateVnetConnectionSlot</a></li><li><a href="global.html#_updateVnetGateway">_updateVnetGateway</a></li><li><a href="global.html#_updateVnetRoute">_updateVnetRoute</a></li><li><a href="global.html#_validate">_validate</a></li><li><a href="global.html#_validateMove">_validateMove</a></li><li><a href="global.html#_validatePurchaseInformation">_validatePurchaseInformation</a></li><li><a href="global.html#_verifyDomainOwnership">_verifyDomainOwnership</a></li><li><a href="global.html#agreedAt">agreedAt</a></li><li><a href="global.html#allowedOrigins">allowedOrigins</a></li><li><a href="global.html#alternateTxtRecords">alternateTxtRecords</a></li><li><a href="global.html#appServiceCertificateNotRenewableReasons">appServiceCertificateNotRenewableReasons</a></li><li><a href="global.html#appSettingNames">appSettingNames</a></li><li><a href="global.html#arguments">arguments</a></li><li><a href="global.html#backupRequestType">backupRequestType</a></li><li><a href="global.html#biztalkUri">biztalkUri</a></li><li><a href="global.html#blockingCharacteristics">blockingCharacteristics</a></li><li><a href="global.html#blockWriteAccessToSite">blockWriteAccessToSite</a></li><li><a href="global.html#capabilities">capabilities</a></li><li><a href="global.html#clusterSettings">clusterSettings</a></li><li><a href="global.html#connectionString">connectionString</a></li><li><a href="global.html#createdAt">createdAt</a></li><li><a href="global.html#decryptionKey">decryptionKey</a></li><li><a href="global.html#description">description</a></li><li><a href="global.html#destinationSlotName">destinationSlotName</a></li><li><a href="global.html#details">details</a></li><li><a href="global.html#diagnosicsOutput">diagnosicsOutput</a></li><li><a href="global.html#displayName">displayName</a></li><li><a href="global.html#dnsServers">dnsServers</a></li><li><a href="global.html#domainNotRenewableReasons">domainNotRenewableReasons</a></li><li><a href="global.html#domainType">domainType</a></li><li><a href="global.html#dynamicTagsJson">dynamicTagsJson</a></li><li><a href="global.html#enabled">enabled</a></li><li><a href="global.html#expirationTime">expirationTime</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#geoMasterOperationId">geoMasterOperationId</a></li><li><a href="global.html#hostingEnvironment">hostingEnvironment</a></li><li><a href="global.html#hostNameType">hostNameType</a></li><li><a href="global.html#hostType">hostType</a></li><li><a href="global.html#html">html</a></li><li><a href="global.html#hybridConnectionsV2">hybridConnectionsV2</a></li><li><a href="global.html#identifierId">identifierId</a></li><li><a href="global.html#includePrivacy">includePrivacy</a></li><li><a href="global.html#instanceNames">instanceNames</a></li><li><a href="global.html#inUse">inUse</a></li><li><a href="global.html#ipSecurityRestrictions">ipSecurityRestrictions</a></li><li><a href="global.html#isFqdn">isFqdn</a></li><li><a href="global.html#isMercurial">isMercurial</a></li><li><a href="global.html#isPrivateKeyExternal">isPrivateKeyExternal</a></li><li><a href="global.html#lastExecutionTime">lastExecutionTime</a></li><li><a href="global.html#level">level</a></li><li><a href="global.html#locale">locale</a></li><li><a href="global.html#localizedValue">localizedValue</a></li><li><a href="global.html#localMySqlEnabled">localMySqlEnabled</a></li><li><a href="global.html#marketplaceOffer">marketplaceOffer</a></li><li><a href="global.html#masterLogErrorsMaxLength">masterLogErrorsMaxLength</a></li><li><a href="global.html#maxDiskSizeInMb">maxDiskSizeInMb</a></li><li><a href="global.html#maxDomainRecommendations">maxDomainRecommendations</a></li><li><a href="global.html#maximum">maximum</a></li><li><a href="global.html#message">message</a></li><li><a href="global.html#microsoftAccountOAuthScopes">microsoftAccountOAuthScopes</a></li><li><a href="global.html#minProcessExecutionTime">minProcessExecutionTime</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#nextLink">nextLink</a></li><li><a href="global.html#operationId">operationId</a></li><li><a href="global.html#ownershipId">ownershipId</a></li><li><a href="global.html#parameters">parameters</a></li><li><a href="global.html#phone">phone</a></li><li><a href="global.html#physicalPath">physicalPath</a></li><li><a href="global.html#postParameterValue">postParameterValue</a></li><li><a href="global.html#preserveVnet">preserveVnet</a></li><li><a href="global.html#privacy">privacy</a></li><li><a href="global.html#properties">properties</a></li><li><a href="global.html#provisioningState">provisioningState</a></li><li><a href="global.html#publishingPasswordHashSalt">publishingPasswordHashSalt</a></li><li><a href="global.html#rampUpRules">rampUpRules</a></li><li><a href="global.html#rawData">rawData</a></li><li><a href="global.html#reason">reason</a></li><li><a href="global.html#remoteSubnet">remoteSubnet</a></li><li><a href="global.html#resources">resources</a></li><li><a href="global.html#retention">retention</a></li><li><a href="global.html#retentionInDays">retentionInDays</a></li><li><a href="global.html#routeType">routeType</a></li><li><a href="global.html#sasUrl">sasUrl</a></li><li><a href="global.html#scaleType">scaleType</a></li><li><a href="global.html#score">score</a></li><li><a href="global.html#sendKeyValue">sendKeyValue</a></li><li><a href="global.html#serverFarmId">serverFarmId</a></li><li><a href="global.html#siteConfigurationSnapshotInfoId">siteConfigurationSnapshotInfoId</a></li><li><a href="global.html#siteInstanceName">siteInstanceName</a></li><li><a href="global.html#siteMode">siteMode</a></li><li><a href="global.html#skus">skus</a></li><li><a href="global.html#slotName">slotName</a></li><li><a href="global.html#state">state</a></li><li><a href="global.html#subnet">subnet</a></li><li><a href="global.html#subnetMask">subnetMask</a></li><li><a href="global.html#tags">tags</a></li><li><a href="global.html#time">time</a></li><li><a href="global.html#timeInterval">timeInterval</a></li><li><a href="global.html#timeStamp">timeStamp</a></li><li><a href="global.html#trafficManagerProfileName">trafficManagerProfileName</a></li><li><a href="global.html#type">type</a></li><li><a href="global.html#url">url</a></li><li><a href="global.html#value">value</a></li><li><a href="global.html#values">values</a></li><li><a href="global.html#vipMappings">vipMappings</a></li><li><a href="global.html#virtualDirectories">virtualDirectories</a></li><li><a href="global.html#virtualIP">virtualIP</a></li><li><a href="global.html#vpnPackageUri">vpnPackageUri</a></li><li><a href="global.html#websiteSizeInBytes">websiteSizeInBytes</a></li></ul>
</nav>

<div id="main">
    
      <a class="github-banner" href="https://github.com/azure/azure-sdk-for-node.git"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
    
    
    <h1 class="page-title">operations/webApps.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const WebResource = msRest.WebResource;

/**
 * @summary Get all apps for a subscription.
 *
 * Get all apps for a subscription.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _list(options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/Microsoft.Web/sites';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all web, mobile, and API apps in the specified resource group.
 *
 * Gets all web, mobile, and API apps in the specified resource group.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.includeSlots] Specify &lt;strong>true&lt;/strong> to
 * include deployment slots in results. The default is false, which only gives
 * you the production slot of all apps.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listByResourceGroup(resourceGroupName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let includeSlots = (options &amp;&amp; options.includeSlots !== undefined) ? options.includeSlots : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (includeSlots !== null &amp;&amp; includeSlots !== undefined &amp;&amp; typeof includeSlots !== 'boolean') {
      throw new Error('includeSlots must be of type boolean.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (includeSlots !== null &amp;&amp; includeSlots !== undefined) {
    queryParameters.push('includeSlots=' + encodeURIComponent(includeSlots.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the details of a web, mobile, or API app.
 *
 * Gets the details of a web, mobile, or API app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _get(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Creates a new web, mobile, or API app in an existing resource
 * group, or updates an existing app.
 *
 * Creates a new web, mobile, or API app in an existing resource group, or
 * updates an existing app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Unique name of the app to create or update. To create
 * or update a deployment slot, use the {slot} parameter.
 *
 * @param {object} siteEnvelope A JSON representation of the app properties.
 * See example.
 *
 * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
 * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
 * the app (takes the app offline).
 *
 * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
 * to manage the SSL bindings for app's hostnames.
 *
 * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
 * App Service plan, formatted as:
 * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
 *
 * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
 * otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
 *
 * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
 * version.
 *
 * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
 * and version
 *
 * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
 * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
 * tracing expiration time.
 *
 * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
 * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
 * debugging version.
 *
 * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
 * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
 * directory size limit.
 *
 * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
 * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
 * name.
 *
 * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
 * strings.
 *
 * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
 * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
 * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
 * 'OneDrive', 'VSO'
 *
 * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
 * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
 * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
 * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
 * container version.
 *
 * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
 * launch.
 *
 * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
 * pipeline mode. Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
 * applications.
 *
 * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
 * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
 * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
 * for polymophic types.
 *
 * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
 * ramp-up rules.
 *
 * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
 * allowed CPU usage percentage.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
 * allowed memory usage in MB.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
 * allowed disk size usage in MB.
 *
 * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
 * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
 * that describe when to execute the auto-heal actions.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
 * rule based on total requests.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
 * interval.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
 * A rule based on status codes.
 *
 * @param {object}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
 * on request execution time.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
 * taken.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
 * Time interval.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
 * be executed when a rule is triggered.
 *
 * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
 * Predefined action to be taken. Possible values include: 'Recycle',
 * 'LogEvent', 'CustomAction'
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
 * Custom action to be taken.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
 * to be run.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
 * (CORS) settings.
 *
 * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
 * the list of origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
 * flag indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
 * a JSON string containing a list of tags that are whitelisted for use by the
 * push registration endpoint.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
 * sets a JSON string containing a list of tags that require user
 * authentication to be used in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
 * a JSON string containing a list of dynamic tags that will be evaluated from
 * user claims in the push registration endpoint.
 *
 * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
 * the formal API definition for the app.
 *
 * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
 * API definition.
 *
 * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
 * name.
 *
 * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
 * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
 * restrictions.
 *
 * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
 * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
 * default is &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
 * Environment to use for the app.
 *
 * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
 * the App Service Environment.
 *
 * @param {string} [siteEnvelope.microService] Micro services like apps, logic
 * apps.
 *
 * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
 * associated with the app.
 *
 * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
 * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
 * cookies, which route client requests in the same session to the same
 * instance. Default is &lt;code>true&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
 * enable client certificate authentication (TLS mutual authentication);
 * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
 * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
 * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
 *
 * @param {number} [siteEnvelope.containerSize] Size of the function container.
 *
 * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
 * memory-time quota (applicable on dynamic apps only).
 *
 * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
 * the app is cloned from a source app.
 *
 * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
 * cloning operation. This ID ties multiple cloning operations
 * together to use the same snapshot.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
 * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
 * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
 * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
 * the source app. App resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
 * for production slots and
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
 * for other slots.
 *
 * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
 * Environment.
 *
 * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
 * setting overrides for cloned app. If specified, these settings override the
 * settings cloned
 * from source app. Otherwise, application settings from source app are
 * retained.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
 * &lt;code>true&lt;/code> to configure load balancing for source and destination
 * app.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
 * resource ID of the Traffic Manager profile to use, if it exists. Traffic
 * Manager resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
 * Traffic Manager profile to create. This is only needed if Traffic Manager
 * profile does not already exist.
 *
 * @param {string} [siteEnvelope.name] Resource Name.
 *
 * @param {string} [siteEnvelope.kind] Kind of resource.
 *
 * @param {string} siteEnvelope.location Resource Location.
 *
 * @param {string} [siteEnvelope.type] Resource type.
 *
 * @param {object} [siteEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
 * not registered with DNS on creation. This parameter is
 * only used for app creation
 *
 * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
 * *.azurewebsites.net) domains associated with web app are not verified.
 *
 * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
 * force registered with DNS
 *
 * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
 * default domain name
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdate(resourceGroupName, name, siteEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
 *
 * Deletes a web, mobile, or API app, or one of the deployment slots.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app to delete.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
 * deleted
 *
 * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
 * Service plan will be empty after app deletion and you want to delete the
 * empty App Service plan. By default, the empty App Service plan is not
 * deleted.
 *
 * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
 * skipped
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMethod(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let deleteMetrics = (options &amp;&amp; options.deleteMetrics !== undefined) ? options.deleteMetrics : undefined;
  let deleteEmptyServerFarm = (options &amp;&amp; options.deleteEmptyServerFarm !== undefined) ? options.deleteEmptyServerFarm : undefined;
  let skipDnsRegistration = (options &amp;&amp; options.skipDnsRegistration !== undefined) ? options.skipDnsRegistration : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (deleteMetrics !== null &amp;&amp; deleteMetrics !== undefined &amp;&amp; typeof deleteMetrics !== 'boolean') {
      throw new Error('deleteMetrics must be of type boolean.');
    }
    if (deleteEmptyServerFarm !== null &amp;&amp; deleteEmptyServerFarm !== undefined &amp;&amp; typeof deleteEmptyServerFarm !== 'boolean') {
      throw new Error('deleteEmptyServerFarm must be of type boolean.');
    }
    if (skipDnsRegistration !== null &amp;&amp; skipDnsRegistration !== undefined &amp;&amp; typeof skipDnsRegistration !== 'boolean') {
      throw new Error('skipDnsRegistration must be of type boolean.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (deleteMetrics !== null &amp;&amp; deleteMetrics !== undefined) {
    queryParameters.push('deleteMetrics=' + encodeURIComponent(deleteMetrics.toString()));
  }
  if (deleteEmptyServerFarm !== null &amp;&amp; deleteEmptyServerFarm !== undefined) {
    queryParameters.push('deleteEmptyServerFarm=' + encodeURIComponent(deleteEmptyServerFarm.toString()));
  }
  if (skipDnsRegistration !== null &amp;&amp; skipDnsRegistration !== undefined) {
    queryParameters.push('skipDnsRegistration=' + encodeURIComponent(skipDnsRegistration.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Analyze a custom hostname.
 *
 * Analyze a custom hostname.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.hostName] Custom hostname
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CustomHostnameAnalysisResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _analyzeCustomHostname(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let hostName = (options &amp;&amp; options.hostName !== undefined) ? options.hostName : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (hostName !== null &amp;&amp; hostName !== undefined &amp;&amp; typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (hostName !== null &amp;&amp; hostName !== undefined) {
    queryParameters.push('hostName=' + encodeURIComponent(hostName));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['CustomHostnameAnalysisResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Applies the configuration settings from the target slot onto the
 * current slot.
 *
 * Applies the configuration settings from the target slot onto the current
 * slot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
 * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null &amp;&amp; slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a backup of an app.
 *
 * Creates a backup of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request Backup configuration. You can use the JSON response
 * from the POST action as input here.
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _backup(resourceGroupName, name, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null &amp;&amp; request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets existing backups of an app.
 *
 * Gets existing backups of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItemCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackups(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItemCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Discovers an existing app backup that can be restored from a blob
 * in Azure storage.
 *
 * Discovers an existing app backup that can be restored from a blob in Azure
 * storage.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request A RestoreRequest object that includes Azure storage
 * URL and blog name for discovery of backup.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
 * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
 * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
 * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _discoverRestore(resourceGroupName, name, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/discover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null &amp;&amp; request !== undefined) {
      let requestModelMapper = new client.models['RestoreRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a backup of an app by its ID.
 *
 * Gets a backup of an app by its ID.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupStatus(resourceGroupName, name, backupId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a backup of an app by its ID.
 *
 * Deletes a backup of an app by its ID.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteBackup(resourceGroupName, name, backupId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets status of a web app backup that may be in progress, including
 * secrets associated with the backup, such as the Azure Storage SAS URL. Also
 * can be used to update the SAS URL for the backup if a new URL is passed in
 * the request body.
 *
 * Gets status of a web app backup that may be in progress, including secrets
 * associated with the backup, such as the Azure Storage SAS URL. Also can be
 * used to update the SAS URL for the backup if a new URL is passed in the
 * request body.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} backupId Id of backup
 *
 * @param {object} request Information on backup request
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackupStatusSecrets(resourceGroupName, name, backupId, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null &amp;&amp; request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} request Information on restore request
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
 * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
 * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
 * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restore(resourceGroupName, name, backupId, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginRestore(resourceGroupName, name, backupId, request, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Replaces the application settings of an app.
 *
 * Replaces the application settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} appSettings Application settings of the app.
 *
 * @param {object} [appSettings.properties] Settings.
 *
 * @param {string} [appSettings.name] Resource Name.
 *
 * @param {string} [appSettings.kind] Kind of resource.
 *
 * @param {string} appSettings.location Resource Location.
 *
 * @param {string} [appSettings.type] Resource type.
 *
 * @param {object} [appSettings.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateApplicationSettings(resourceGroupName, name, appSettings, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (appSettings === null || appSettings === undefined) {
      throw new Error('appSettings cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (appSettings !== null &amp;&amp; appSettings !== undefined) {
      let requestModelMapper = new client.models['StringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, appSettings, 'appSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(appSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the application settings of an app.
 *
 * Gets the application settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listApplicationSettings(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the Authentication / Authorization settings associated with
 * web app.
 *
 * Updates the Authentication / Authorization settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} siteAuthSettings Auth settings associated with web app
 *
 * @param {boolean} [siteAuthSettings.enabled] &lt;code>true&lt;/code> if the
 * Authentication / Authorization feature is enabled for the current app;
 * otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
 * Authentication / Authorization feature in use for the current app.
 * The setting in this value can control the behavior of certain features in
 * the Authentication / Authorization module.
 *
 * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
 * take when an unauthenticated client attempts to access the app. Possible
 * values include: 'RedirectToLoginPage', 'AllowAnonymous'
 *
 * @param {boolean} [siteAuthSettings.tokenStoreEnabled] &lt;code>true&lt;/code> to
 * durably store platform-specific security tokens that are obtained during
 * login flows; otherwise, &lt;code>false&lt;/code>.
 * The default is &lt;code>false&lt;/code>.
 *
 * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
 * that can be redirected to as part of logging in or logging out of the app.
 * Note that the query string part of the URL is ignored.
 * This is an advanced setting typically only needed by Windows Store
 * application backends.
 * Note that URLs within the current domain are always implicitly allowed.
 *
 * @param {string} [siteAuthSettings.defaultProvider] The default
 * authentication provider to use when multiple providers are configured.
 * This setting is only needed if multiple providers are configured and the
 * unauthenticated client
 * action is set to "RedirectToLoginPage". Possible values include:
 * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
 *
 * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
 * hours after session token expiration that a session token can be used to
 * call the token refresh API. The default is 72 hours.
 *
 * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
 * party application, known as the client_id.
 * This setting is required for enabling OpenID Connection authentication with
 * Azure Active Directory or
 * other 3rd party OpenID Connect providers.
 * More information on OpenID Connect:
 * http://openid.net/specs/openid-connect-core-1_0.html
 *
 * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
 * relying party application (in Azure Active Directory, this is also referred
 * to as the Key).
 * This setting is optional. If no client secret is configured, the OpenID
 * Connect implicit auth flow is used to authenticate end users.
 * Otherwise, the OpenID Connect Authorization Code Flow is used to
 * authenticate end users.
 * More information on OpenID Connect:
 * http://openid.net/specs/openid-connect-core-1_0.html
 *
 * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
 * represents the entity which issues access tokens for this application.
 * When using Azure Active Directory, this value is the URI of the directory
 * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
 * This URI is a case-sensitive identifier for the token issuer.
 * More information on OpenID Connect Discovery:
 * http://openid.net/specs/openid-connect-discovery-1_0.html
 *
 * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
 * to consider when validating JWTs issued by
 * Azure Active Directory. Note that the &lt;code>ClientID&lt;/code> value is always
 * considered an
 * allowed audience, regardless of this setting.
 *
 * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
 * send to the OpenID Connect authorization endpoint when
 * a user logs in. Each parameter must be in the form "key=value".
 *
 * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
 * ID for the Google web application.
 * This setting is required for enabling Google Sign-In.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {string} [siteAuthSettings.googleClientSecret] The client secret
 * associated with the Google web application.
 * This setting is required for enabling Google Sign-In.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
 * that will be requested as part of Google Sign-In authentication.
 * This setting is optional. If not specified, "openid", "profile", and "email"
 * are used as default scopes.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
 * app used for login.
 * This setting is required for enabling Facebook Login.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
 * Facebook app used for Facebook Login.
 * This setting is required for enabling Facebook Login.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
 * that will be requested as part of Facebook Login authentication.
 * This setting is optional.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
 * consumer key of the Twitter application used for sign-in.
 * This setting is required for enabling Twitter Sign-In.
 * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
 *
 * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
 * consumer secret of the Twitter application used for sign-in.
 * This setting is required for enabling Twitter Sign-In.
 * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
 *
 * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
 * client ID that was created for the app used for authentication.
 * This setting is required for enabling Microsoft Account authentication.
 * Microsoft Account OAuth documentation:
 * https://dev.onedrive.com/auth/msa_oauth.htm
 *
 * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
 * 2.0 client secret that was created for the app used for authentication.
 * This setting is required for enabling Microsoft Account authentication.
 * Microsoft Account OAuth documentation:
 * https://dev.onedrive.com/auth/msa_oauth.htm
 *
 * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
 * scopes that will be requested as part of Microsoft Account authentication.
 * This setting is optional. If not specified, "wl.basic" is used as the
 * default scope.
 * Microsoft Account Scopes and permissions documentation:
 * https://msdn.microsoft.com/en-us/library/dn631845.aspx
 *
 * @param {string} [siteAuthSettings.name] Resource Name.
 *
 * @param {string} [siteAuthSettings.kind] Kind of resource.
 *
 * @param {string} siteAuthSettings.location Resource Location.
 *
 * @param {string} [siteAuthSettings.type] Resource type.
 *
 * @param {object} [siteAuthSettings.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteAuthSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateAuthSettings(resourceGroupName, name, siteAuthSettings, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteAuthSettings === null || siteAuthSettings === undefined) {
      throw new Error('siteAuthSettings cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteAuthSettings !== null &amp;&amp; siteAuthSettings !== undefined) {
      let requestModelMapper = new client.models['SiteAuthSettings']().mapper();
      requestModel = client.serialize(requestModelMapper, siteAuthSettings, 'siteAuthSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteAuthSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteAuthSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Authentication/Authorization settings of an app.
 *
 * Gets the Authentication/Authorization settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteAuthSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAuthSettings(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteAuthSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the backup configuration of an app.
 *
 * Updates the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request Edited backup configuration.
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateBackupConfiguration(resourceGroupName, name, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null &amp;&amp; request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes the backup configuration of an app.
 *
 * Deletes the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteBackupConfiguration(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the backup configuration of an app.
 *
 * Gets the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupConfiguration(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Replaces the connection strings of an app.
 *
 * Replaces the connection strings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} connectionStrings Connection strings of the app or
 * deployment slot. See example.
 *
 * @param {object} [connectionStrings.properties] Connection strings.
 *
 * @param {string} [connectionStrings.name] Resource Name.
 *
 * @param {string} [connectionStrings.kind] Kind of resource.
 *
 * @param {string} connectionStrings.location Resource Location.
 *
 * @param {string} [connectionStrings.type] Resource type.
 *
 * @param {object} [connectionStrings.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ConnectionStringDictionary} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateConnectionStrings(resourceGroupName, name, connectionStrings, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (connectionStrings === null || connectionStrings === undefined) {
      throw new Error('connectionStrings cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionStrings !== null &amp;&amp; connectionStrings !== undefined) {
      let requestModelMapper = new client.models['ConnectionStringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionStrings, 'connectionStrings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionStrings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ConnectionStringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the connection strings of an app.
 *
 * Gets the connection strings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ConnectionStringDictionary} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listConnectionStrings(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ConnectionStringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the logging configuration of an app.
 *
 * Gets the logging configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteLogsConfig} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDiagnosticLogsConfiguration(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteLogsConfig']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the logging configuration of an app.
 *
 * Updates the logging configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
 * the logging configuration to change in the "properties" property.
 *
 * @param {object} [siteLogsConfig.applicationLogs] Application logs
 * configuration.
 *
 * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
 * to file system configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
 * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
 *
 * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
 * Application logs to azure table storage configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
 * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
 * 'Error'
 *
 * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
 * URL to an Azure table with add/query/delete permissions.
 *
 * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
 * Application logs to blob storage configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
 * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
 * 'Error'
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
 * url to a azure blob container with read/write/list/delete permissions.
 *
 * @param {number}
 * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
 * in days.
 * Remove blobs older than X days.
 * 0 or lower means no retention.
 *
 * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
 *
 * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
 * system configuration.
 *
 * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
 * size in megabytes that http log files can use.
 * When reached old log files will be removed to make space for new ones.
 * Value can range between 25 and 100.
 *
 * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
 * Retention in days.
 * Remove files older than X days.
 * 0 or lower means no retention.
 *
 * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
 *
 * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
 * azure blob storage configuration.
 *
 * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
 * a azure blob container with read/write/list/delete permissions.
 *
 * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
 * Retention in days.
 * Remove blobs older than X days.
 * 0 or lower means no retention.
 *
 * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
 *
 * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
 * tracing configuration.
 *
 * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
 * messages configuration.
 *
 * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
 *
 * @param {string} [siteLogsConfig.name] Resource Name.
 *
 * @param {string} [siteLogsConfig.kind] Kind of resource.
 *
 * @param {string} siteLogsConfig.location Resource Location.
 *
 * @param {string} [siteLogsConfig.type] Resource type.
 *
 * @param {object} [siteLogsConfig.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteLogsConfig} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteLogsConfig === null || siteLogsConfig === undefined) {
      throw new Error('siteLogsConfig cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteLogsConfig !== null &amp;&amp; siteLogsConfig !== undefined) {
      let requestModelMapper = new client.models['SiteLogsConfig']().mapper();
      requestModel = client.serialize(requestModelMapper, siteLogsConfig, 'siteLogsConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteLogsConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteLogsConfig']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Replaces the metadata of an app.
 *
 * Replaces the metadata of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} metadata Edited metadata of the app or deployment slot. See
 * example.
 *
 * @param {object} [metadata.properties] Settings.
 *
 * @param {string} [metadata.name] Resource Name.
 *
 * @param {string} [metadata.kind] Kind of resource.
 *
 * @param {string} metadata.location Resource Location.
 *
 * @param {string} [metadata.type] Resource type.
 *
 * @param {object} [metadata.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateMetadata(resourceGroupName, name, metadata, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (metadata === null || metadata === undefined) {
      throw new Error('metadata cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (metadata !== null &amp;&amp; metadata !== undefined) {
      let requestModelMapper = new client.models['StringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, metadata, 'metadata');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(metadata, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the metadata of an app.
 *
 * Gets the metadata of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetadata(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Gets the Git/FTP publishing credentials of an app.
 *
 * Gets the Git/FTP publishing credentials of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link User} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPublishingCredentials(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginListPublishingCredentials(resourceGroupName, name, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['User']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Updates the Push settings associated with web app.
 *
 * Updates the Push settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} pushSettings Push settings associated with web app
 *
 * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
 * whether the Push endpoint is enabled.
 *
 * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
 * containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
 * containing a list of tags that require user authentication to be used in the
 * push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PushSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateSitePushSettings(resourceGroupName, name, pushSettings, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (pushSettings === null || pushSettings === undefined) {
      throw new Error('pushSettings cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (pushSettings !== null &amp;&amp; pushSettings !== undefined) {
      let requestModelMapper = new client.models['PushSettings']().mapper();
      requestModel = client.serialize(requestModelMapper, pushSettings, 'pushSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(pushSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PushSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Push settings associated with web app.
 *
 * Gets the Push settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PushSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSitePushSettings(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PushSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the names of app settings and connection strings that stick to
 * the slot (not swapped).
 *
 * Gets the names of app settings and connection strings that stick to the slot
 * (not swapped).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotConfigNamesResource} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotConfigurationNames(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotConfigNamesResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the names of application settings and connection string
 * that remain with the slot during swap operation.
 *
 * Updates the names of application settings and connection string that remain
 * with the slot during swap operation.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotConfigNames Names of application settings and connection
 * strings. See example.
 *
 * @param {array} [slotConfigNames.connectionStringNames] List of connection
 * string names.
 *
 * @param {array} [slotConfigNames.appSettingNames] List of application
 * settings names.
 *
 * @param {string} [slotConfigNames.name] Resource Name.
 *
 * @param {string} [slotConfigNames.kind] Kind of resource.
 *
 * @param {string} slotConfigNames.location Resource Location.
 *
 * @param {string} [slotConfigNames.type] Resource type.
 *
 * @param {object} [slotConfigNames.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotConfigNamesResource} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotConfigNames === null || slotConfigNames === undefined) {
      throw new Error('slotConfigNames cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotConfigNames !== null &amp;&amp; slotConfigNames !== undefined) {
      let requestModelMapper = new client.models['SlotConfigNamesResource']().mapper();
      requestModel = client.serialize(requestModelMapper, slotConfigNames, 'slotConfigNames');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotConfigNames, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotConfigNamesResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the configuration of an app, such as platform version and
 * bitness, default documents, virtual applications, Always On, etc.
 *
 * Gets the configuration of an app, such as platform version and bitness,
 * default documents, virtual applications, Always On, etc.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getConfiguration(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the configuration of an app.
 *
 * Updates the configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteConfig JSON representation of a SiteConfig object. See
 * example.
 *
 * @param {number} [siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
 *
 * @param {string} [siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
 *
 * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
 * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
 * expiration time.
 *
 * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
 * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
 * version.
 *
 * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
 * logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
 * limit.
 *
 * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
 * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.publishingUsername] Publishing user name.
 *
 * @param {array} [siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteConfig.connectionStrings] Connection strings.
 *
 * @param {array} [siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteConfig.scmType] SCM type. Possible values include:
 * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
 * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
 * 'VSO'
 *
 * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
 * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
 * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
 * enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteConfig.javaContainerVersion] Java container version.
 *
 * @param {string} [siteConfig.appCommandLine] App command line to launch.
 *
 * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
 * Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteConfig.virtualApplications] Virtual applications.
 *
 * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
 * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
 * 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteConfig.experiments] This is work around for polymophic
 * types.
 *
 * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
 *
 * @param {object} [siteConfig.limits] Site limits.
 *
 * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
 * usage percentage.
 *
 * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
 * usage in MB.
 *
 * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
 * size usage in MB.
 *
 * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
 * is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
 * when to execute the auto-heal actions.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
 * total requests.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
 * Time interval.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
 * on status codes.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
 * based on request execution time.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
 * Time taken.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
 * Count.
 *
 * @param {string}
 * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
 *
 * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
 * when a rule is triggered.
 *
 * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
 * action to be taken. Possible values include: 'Recycle', 'LogEvent',
 * 'CustomAction'
 *
 * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
 * action to be taken.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
 * Executable to be run.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
 * settings.
 *
 * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
 * origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
 * indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
 * string containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
 * string containing a list of tags that require user authentication to be used
 * in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {object} [siteConfig.apiDefinition] Information about the formal API
 * definition for the app.
 *
 * @param {string} [siteConfig.apiDefinition.url] The URL of the API
 * definition.
 *
 * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
 *
 * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
 * local MySQL; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
 *
 * @param {string} [siteConfig.name] Resource Name.
 *
 * @param {string} [siteConfig.kind] Kind of resource.
 *
 * @param {string} siteConfig.location Resource Location.
 *
 * @param {string} [siteConfig.type] Resource type.
 *
 * @param {object} [siteConfig.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteConfig === null || siteConfig === undefined) {
      throw new Error('siteConfig cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteConfig !== null &amp;&amp; siteConfig !== undefined) {
      let requestModelMapper = new client.models['SiteConfigResource']().mapper();
      requestModel = client.serialize(requestModelMapper, siteConfig, 'siteConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the configuration of an app.
 *
 * Updates the configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteConfig JSON representation of a SiteConfig object. See
 * example.
 *
 * @param {number} [siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
 *
 * @param {string} [siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
 *
 * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
 * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
 * expiration time.
 *
 * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
 * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
 * version.
 *
 * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
 * logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
 * limit.
 *
 * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
 * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.publishingUsername] Publishing user name.
 *
 * @param {array} [siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteConfig.connectionStrings] Connection strings.
 *
 * @param {array} [siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteConfig.scmType] SCM type. Possible values include:
 * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
 * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
 * 'VSO'
 *
 * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
 * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
 * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
 * enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteConfig.javaContainerVersion] Java container version.
 *
 * @param {string} [siteConfig.appCommandLine] App command line to launch.
 *
 * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
 * Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteConfig.virtualApplications] Virtual applications.
 *
 * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
 * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
 * 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteConfig.experiments] This is work around for polymophic
 * types.
 *
 * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
 *
 * @param {object} [siteConfig.limits] Site limits.
 *
 * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
 * usage percentage.
 *
 * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
 * usage in MB.
 *
 * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
 * size usage in MB.
 *
 * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
 * is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
 * when to execute the auto-heal actions.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
 * total requests.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
 * Time interval.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
 * on status codes.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
 * based on request execution time.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
 * Time taken.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
 * Count.
 *
 * @param {string}
 * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
 *
 * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
 * when a rule is triggered.
 *
 * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
 * action to be taken. Possible values include: 'Recycle', 'LogEvent',
 * 'CustomAction'
 *
 * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
 * action to be taken.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
 * Executable to be run.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
 * settings.
 *
 * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
 * origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
 * indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
 * string containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
 * string containing a list of tags that require user authentication to be used
 * in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {object} [siteConfig.apiDefinition] Information about the formal API
 * definition for the app.
 *
 * @param {string} [siteConfig.apiDefinition.url] The URL of the API
 * definition.
 *
 * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
 *
 * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
 * local MySQL; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
 *
 * @param {string} [siteConfig.name] Resource Name.
 *
 * @param {string} [siteConfig.kind] Kind of resource.
 *
 * @param {string} siteConfig.location Resource Location.
 *
 * @param {string} [siteConfig.type] Resource type.
 *
 * @param {object} [siteConfig.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateConfiguration(resourceGroupName, name, siteConfig, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteConfig === null || siteConfig === undefined) {
      throw new Error('siteConfig cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteConfig !== null &amp;&amp; siteConfig !== undefined) {
      let requestModelMapper = new client.models['SiteConfigResource']().mapper();
      requestModel = client.serialize(requestModelMapper, siteConfig, 'siteConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of web app configuration snapshots identifiers. Each
 * element of the list contains a timestamp and the ID of the snapshot.
 *
 * Gets a list of web app configuration snapshots identifiers. Each element of
 * the list contains a timestamp and the ID of the snapshot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listConfigurationSnapshotInfo(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'SiteConfigurationSnapshotInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'SiteConfigurationSnapshotInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a snapshot of the configuration of an app at a previous point
 * in time.
 *
 * Gets a snapshot of the configuration of an app at a previous point in time.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} snapshotId The ID of the snapshot to read.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getConfigurationSnapshot(resourceGroupName, name, snapshotId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (snapshotId === null || snapshotId === undefined || typeof snapshotId.valueOf() !== 'string') {
      throw new Error('snapshotId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{snapshotId}', encodeURIComponent(snapshotId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Reverts the configuration of an app to a previous snapshot.
 *
 * Reverts the configuration of an app to a previous snapshot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} snapshotId The ID of the snapshot to read.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (snapshotId === null || snapshotId === undefined || typeof snapshotId.valueOf() !== 'string') {
      throw new Error('snapshotId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{snapshotId}', encodeURIComponent(snapshotId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDeployments(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get a deployment by its ID for an app, a specific deployment slot,
 * and/or a specific scaled-out instance.
 *
 * Get a deployment by its ID for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployment(resourceGroupName, name, id, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Create a deployment for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * Create a deployment for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id ID of an existing deployment.
 *
 * @param {object} deployment Deployment details.
 *
 * @param {string} [deployment.deploymentId] ID.
 *
 * @param {number} [deployment.status] Status.
 *
 * @param {string} [deployment.message] Message.
 *
 * @param {string} [deployment.author] Author.
 *
 * @param {string} [deployment.deployer] Deployer.
 *
 * @param {string} [deployment.authorEmail] Author email.
 *
 * @param {date} [deployment.startTime] Start time.
 *
 * @param {date} [deployment.endTime] End time.
 *
 * @param {boolean} [deployment.active] Active.
 *
 * @param {string} [deployment.details] Detail.
 *
 * @param {string} [deployment.name] Resource Name.
 *
 * @param {string} [deployment.kind] Kind of resource.
 *
 * @param {string} deployment.location Resource Location.
 *
 * @param {string} [deployment.type] Resource type.
 *
 * @param {object} [deployment.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createDeployment(resourceGroupName, name, id, deployment, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (deployment === null || deployment === undefined) {
      throw new Error('deployment cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deployment !== null &amp;&amp; deployment !== undefined) {
      let requestModelMapper = new client.models['Deployment']().mapper();
      requestModel = client.serialize(requestModelMapper, deployment, 'deployment');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deployment, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a deployment by its ID for an app, a specific deployment
 * slot, and/or a specific scaled-out instance.
 *
 * Delete a deployment by its ID for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDeployment(resourceGroupName, name, id, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists ownership identifiers for domain associated with web app.
 *
 * Lists ownership identifiers for domain associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IdentifierCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDomainOwnershipIdentifiers(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['IdentifierCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get domain ownership identifier for web app.
 *
 * Get domain ownership identifier for web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a domain ownership identifier for web app, or updates an
 * existing ownership identifier.
 *
 * Creates a domain ownership identifier for web app, or updates an existing
 * ownership identifier.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} domainOwnershipIdentifier A JSON representation of the
 * domain ownership properties.
 *
 * @param {string} [domainOwnershipIdentifier.identifierId] ID.
 *
 * @param {string} [domainOwnershipIdentifier.name] Resource Name.
 *
 * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
 *
 * @param {string} domainOwnershipIdentifier.location Resource Location.
 *
 * @param {string} [domainOwnershipIdentifier.type] Resource type.
 *
 * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifier === null || domainOwnershipIdentifier === undefined) {
      throw new Error('domainOwnershipIdentifier cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (domainOwnershipIdentifier !== null &amp;&amp; domainOwnershipIdentifier !== undefined) {
      let requestModelMapper = new client.models['Identifier']().mapper();
      requestModel = client.serialize(requestModelMapper, domainOwnershipIdentifier, 'domainOwnershipIdentifier');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(domainOwnershipIdentifier, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a domain ownership identifier for a web app.
 *
 * Deletes a domain ownership identifier for a web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a domain ownership identifier for web app, or updates an
 * existing ownership identifier.
 *
 * Creates a domain ownership identifier for web app, or updates an existing
 * ownership identifier.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} domainOwnershipIdentifier A JSON representation of the
 * domain ownership properties.
 *
 * @param {string} [domainOwnershipIdentifier.identifierId] ID.
 *
 * @param {string} [domainOwnershipIdentifier.name] Resource Name.
 *
 * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
 *
 * @param {string} domainOwnershipIdentifier.location Resource Location.
 *
 * @param {string} [domainOwnershipIdentifier.type] Resource type.
 *
 * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifier === null || domainOwnershipIdentifier === undefined) {
      throw new Error('domainOwnershipIdentifier cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (domainOwnershipIdentifier !== null &amp;&amp; domainOwnershipIdentifier !== undefined) {
      let requestModelMapper = new client.models['Identifier']().mapper();
      requestModel = client.serialize(requestModelMapper, domainOwnershipIdentifier, 'domainOwnershipIdentifier');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(domainOwnershipIdentifier, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get hostname bindings for an app or a deployment slot.
 *
 * Get hostname bindings for an app or a deployment slot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBindingCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHostNameBindings(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBindingCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the named hostname binding for an app (or deployment slot, if
 * specified).
 *
 * Get the named hostname binding for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBinding} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getHostNameBinding(resourceGroupName, name, hostName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBinding']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a hostname binding for an app.
 *
 * Creates a hostname binding for an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} hostNameBinding Binding details. This is the JSON
 * representation of a HostNameBinding object.
 *
 * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
 *
 * @param {string} [hostNameBinding.siteName] App Service app name.
 *
 * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
 * resource URI.
 *
 * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
 *
 * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
 * Possible values include: 'Website', 'TrafficManager'
 *
 * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
 * record type. Possible values include: 'CName', 'A'
 *
 * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
 * values include: 'Verified', 'Managed'
 *
 * @param {string} [hostNameBinding.sslState] SSL type. Possible values
 * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
 *
 * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
 *
 * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
 * the hostname if IP based SSL is enabled.
 *
 * @param {string} [hostNameBinding.name] Resource Name.
 *
 * @param {string} [hostNameBinding.kind] Kind of resource.
 *
 * @param {string} hostNameBinding.location Resource Location.
 *
 * @param {string} [hostNameBinding.type] Resource type.
 *
 * @param {object} [hostNameBinding.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBinding} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (hostNameBinding === null || hostNameBinding === undefined) {
      throw new Error('hostNameBinding cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (hostNameBinding !== null &amp;&amp; hostNameBinding !== undefined) {
      let requestModelMapper = new client.models['HostNameBinding']().mapper();
      requestModel = client.serialize(requestModelMapper, hostNameBinding, 'hostNameBinding');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(hostNameBinding, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBinding']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a hostname binding for an app.
 *
 * Deletes a hostname binding for an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteHostNameBinding(resourceGroupName, name, hostName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
 * App.
 *
 * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getHybridConnection(resourceGroupName, name, namespaceName, relayName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new Hybrid Connection using a Service Bus relay.
 *
 * Creates a new Hybrid Connection using a Service Bus relay.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} connectionEnvelope The details of the hybrid connection
 *
 * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
 * Service Bus namespace.
 *
 * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
 * relay.
 *
 * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
 * Bus relay.
 *
 * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
 *
 * @param {number} [connectionEnvelope.port] The port of the endpoint.
 *
 * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
 * key which has Send permissions. This is used to authenticate to Service Bus.
 *
 * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
 * Bus key. This is used to authenticate to Service Bus. In ARM this key will
 * not be returned
 * normally, use the POST /listKeys API instead.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['HybridConnection']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Removes a Hybrid Connection from this site.
 *
 * Removes a Hybrid Connection from this site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new Hybrid Connection using a Service Bus relay.
 *
 * Creates a new Hybrid Connection using a Service Bus relay.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} connectionEnvelope The details of the hybrid connection
 *
 * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
 * Service Bus namespace.
 *
 * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
 * relay.
 *
 * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
 * Bus relay.
 *
 * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
 *
 * @param {number} [connectionEnvelope.port] The port of the endpoint.
 *
 * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
 * key which has Send permissions. This is used to authenticate to Service Bus.
 *
 * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
 * Bus key. This is used to authenticate to Service Bus. In ARM this key will
 * not be returned
 * normally, use the POST /listKeys API instead.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['HybridConnection']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the send key name and value for a Hybrid Connection.
 *
 * Gets the send key name and value for a Hybrid Connection.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnectionKey} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnectionKey']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
 *
 * Retrieves all Service Bus Hybrid Connections used by this Web App.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHybridConnections(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets hybrid connections configured for an app (or deployment slot,
 * if specified).
 *
 * Gets hybrid connections configured for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listRelayServiceConnections(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a hybrid connection configuration by its name.
 *
 * Gets a hybrid connection configuration by its name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getRelayServiceConnection(resourceGroupName, name, entityName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new hybrid connection configuration (PUT), or updates an
 * existing one (PATCH).
 *
 * Creates a new hybrid connection configuration (PUT), or updates an existing
 * one (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {object} connectionEnvelope Details of the hybrid connection
 * configuration.
 *
 * @param {string} [connectionEnvelope.entityName]
 *
 * @param {string} [connectionEnvelope.entityConnectionString]
 *
 * @param {string} [connectionEnvelope.resourceType]
 *
 * @param {string} [connectionEnvelope.resourceConnectionString]
 *
 * @param {string} [connectionEnvelope.hostname]
 *
 * @param {number} [connectionEnvelope.port]
 *
 * @param {string} [connectionEnvelope.biztalkUri]
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['RelayServiceConnectionEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a relay service connection by its name.
 *
 * Deletes a relay service connection by its name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteRelayServiceConnection(resourceGroupName, name, entityName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new hybrid connection configuration (PUT), or updates an
 * existing one (PATCH).
 *
 * Creates a new hybrid connection configuration (PUT), or updates an existing
 * one (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {object} connectionEnvelope Details of the hybrid connection
 * configuration.
 *
 * @param {string} [connectionEnvelope.entityName]
 *
 * @param {string} [connectionEnvelope.entityConnectionString]
 *
 * @param {string} [connectionEnvelope.resourceType]
 *
 * @param {string} [connectionEnvelope.resourceConnectionString]
 *
 * @param {string} [connectionEnvelope.hostname]
 *
 * @param {number} [connectionEnvelope.port]
 *
 * @param {string} [connectionEnvelope.biztalkUri]
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['RelayServiceConnectionEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all scale-out instances of an app.
 *
 * Gets all scale-out instances of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppInstanceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceIdentifiers(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppInstanceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} instanceId The ID of a specific scaled-out instance. This is
 * the value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceDeployments(resourceGroupName, name, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get a deployment by its ID for an app, a specific deployment slot,
 * and/or a specific scaled-out instance.
 *
 * Get a deployment by its ID for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getInstanceDeployment(resourceGroupName, name, id, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Create a deployment for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * Create a deployment for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id ID of an existing deployment.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} deployment Deployment details.
 *
 * @param {string} [deployment.deploymentId] ID.
 *
 * @param {number} [deployment.status] Status.
 *
 * @param {string} [deployment.message] Message.
 *
 * @param {string} [deployment.author] Author.
 *
 * @param {string} [deployment.deployer] Deployer.
 *
 * @param {string} [deployment.authorEmail] Author email.
 *
 * @param {date} [deployment.startTime] Start time.
 *
 * @param {date} [deployment.endTime] End time.
 *
 * @param {boolean} [deployment.active] Active.
 *
 * @param {string} [deployment.details] Detail.
 *
 * @param {string} [deployment.name] Resource Name.
 *
 * @param {string} [deployment.kind] Kind of resource.
 *
 * @param {string} deployment.location Resource Location.
 *
 * @param {string} [deployment.type] Resource type.
 *
 * @param {object} [deployment.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createInstanceDeployment(resourceGroupName, name, id, instanceId, deployment, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (deployment === null || deployment === undefined) {
      throw new Error('deployment cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deployment !== null &amp;&amp; deployment !== undefined) {
      let requestModelMapper = new client.models['Deployment']().mapper();
      requestModel = client.serialize(requestModelMapper, deployment, 'deployment');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deployment, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a deployment by its ID for an app, a specific deployment
 * slot, and/or a specific scaled-out instance.
 *
 * Delete a deployment by its ID for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteInstanceDeployment(resourceGroupName, name, id, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Shows whether an app can be cloned to another resource group or
 * subscription.
 *
 * Shows whether an app can be cloned to another resource group or
 * subscription.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteCloneability} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _isCloneable(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteCloneability']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all metric definitions of an app (or deployment slot, if
 * specified).
 *
 * Gets all metric definitions of an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricDefinitionCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricDefinitions(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metricdefinitions';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricDefinitionCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets performance metrics of an app (or deployment slot, if
 * specified).
 *
 * Gets performance metrics of an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.details] Specify "true" to include metric details
 * in the response. It is "false" by default.
 *
 * @param {string} [options.filter] Return only metrics specified in the filter
 * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
 * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
 * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetrics(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let details = (options &amp;&amp; options.details !== undefined) ? options.details : undefined;
  let filter = (options &amp;&amp; options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (details !== null &amp;&amp; details !== undefined &amp;&amp; typeof details !== 'boolean') {
      throw new Error('details must be of type boolean.');
    }
    if (filter !== null &amp;&amp; filter !== undefined &amp;&amp; typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metrics';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (details !== null &amp;&amp; details !== undefined) {
    queryParameters.push('details=' + encodeURIComponent(details.toString()));
  }
  if (filter !== null &amp;&amp; filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Restores a web app.
 *
 * Restores a web app.
 *
 * @param {string} subscriptionName Azure subscription
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} migrationOptions Migration migrationOptions
 *
 * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
 * connection string.
 *
 * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
 *
 * @param {boolean} [migrationOptions.switchSiteAfterMigration]
 * &lt;code>true&lt;/code>if the app should be switched over; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [migrationOptions.blockWriteAccessToSite] &lt;code>true&lt;/code>
 * if the app should be read only during copy operation; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [migrationOptions.name] Resource Name.
 *
 * @param {string} [migrationOptions.kind] Kind of resource.
 *
 * @param {string} migrationOptions.location Resource Location.
 *
 * @param {string} [migrationOptions.type] Resource type.
 *
 * @param {object} [migrationOptions.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageMigrationResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _migrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageMigrationResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * @summary Migrates a local (in-app) MySql database to a remote MySql
 * database.
 *
 * Migrates a local (in-app) MySql database to a remote MySql database.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} migrationRequestEnvelope MySql migration options
 *
 * @param {string} [migrationRequestEnvelope.connectionString] Connection
 * string to the remote MySQL database to which data should be migrated.
 *
 * @param {string} [migrationRequestEnvelope.name] Resource Name.
 *
 * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
 *
 * @param {string} migrationRequestEnvelope.location Resource Location.
 *
 * @param {string} [migrationRequestEnvelope.type] Resource type.
 *
 * @param {object} [migrationRequestEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Operation} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _migrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Operation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Returns the status of MySql in app migration, if one is active, and
 * whether or not MySql in app is enabled
 *
 * Returns the status of MySql in app migration, if one is active, and whether
 * or not MySql in app is enabled
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MigrateMySqlStatus} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getMigrateMySqlStatus(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['MigrateMySqlStatus']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all network features used by the app (or deployment slot, if
 * specified).
 *
 * Gets all network features used by the app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} view The type of view. This can either be "summary" or
 * "detailed".
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NetworkFeatures} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listNetworkFeatures(resourceGroupName, name, view, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (view === null || view === undefined || typeof view.valueOf() !== 'string') {
      throw new Error('view cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{view}', encodeURIComponent(view));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['NetworkFeatures']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Start capturing network packets for the site.
 *
 * Start capturing network packets for the site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.durationInSeconds] The duration to keep capturing
 * in seconds.
 *
 * @param {number} [options.maxFrameLength] The maximum frame length in bytes
 * (Optional).
 *
 * @param {string} [options.sasUrl] The Blob URL to store capture file.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startWebSiteNetworkTrace(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let durationInSeconds = (options &amp;&amp; options.durationInSeconds !== undefined) ? options.durationInSeconds : undefined;
  let maxFrameLength = (options &amp;&amp; options.maxFrameLength !== undefined) ? options.maxFrameLength : undefined;
  let sasUrl = (options &amp;&amp; options.sasUrl !== undefined) ? options.sasUrl : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (durationInSeconds !== null &amp;&amp; durationInSeconds !== undefined &amp;&amp; typeof durationInSeconds !== 'number') {
      throw new Error('durationInSeconds must be of type number.');
    }
    if (maxFrameLength !== null &amp;&amp; maxFrameLength !== undefined &amp;&amp; typeof maxFrameLength !== 'number') {
      throw new Error('maxFrameLength must be of type number.');
    }
    if (sasUrl !== null &amp;&amp; sasUrl !== undefined &amp;&amp; typeof sasUrl.valueOf() !== 'string') {
      throw new Error('sasUrl must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (durationInSeconds !== null &amp;&amp; durationInSeconds !== undefined) {
    queryParameters.push('durationInSeconds=' + encodeURIComponent(durationInSeconds.toString()));
  }
  if (maxFrameLength !== null &amp;&amp; maxFrameLength !== undefined) {
    queryParameters.push('maxFrameLength=' + encodeURIComponent(maxFrameLength.toString()));
  }
  if (sasUrl !== null &amp;&amp; sasUrl !== undefined) {
    queryParameters.push('sasUrl=' + encodeURIComponent(sasUrl));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stop ongoing capturing network packets for the site.
 *
 * Stop ongoing capturing network packets for the site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stopWebSiteNetworkTrace(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Generates a new publishing password for an app (or deployment slot,
 * if specified).
 *
 * Generates a new publishing password for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _generateNewSitePublishingPassword(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets perfmon counters for web app.
 *
 * Gets perfmon counters for web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filter] Return only usages/metrics specified in the
 * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
 * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
 * eq duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PerfMonCounterCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPerfMonCounters(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filter = (options &amp;&amp; options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (filter !== null &amp;&amp; filter !== undefined &amp;&amp; typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (filter !== null &amp;&amp; filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PerfMonCounterCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets web app's event logs.
 *
 * Gets web app's event logs.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SitePhpErrorLogFlag} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSitePhpErrorLogFlag(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SitePhpErrorLogFlag']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the premier add-ons of an app.
 *
 * Gets the premier add-ons of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPremierAddOns(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a named add-on of an app.
 *
 * Gets a named add-on of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPremierAddOn(resourceGroupName, name, premierAddOnName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a named add-on of an app.
 *
 * Updates a named add-on of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {object} premierAddOn A JSON representation of the edited premier
 * add-on.
 *
 * @param {string} [premierAddOn.sku] SKU.
 *
 * @param {string} [premierAddOn.product] Product.
 *
 * @param {string} [premierAddOn.vendor] Vendor.
 *
 * @param {string} [premierAddOn.premierAddOnName] Name.
 *
 * @param {string} [premierAddOn.premierAddOnLocation] Location.
 *
 * @param {object} [premierAddOn.premierAddOnTags] Tags.
 *
 * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
 *
 * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
 *
 * @param {string} [premierAddOn.name] Resource Name.
 *
 * @param {string} [premierAddOn.kind] Kind of resource.
 *
 * @param {string} premierAddOn.location Resource Location.
 *
 * @param {string} [premierAddOn.type] Resource type.
 *
 * @param {object} [premierAddOn.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOn === null || premierAddOn === undefined) {
      throw new Error('premierAddOn cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (premierAddOn !== null &amp;&amp; premierAddOn !== undefined) {
      let requestModelMapper = new client.models['PremierAddOn']().mapper();
      requestModel = client.serialize(requestModelMapper, premierAddOn, 'premierAddOn');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(premierAddOn, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a premier add-on from an app.
 *
 * Delete a premier add-on from an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deletePremierAddOn(resourceGroupName, name, premierAddOnName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the publishing profile for an app (or deployment slot, if
 * specified).
 *
 * Gets the publishing profile for an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.format] Name of the format. Valid values are:
 * FileZilla3
 * WebDeploy -- default
 * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPublishingProfileXmlWithSecrets(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let format = (options &amp;&amp; options.format !== undefined) ? options.format : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (format !== null &amp;&amp; format !== undefined &amp;&amp; typeof format.valueOf() !== 'string') {
      throw new Error('format must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let publishingProfileOptions;
  if (format !== null &amp;&amp; format !== undefined) {
    publishingProfileOptions = new client.models['CsmPublishingProfileOptions']();
    publishingProfileOptions.format = format;
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (publishingProfileOptions !== null &amp;&amp; publishingProfileOptions !== undefined) {
      let requestModelMapper = new client.models['CsmPublishingProfileOptions']().mapper();
      requestModel = client.serialize(requestModelMapper, publishingProfileOptions, 'publishingProfileOptions');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(publishingProfileOptions, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  httpRequest.streamedResponse = true;
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }

    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(`Unexpected status code: ${statusCode}`);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        if (responseBody !== undefined) parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }

    // Create Result
    let result = response;
    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Recovers a deleted web app.
 *
 * Recovers a deleted web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} recoveryEntity Snapshot data used for web app recovery.
 * Snapshot information can be obtained by calling GetDeletedSites or
 * GetSiteSnapshots API.
 *
 * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
 * recovery should be attempted.
 *
 * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
 * into which app should be recovered. This is case when new app should be
 * created instead.
 *
 * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
 * name into which app should be recovered.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RecoverResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recover(resourceGroupName, name, recoveryEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginRecover(resourceGroupName, name, recoveryEntity, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RecoverResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Resets the configuration settings of the current slot if they were
 * previously modified by calling the API with POST.
 *
 * Resets the configuration settings of the current slot if they were
 * previously modified by calling the API with POST.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resetProductionSlotConfig(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restarts an app (or deployment slot, if specified).
 *
 * Restarts an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.softRestart] Specify true to apply the
 * configuration settings and restarts the app only if necessary. By default,
 * the API always restarts and reprovisions the app.
 *
 * @param {boolean} [options.synchronous] Specify true to block until the app
 * is restarted. By default, it is set to false, and the API responds
 * immediately (asynchronous).
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restart(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let softRestart = (options &amp;&amp; options.softRestart !== undefined) ? options.softRestart : undefined;
  let synchronous = (options &amp;&amp; options.synchronous !== undefined) ? options.synchronous : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (softRestart !== null &amp;&amp; softRestart !== undefined &amp;&amp; typeof softRestart !== 'boolean') {
      throw new Error('softRestart must be of type boolean.');
    }
    if (synchronous !== null &amp;&amp; synchronous !== undefined &amp;&amp; typeof synchronous !== 'boolean') {
      throw new Error('synchronous must be of type boolean.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (softRestart !== null &amp;&amp; softRestart !== undefined) {
    queryParameters.push('softRestart=' + encodeURIComponent(softRestart.toString()));
  }
  if (synchronous !== null &amp;&amp; synchronous !== undefined) {
    queryParameters.push('synchronous=' + encodeURIComponent(synchronous.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets an app's deployment slots.
 *
 * Gets an app's deployment slots.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlots(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the details of a web, mobile, or API app.
 *
 * Gets the details of a web, mobile, or API app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. By default, this API
 * returns the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Creates a new web, mobile, or API app in an existing resource
 * group, or updates an existing app.
 *
 * Creates a new web, mobile, or API app in an existing resource group, or
 * updates an existing app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Unique name of the app to create or update. To create
 * or update a deployment slot, use the {slot} parameter.
 *
 * @param {object} siteEnvelope A JSON representation of the app properties.
 * See example.
 *
 * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
 * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
 * the app (takes the app offline).
 *
 * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
 * to manage the SSL bindings for app's hostnames.
 *
 * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
 * App Service plan, formatted as:
 * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
 *
 * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
 * otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
 *
 * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
 * version.
 *
 * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
 * and version
 *
 * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
 * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
 * tracing expiration time.
 *
 * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
 * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
 * debugging version.
 *
 * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
 * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
 * directory size limit.
 *
 * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
 * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
 * name.
 *
 * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
 * strings.
 *
 * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
 * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
 * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
 * 'OneDrive', 'VSO'
 *
 * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
 * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
 * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
 * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
 * container version.
 *
 * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
 * launch.
 *
 * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
 * pipeline mode. Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
 * applications.
 *
 * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
 * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
 * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
 * for polymophic types.
 *
 * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
 * ramp-up rules.
 *
 * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
 * allowed CPU usage percentage.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
 * allowed memory usage in MB.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
 * allowed disk size usage in MB.
 *
 * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
 * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
 * that describe when to execute the auto-heal actions.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
 * rule based on total requests.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
 * interval.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
 * A rule based on status codes.
 *
 * @param {object}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
 * on request execution time.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
 * taken.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
 * Time interval.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
 * be executed when a rule is triggered.
 *
 * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
 * Predefined action to be taken. Possible values include: 'Recycle',
 * 'LogEvent', 'CustomAction'
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
 * Custom action to be taken.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
 * to be run.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
 * (CORS) settings.
 *
 * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
 * the list of origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
 * flag indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
 * a JSON string containing a list of tags that are whitelisted for use by the
 * push registration endpoint.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
 * sets a JSON string containing a list of tags that require user
 * authentication to be used in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
 * a JSON string containing a list of dynamic tags that will be evaluated from
 * user claims in the push registration endpoint.
 *
 * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
 * the formal API definition for the app.
 *
 * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
 * API definition.
 *
 * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
 * name.
 *
 * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
 * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
 * restrictions.
 *
 * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
 * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
 * default is &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
 * Environment to use for the app.
 *
 * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
 * the App Service Environment.
 *
 * @param {string} [siteEnvelope.microService] Micro services like apps, logic
 * apps.
 *
 * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
 * associated with the app.
 *
 * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
 * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
 * cookies, which route client requests in the same session to the same
 * instance. Default is &lt;code>true&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
 * enable client certificate authentication (TLS mutual authentication);
 * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
 * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
 * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
 *
 * @param {number} [siteEnvelope.containerSize] Size of the function container.
 *
 * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
 * memory-time quota (applicable on dynamic apps only).
 *
 * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
 * the app is cloned from a source app.
 *
 * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
 * cloning operation. This ID ties multiple cloning operations
 * together to use the same snapshot.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
 * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
 * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
 * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
 * the source app. App resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
 * for production slots and
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
 * for other slots.
 *
 * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
 * Environment.
 *
 * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
 * setting overrides for cloned app. If specified, these settings override the
 * settings cloned
 * from source app. Otherwise, application settings from source app are
 * retained.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
 * &lt;code>true&lt;/code> to configure load balancing for source and destination
 * app.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
 * resource ID of the Traffic Manager profile to use, if it exists. Traffic
 * Manager resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
 * Traffic Manager profile to create. This is only needed if Traffic Manager
 * profile does not already exist.
 *
 * @param {string} [siteEnvelope.name] Resource Name.
 *
 * @param {string} [siteEnvelope.kind] Kind of resource.
 *
 * @param {string} siteEnvelope.location Resource Location.
 *
 * @param {string} [siteEnvelope.type] Resource type.
 *
 * @param {object} [siteEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot to create or update. By
 * default, this API attempts to create or modify the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
 * not registered with DNS on creation. This parameter is
 * only used for app creation
 *
 * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
 * *.azurewebsites.net) domains associated with web app are not verified.
 *
 * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
 * force registered with DNS
 *
 * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
 * default domain name
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
 *
 * Deletes a web, mobile, or API app, or one of the deployment slots.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app to delete.
 *
 * @param {string} slot Name of the deployment slot to delete. By default, the
 * API deletes the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
 * deleted
 *
 * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
 * Service plan will be empty after app deletion and you want to delete the
 * empty App Service plan. By default, the empty App Service plan is not
 * deleted.
 *
 * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
 * skipped
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let deleteMetrics = (options &amp;&amp; options.deleteMetrics !== undefined) ? options.deleteMetrics : undefined;
  let deleteEmptyServerFarm = (options &amp;&amp; options.deleteEmptyServerFarm !== undefined) ? options.deleteEmptyServerFarm : undefined;
  let skipDnsRegistration = (options &amp;&amp; options.skipDnsRegistration !== undefined) ? options.skipDnsRegistration : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (deleteMetrics !== null &amp;&amp; deleteMetrics !== undefined &amp;&amp; typeof deleteMetrics !== 'boolean') {
      throw new Error('deleteMetrics must be of type boolean.');
    }
    if (deleteEmptyServerFarm !== null &amp;&amp; deleteEmptyServerFarm !== undefined &amp;&amp; typeof deleteEmptyServerFarm !== 'boolean') {
      throw new Error('deleteEmptyServerFarm must be of type boolean.');
    }
    if (skipDnsRegistration !== null &amp;&amp; skipDnsRegistration !== undefined &amp;&amp; typeof skipDnsRegistration !== 'boolean') {
      throw new Error('skipDnsRegistration must be of type boolean.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (deleteMetrics !== null &amp;&amp; deleteMetrics !== undefined) {
    queryParameters.push('deleteMetrics=' + encodeURIComponent(deleteMetrics.toString()));
  }
  if (deleteEmptyServerFarm !== null &amp;&amp; deleteEmptyServerFarm !== undefined) {
    queryParameters.push('deleteEmptyServerFarm=' + encodeURIComponent(deleteEmptyServerFarm.toString()));
  }
  if (skipDnsRegistration !== null &amp;&amp; skipDnsRegistration !== undefined) {
    queryParameters.push('skipDnsRegistration=' + encodeURIComponent(skipDnsRegistration.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Analyze a custom hostname.
 *
 * Analyze a custom hostname.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.hostName] Custom hostname
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CustomHostnameAnalysisResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _analyzeCustomHostnameSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let hostName = (options &amp;&amp; options.hostName !== undefined) ? options.hostName : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (hostName !== null &amp;&amp; hostName !== undefined &amp;&amp; typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (hostName !== null &amp;&amp; hostName !== undefined) {
    queryParameters.push('hostName=' + encodeURIComponent(hostName));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['CustomHostnameAnalysisResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Applies the configuration settings from the target slot onto the
 * current slot.
 *
 * Applies the configuration settings from the target slot onto the current
 * slot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
 * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} slot Name of the source slot. If a slot is not specified,
 * the production slot is used as the source slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _applySlotConfigurationSlot(resourceGroupName, name, slotSwapEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null &amp;&amp; slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a backup of an app.
 *
 * Creates a backup of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request Backup configuration. You can use the JSON response
 * from the POST action as input here.
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will create a backup for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _backupSlot(resourceGroupName, name, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null &amp;&amp; request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets existing backups of an app.
 *
 * Gets existing backups of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get backups of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItemCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackupsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItemCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Discovers an existing app backup that can be restored from a blob
 * in Azure storage.
 *
 * Discovers an existing app backup that can be restored from a blob in Azure
 * storage.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request A RestoreRequest object that includes Azure storage
 * URL and blog name for discovery of backup.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
 * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
 * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
 * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will perform discovery for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _discoverRestoreSlot(resourceGroupName, name, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/discover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null &amp;&amp; request !== undefined) {
      let requestModelMapper = new client.models['RestoreRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a backup of an app by its ID.
 *
 * Gets a backup of an app by its ID.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get a backup of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupStatusSlot(resourceGroupName, name, backupId, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a backup of an app by its ID.
 *
 * Deletes a backup of an app by its ID.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete a backup of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteBackupSlot(resourceGroupName, name, backupId, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets status of a web app backup that may be in progress, including
 * secrets associated with the backup, such as the Azure Storage SAS URL. Also
 * can be used to update the SAS URL for the backup if a new URL is passed in
 * the request body.
 *
 * Gets status of a web app backup that may be in progress, including secrets
 * associated with the backup, such as the Azure Storage SAS URL. Also can be
 * used to update the SAS URL for the backup if a new URL is passed in the
 * request body.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} backupId Id of backup
 *
 * @param {object} request Information on backup request
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackupStatusSecretsSlot(resourceGroupName, name, backupId, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null &amp;&amp; request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} request Information on restore request
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
 * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
 * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
 * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will restore a backup of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restoreSlot(resourceGroupName, name, backupId, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Replaces the application settings of an app.
 *
 * Replaces the application settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} appSettings Application settings of the app.
 *
 * @param {object} [appSettings.properties] Settings.
 *
 * @param {string} [appSettings.name] Resource Name.
 *
 * @param {string} [appSettings.kind] Kind of resource.
 *
 * @param {string} appSettings.location Resource Location.
 *
 * @param {string} [appSettings.type] Resource type.
 *
 * @param {object} [appSettings.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the application settings for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateApplicationSettingsSlot(resourceGroupName, name, appSettings, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (appSettings === null || appSettings === undefined) {
      throw new Error('appSettings cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (appSettings !== null &amp;&amp; appSettings !== undefined) {
      let requestModelMapper = new client.models['StringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, appSettings, 'appSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(appSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the application settings of an app.
 *
 * Gets the application settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the application settings for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listApplicationSettingsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the Authentication / Authorization settings associated with
 * web app.
 *
 * Updates the Authentication / Authorization settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} siteAuthSettings Auth settings associated with web app
 *
 * @param {boolean} [siteAuthSettings.enabled] &lt;code>true&lt;/code> if the
 * Authentication / Authorization feature is enabled for the current app;
 * otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
 * Authentication / Authorization feature in use for the current app.
 * The setting in this value can control the behavior of certain features in
 * the Authentication / Authorization module.
 *
 * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
 * take when an unauthenticated client attempts to access the app. Possible
 * values include: 'RedirectToLoginPage', 'AllowAnonymous'
 *
 * @param {boolean} [siteAuthSettings.tokenStoreEnabled] &lt;code>true&lt;/code> to
 * durably store platform-specific security tokens that are obtained during
 * login flows; otherwise, &lt;code>false&lt;/code>.
 * The default is &lt;code>false&lt;/code>.
 *
 * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
 * that can be redirected to as part of logging in or logging out of the app.
 * Note that the query string part of the URL is ignored.
 * This is an advanced setting typically only needed by Windows Store
 * application backends.
 * Note that URLs within the current domain are always implicitly allowed.
 *
 * @param {string} [siteAuthSettings.defaultProvider] The default
 * authentication provider to use when multiple providers are configured.
 * This setting is only needed if multiple providers are configured and the
 * unauthenticated client
 * action is set to "RedirectToLoginPage". Possible values include:
 * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
 *
 * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
 * hours after session token expiration that a session token can be used to
 * call the token refresh API. The default is 72 hours.
 *
 * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
 * party application, known as the client_id.
 * This setting is required for enabling OpenID Connection authentication with
 * Azure Active Directory or
 * other 3rd party OpenID Connect providers.
 * More information on OpenID Connect:
 * http://openid.net/specs/openid-connect-core-1_0.html
 *
 * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
 * relying party application (in Azure Active Directory, this is also referred
 * to as the Key).
 * This setting is optional. If no client secret is configured, the OpenID
 * Connect implicit auth flow is used to authenticate end users.
 * Otherwise, the OpenID Connect Authorization Code Flow is used to
 * authenticate end users.
 * More information on OpenID Connect:
 * http://openid.net/specs/openid-connect-core-1_0.html
 *
 * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
 * represents the entity which issues access tokens for this application.
 * When using Azure Active Directory, this value is the URI of the directory
 * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
 * This URI is a case-sensitive identifier for the token issuer.
 * More information on OpenID Connect Discovery:
 * http://openid.net/specs/openid-connect-discovery-1_0.html
 *
 * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
 * to consider when validating JWTs issued by
 * Azure Active Directory. Note that the &lt;code>ClientID&lt;/code> value is always
 * considered an
 * allowed audience, regardless of this setting.
 *
 * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
 * send to the OpenID Connect authorization endpoint when
 * a user logs in. Each parameter must be in the form "key=value".
 *
 * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
 * ID for the Google web application.
 * This setting is required for enabling Google Sign-In.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {string} [siteAuthSettings.googleClientSecret] The client secret
 * associated with the Google web application.
 * This setting is required for enabling Google Sign-In.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
 * that will be requested as part of Google Sign-In authentication.
 * This setting is optional. If not specified, "openid", "profile", and "email"
 * are used as default scopes.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
 * app used for login.
 * This setting is required for enabling Facebook Login.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
 * Facebook app used for Facebook Login.
 * This setting is required for enabling Facebook Login.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
 * that will be requested as part of Facebook Login authentication.
 * This setting is optional.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
 * consumer key of the Twitter application used for sign-in.
 * This setting is required for enabling Twitter Sign-In.
 * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
 *
 * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
 * consumer secret of the Twitter application used for sign-in.
 * This setting is required for enabling Twitter Sign-In.
 * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
 *
 * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
 * client ID that was created for the app used for authentication.
 * This setting is required for enabling Microsoft Account authentication.
 * Microsoft Account OAuth documentation:
 * https://dev.onedrive.com/auth/msa_oauth.htm
 *
 * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
 * 2.0 client secret that was created for the app used for authentication.
 * This setting is required for enabling Microsoft Account authentication.
 * Microsoft Account OAuth documentation:
 * https://dev.onedrive.com/auth/msa_oauth.htm
 *
 * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
 * scopes that will be requested as part of Microsoft Account authentication.
 * This setting is optional. If not specified, "wl.basic" is used as the
 * default scope.
 * Microsoft Account Scopes and permissions documentation:
 * https://msdn.microsoft.com/en-us/library/dn631845.aspx
 *
 * @param {string} [siteAuthSettings.name] Resource Name.
 *
 * @param {string} [siteAuthSettings.kind] Kind of resource.
 *
 * @param {string} siteAuthSettings.location Resource Location.
 *
 * @param {string} [siteAuthSettings.type] Resource type.
 *
 * @param {object} [siteAuthSettings.tags] Resource tags.
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteAuthSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateAuthSettingsSlot(resourceGroupName, name, siteAuthSettings, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteAuthSettings === null || siteAuthSettings === undefined) {
      throw new Error('siteAuthSettings cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteAuthSettings !== null &amp;&amp; siteAuthSettings !== undefined) {
      let requestModelMapper = new client.models['SiteAuthSettings']().mapper();
      requestModel = client.serialize(requestModelMapper, siteAuthSettings, 'siteAuthSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteAuthSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteAuthSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Authentication/Authorization settings of an app.
 *
 * Gets the Authentication/Authorization settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the settings for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteAuthSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAuthSettingsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteAuthSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the backup configuration of an app.
 *
 * Updates the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request Edited backup configuration.
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the backup configuration for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateBackupConfigurationSlot(resourceGroupName, name, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null &amp;&amp; request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes the backup configuration of an app.
 *
 * Deletes the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the backup configuration for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteBackupConfigurationSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the backup configuration of an app.
 *
 * Gets the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the backup configuration for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupConfigurationSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Replaces the connection strings of an app.
 *
 * Replaces the connection strings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} connectionStrings Connection strings of the app or
 * deployment slot. See example.
 *
 * @param {object} [connectionStrings.properties] Connection strings.
 *
 * @param {string} [connectionStrings.name] Resource Name.
 *
 * @param {string} [connectionStrings.kind] Kind of resource.
 *
 * @param {string} connectionStrings.location Resource Location.
 *
 * @param {string} [connectionStrings.type] Resource type.
 *
 * @param {object} [connectionStrings.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the connection settings for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ConnectionStringDictionary} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateConnectionStringsSlot(resourceGroupName, name, connectionStrings, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (connectionStrings === null || connectionStrings === undefined) {
      throw new Error('connectionStrings cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionStrings !== null &amp;&amp; connectionStrings !== undefined) {
      let requestModelMapper = new client.models['ConnectionStringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionStrings, 'connectionStrings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionStrings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ConnectionStringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the connection strings of an app.
 *
 * Gets the connection strings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the connection settings for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ConnectionStringDictionary} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listConnectionStringsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ConnectionStringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the logging configuration of an app.
 *
 * Gets the logging configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the logging configuration for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteLogsConfig} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteLogsConfig']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the logging configuration of an app.
 *
 * Updates the logging configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
 * the logging configuration to change in the "properties" property.
 *
 * @param {object} [siteLogsConfig.applicationLogs] Application logs
 * configuration.
 *
 * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
 * to file system configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
 * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
 *
 * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
 * Application logs to azure table storage configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
 * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
 * 'Error'
 *
 * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
 * URL to an Azure table with add/query/delete permissions.
 *
 * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
 * Application logs to blob storage configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
 * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
 * 'Error'
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
 * url to a azure blob container with read/write/list/delete permissions.
 *
 * @param {number}
 * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
 * in days.
 * Remove blobs older than X days.
 * 0 or lower means no retention.
 *
 * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
 *
 * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
 * system configuration.
 *
 * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
 * size in megabytes that http log files can use.
 * When reached old log files will be removed to make space for new ones.
 * Value can range between 25 and 100.
 *
 * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
 * Retention in days.
 * Remove files older than X days.
 * 0 or lower means no retention.
 *
 * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
 *
 * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
 * azure blob storage configuration.
 *
 * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
 * a azure blob container with read/write/list/delete permissions.
 *
 * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
 * Retention in days.
 * Remove blobs older than X days.
 * 0 or lower means no retention.
 *
 * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
 *
 * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
 * tracing configuration.
 *
 * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
 * messages configuration.
 *
 * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
 *
 * @param {string} [siteLogsConfig.name] Resource Name.
 *
 * @param {string} [siteLogsConfig.kind] Kind of resource.
 *
 * @param {string} siteLogsConfig.location Resource Location.
 *
 * @param {string} [siteLogsConfig.type] Resource type.
 *
 * @param {object} [siteLogsConfig.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the logging configuration for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteLogsConfig} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateDiagnosticLogsConfigSlot(resourceGroupName, name, siteLogsConfig, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteLogsConfig === null || siteLogsConfig === undefined) {
      throw new Error('siteLogsConfig cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteLogsConfig !== null &amp;&amp; siteLogsConfig !== undefined) {
      let requestModelMapper = new client.models['SiteLogsConfig']().mapper();
      requestModel = client.serialize(requestModelMapper, siteLogsConfig, 'siteLogsConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteLogsConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteLogsConfig']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Replaces the metadata of an app.
 *
 * Replaces the metadata of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} metadata Edited metadata of the app or deployment slot. See
 * example.
 *
 * @param {object} [metadata.properties] Settings.
 *
 * @param {string} [metadata.name] Resource Name.
 *
 * @param {string} [metadata.kind] Kind of resource.
 *
 * @param {string} metadata.location Resource Location.
 *
 * @param {string} [metadata.type] Resource type.
 *
 * @param {object} [metadata.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the metadata for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateMetadataSlot(resourceGroupName, name, metadata, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (metadata === null || metadata === undefined) {
      throw new Error('metadata cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (metadata !== null &amp;&amp; metadata !== undefined) {
      let requestModelMapper = new client.models['StringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, metadata, 'metadata');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(metadata, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the metadata of an app.
 *
 * Gets the metadata of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the metadata for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetadataSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Gets the Git/FTP publishing credentials of an app.
 *
 * Gets the Git/FTP publishing credentials of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the publishing credentials for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link User} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPublishingCredentialsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['User']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Updates the Push settings associated with web app.
 *
 * Updates the Push settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} pushSettings Push settings associated with web app
 *
 * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
 * whether the Push endpoint is enabled.
 *
 * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
 * containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
 * containing a list of tags that require user authentication to be used in the
 * push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PushSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateSitePushSettingsSlot(resourceGroupName, name, pushSettings, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (pushSettings === null || pushSettings === undefined) {
      throw new Error('pushSettings cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (pushSettings !== null &amp;&amp; pushSettings !== undefined) {
      let requestModelMapper = new client.models['PushSettings']().mapper();
      requestModel = client.serialize(requestModelMapper, pushSettings, 'pushSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(pushSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PushSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Push settings associated with web app.
 *
 * Gets the Push settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PushSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSitePushSettingsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PushSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the configuration of an app, such as platform version and
 * bitness, default documents, virtual applications, Always On, etc.
 *
 * Gets the configuration of an app, such as platform version and bitness,
 * default documents, virtual applications, Always On, etc.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will return configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getConfigurationSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the configuration of an app.
 *
 * Updates the configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteConfig JSON representation of a SiteConfig object. See
 * example.
 *
 * @param {number} [siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
 *
 * @param {string} [siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
 *
 * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
 * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
 * expiration time.
 *
 * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
 * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
 * version.
 *
 * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
 * logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
 * limit.
 *
 * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
 * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.publishingUsername] Publishing user name.
 *
 * @param {array} [siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteConfig.connectionStrings] Connection strings.
 *
 * @param {array} [siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteConfig.scmType] SCM type. Possible values include:
 * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
 * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
 * 'VSO'
 *
 * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
 * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
 * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
 * enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteConfig.javaContainerVersion] Java container version.
 *
 * @param {string} [siteConfig.appCommandLine] App command line to launch.
 *
 * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
 * Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteConfig.virtualApplications] Virtual applications.
 *
 * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
 * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
 * 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteConfig.experiments] This is work around for polymophic
 * types.
 *
 * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
 *
 * @param {object} [siteConfig.limits] Site limits.
 *
 * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
 * usage percentage.
 *
 * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
 * usage in MB.
 *
 * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
 * size usage in MB.
 *
 * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
 * is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
 * when to execute the auto-heal actions.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
 * total requests.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
 * Time interval.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
 * on status codes.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
 * based on request execution time.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
 * Time taken.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
 * Count.
 *
 * @param {string}
 * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
 *
 * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
 * when a rule is triggered.
 *
 * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
 * action to be taken. Possible values include: 'Recycle', 'LogEvent',
 * 'CustomAction'
 *
 * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
 * action to be taken.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
 * Executable to be run.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
 * settings.
 *
 * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
 * origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
 * indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
 * string containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
 * string containing a list of tags that require user authentication to be used
 * in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {object} [siteConfig.apiDefinition] Information about the formal API
 * definition for the app.
 *
 * @param {string} [siteConfig.apiDefinition.url] The URL of the API
 * definition.
 *
 * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
 *
 * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
 * local MySQL; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
 *
 * @param {string} [siteConfig.name] Resource Name.
 *
 * @param {string} [siteConfig.kind] Kind of resource.
 *
 * @param {string} siteConfig.location Resource Location.
 *
 * @param {string} [siteConfig.type] Resource type.
 *
 * @param {object} [siteConfig.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteConfig === null || siteConfig === undefined) {
      throw new Error('siteConfig cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteConfig !== null &amp;&amp; siteConfig !== undefined) {
      let requestModelMapper = new client.models['SiteConfigResource']().mapper();
      requestModel = client.serialize(requestModelMapper, siteConfig, 'siteConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the configuration of an app.
 *
 * Updates the configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteConfig JSON representation of a SiteConfig object. See
 * example.
 *
 * @param {number} [siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
 *
 * @param {string} [siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
 *
 * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
 * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
 * expiration time.
 *
 * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
 * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
 * version.
 *
 * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
 * logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
 * limit.
 *
 * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
 * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.publishingUsername] Publishing user name.
 *
 * @param {array} [siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteConfig.connectionStrings] Connection strings.
 *
 * @param {array} [siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteConfig.scmType] SCM type. Possible values include:
 * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
 * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
 * 'VSO'
 *
 * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
 * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
 * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
 * enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteConfig.javaContainerVersion] Java container version.
 *
 * @param {string} [siteConfig.appCommandLine] App command line to launch.
 *
 * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
 * Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteConfig.virtualApplications] Virtual applications.
 *
 * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
 * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
 * 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteConfig.experiments] This is work around for polymophic
 * types.
 *
 * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
 *
 * @param {object} [siteConfig.limits] Site limits.
 *
 * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
 * usage percentage.
 *
 * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
 * usage in MB.
 *
 * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
 * size usage in MB.
 *
 * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
 * is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
 * when to execute the auto-heal actions.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
 * total requests.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
 * Time interval.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
 * on status codes.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
 * based on request execution time.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
 * Time taken.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
 * Count.
 *
 * @param {string}
 * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
 *
 * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
 * when a rule is triggered.
 *
 * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
 * action to be taken. Possible values include: 'Recycle', 'LogEvent',
 * 'CustomAction'
 *
 * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
 * action to be taken.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
 * Executable to be run.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
 * settings.
 *
 * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
 * origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
 * indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
 * string containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
 * string containing a list of tags that require user authentication to be used
 * in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {object} [siteConfig.apiDefinition] Information about the formal API
 * definition for the app.
 *
 * @param {string} [siteConfig.apiDefinition.url] The URL of the API
 * definition.
 *
 * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
 *
 * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
 * local MySQL; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
 *
 * @param {string} [siteConfig.name] Resource Name.
 *
 * @param {string} [siteConfig.kind] Kind of resource.
 *
 * @param {string} siteConfig.location Resource Location.
 *
 * @param {string} [siteConfig.type] Resource type.
 *
 * @param {object} [siteConfig.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteConfig === null || siteConfig === undefined) {
      throw new Error('siteConfig cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteConfig !== null &amp;&amp; siteConfig !== undefined) {
      let requestModelMapper = new client.models['SiteConfigResource']().mapper();
      requestModel = client.serialize(requestModelMapper, siteConfig, 'siteConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of web app configuration snapshots identifiers. Each
 * element of the list contains a timestamp and the ID of the snapshot.
 *
 * Gets a list of web app configuration snapshots identifiers. Each element of
 * the list contains a timestamp and the ID of the snapshot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will return configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'SiteConfigurationSnapshotInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'SiteConfigurationSnapshotInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a snapshot of the configuration of an app at a previous point
 * in time.
 *
 * Gets a snapshot of the configuration of an app at a previous point in time.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} snapshotId The ID of the snapshot to read.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will return configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (snapshotId === null || snapshotId === undefined || typeof snapshotId.valueOf() !== 'string') {
      throw new Error('snapshotId cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{snapshotId}', encodeURIComponent(snapshotId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Reverts the configuration of an app to a previous snapshot.
 *
 * Reverts the configuration of an app to a previous snapshot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} snapshotId The ID of the snapshot to read.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will return configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (snapshotId === null || snapshotId === undefined || typeof snapshotId.valueOf() !== 'string') {
      throw new Error('snapshotId cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{snapshotId}', encodeURIComponent(snapshotId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API returns deployments for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDeploymentsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get a deployment by its ID for an app, a specific deployment slot,
 * and/or a specific scaled-out instance.
 *
 * Get a deployment by its ID for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API gets a deployment for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeploymentSlot(resourceGroupName, name, id, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Create a deployment for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * Create a deployment for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id ID of an existing deployment.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API creates a deployment for the production slot.
 *
 * @param {object} deployment Deployment details.
 *
 * @param {string} [deployment.deploymentId] ID.
 *
 * @param {number} [deployment.status] Status.
 *
 * @param {string} [deployment.message] Message.
 *
 * @param {string} [deployment.author] Author.
 *
 * @param {string} [deployment.deployer] Deployer.
 *
 * @param {string} [deployment.authorEmail] Author email.
 *
 * @param {date} [deployment.startTime] Start time.
 *
 * @param {date} [deployment.endTime] End time.
 *
 * @param {boolean} [deployment.active] Active.
 *
 * @param {string} [deployment.details] Detail.
 *
 * @param {string} [deployment.name] Resource Name.
 *
 * @param {string} [deployment.kind] Kind of resource.
 *
 * @param {string} deployment.location Resource Location.
 *
 * @param {string} [deployment.type] Resource type.
 *
 * @param {object} [deployment.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (deployment === null || deployment === undefined) {
      throw new Error('deployment cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deployment !== null &amp;&amp; deployment !== undefined) {
      let requestModelMapper = new client.models['Deployment']().mapper();
      requestModel = client.serialize(requestModelMapper, deployment, 'deployment');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deployment, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a deployment by its ID for an app, a specific deployment
 * slot, and/or a specific scaled-out instance.
 *
 * Delete a deployment by its ID for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API deletes a deployment for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDeploymentSlot(resourceGroupName, name, id, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists ownership identifiers for domain associated with web app.
 *
 * Lists ownership identifiers for domain associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IdentifierCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['IdentifierCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get domain ownership identifier for web app.
 *
 * Get domain ownership identifier for web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a domain ownership identifier for web app, or updates an
 * existing ownership identifier.
 *
 * Creates a domain ownership identifier for web app, or updates an existing
 * ownership identifier.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} domainOwnershipIdentifier A JSON representation of the
 * domain ownership properties.
 *
 * @param {string} [domainOwnershipIdentifier.identifierId] ID.
 *
 * @param {string} [domainOwnershipIdentifier.name] Resource Name.
 *
 * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
 *
 * @param {string} domainOwnershipIdentifier.location Resource Location.
 *
 * @param {string} [domainOwnershipIdentifier.type] Resource type.
 *
 * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifier === null || domainOwnershipIdentifier === undefined) {
      throw new Error('domainOwnershipIdentifier cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (domainOwnershipIdentifier !== null &amp;&amp; domainOwnershipIdentifier !== undefined) {
      let requestModelMapper = new client.models['Identifier']().mapper();
      requestModel = client.serialize(requestModelMapper, domainOwnershipIdentifier, 'domainOwnershipIdentifier');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(domainOwnershipIdentifier, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a domain ownership identifier for a web app.
 *
 * Deletes a domain ownership identifier for a web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a domain ownership identifier for web app, or updates an
 * existing ownership identifier.
 *
 * Creates a domain ownership identifier for web app, or updates an existing
 * ownership identifier.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} domainOwnershipIdentifier A JSON representation of the
 * domain ownership properties.
 *
 * @param {string} [domainOwnershipIdentifier.identifierId] ID.
 *
 * @param {string} [domainOwnershipIdentifier.name] Resource Name.
 *
 * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
 *
 * @param {string} domainOwnershipIdentifier.location Resource Location.
 *
 * @param {string} [domainOwnershipIdentifier.type] Resource type.
 *
 * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifier === null || domainOwnershipIdentifier === undefined) {
      throw new Error('domainOwnershipIdentifier cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (domainOwnershipIdentifier !== null &amp;&amp; domainOwnershipIdentifier !== undefined) {
      let requestModelMapper = new client.models['Identifier']().mapper();
      requestModel = client.serialize(requestModelMapper, domainOwnershipIdentifier, 'domainOwnershipIdentifier');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(domainOwnershipIdentifier, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get hostname bindings for an app or a deployment slot.
 *
 * Get hostname bindings for an app or a deployment slot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API gets hostname bindings for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBindingCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHostNameBindingsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBindingCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the named hostname binding for an app (or deployment slot, if
 * specified).
 *
 * Get the named hostname binding for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API the named binding for the production slot.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBinding} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBinding']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a hostname binding for an app.
 *
 * Creates a hostname binding for an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} hostNameBinding Binding details. This is the JSON
 * representation of a HostNameBinding object.
 *
 * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
 *
 * @param {string} [hostNameBinding.siteName] App Service app name.
 *
 * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
 * resource URI.
 *
 * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
 *
 * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
 * Possible values include: 'Website', 'TrafficManager'
 *
 * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
 * record type. Possible values include: 'CName', 'A'
 *
 * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
 * values include: 'Verified', 'Managed'
 *
 * @param {string} [hostNameBinding.sslState] SSL type. Possible values
 * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
 *
 * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
 *
 * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
 * the hostname if IP based SSL is enabled.
 *
 * @param {string} [hostNameBinding.name] Resource Name.
 *
 * @param {string} [hostNameBinding.kind] Kind of resource.
 *
 * @param {string} hostNameBinding.location Resource Location.
 *
 * @param {string} [hostNameBinding.type] Resource type.
 *
 * @param {object} [hostNameBinding.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will create a binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBinding} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, hostNameBinding, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (hostNameBinding === null || hostNameBinding === undefined) {
      throw new Error('hostNameBinding cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (hostNameBinding !== null &amp;&amp; hostNameBinding !== undefined) {
      let requestModelMapper = new client.models['HostNameBinding']().mapper();
      requestModel = client.serialize(requestModelMapper, hostNameBinding, 'hostNameBinding');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(hostNameBinding, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBinding']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a hostname binding for an app.
 *
 * Deletes a hostname binding for an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
 * App.
 *
 * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new Hybrid Connection using a Service Bus relay.
 *
 * Creates a new Hybrid Connection using a Service Bus relay.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} connectionEnvelope The details of the hybrid connection
 *
 * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
 * Service Bus namespace.
 *
 * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
 * relay.
 *
 * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
 * Bus relay.
 *
 * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
 *
 * @param {number} [connectionEnvelope.port] The port of the endpoint.
 *
 * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
 * key which has Send permissions. This is used to authenticate to Service Bus.
 *
 * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
 * Bus key. This is used to authenticate to Service Bus. In ARM this key will
 * not be returned
 * normally, use the POST /listKeys API instead.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['HybridConnection']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Removes a Hybrid Connection from this site.
 *
 * Removes a Hybrid Connection from this site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new Hybrid Connection using a Service Bus relay.
 *
 * Creates a new Hybrid Connection using a Service Bus relay.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} connectionEnvelope The details of the hybrid connection
 *
 * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
 * Service Bus namespace.
 *
 * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
 * relay.
 *
 * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
 * Bus relay.
 *
 * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
 *
 * @param {number} [connectionEnvelope.port] The port of the endpoint.
 *
 * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
 * key which has Send permissions. This is used to authenticate to Service Bus.
 *
 * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
 * Bus key. This is used to authenticate to Service Bus. In ARM this key will
 * not be returned
 * normally, use the POST /listKeys API instead.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['HybridConnection']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the send key name and value for a Hybrid Connection.
 *
 * Gets the send key name and value for a Hybrid Connection.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnectionKey} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnectionKey']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
 *
 * Retrieves all Service Bus Hybrid Connections used by this Web App.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHybridConnectionsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets hybrid connections configured for an app (or deployment slot,
 * if specified).
 *
 * Gets hybrid connections configured for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get hybrid connections for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a hybrid connection configuration by its name.
 *
 * Gets a hybrid connection configuration by its name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get a hybrid connection for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new hybrid connection configuration (PUT), or updates an
 * existing one (PATCH).
 *
 * Creates a new hybrid connection configuration (PUT), or updates an existing
 * one (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {object} connectionEnvelope Details of the hybrid connection
 * configuration.
 *
 * @param {string} [connectionEnvelope.entityName]
 *
 * @param {string} [connectionEnvelope.entityConnectionString]
 *
 * @param {string} [connectionEnvelope.resourceType]
 *
 * @param {string} [connectionEnvelope.resourceConnectionString]
 *
 * @param {string} [connectionEnvelope.hostname]
 *
 * @param {number} [connectionEnvelope.port]
 *
 * @param {string} [connectionEnvelope.biztalkUri]
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will create or update a hybrid connection for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['RelayServiceConnectionEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a relay service connection by its name.
 *
 * Deletes a relay service connection by its name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete a hybrid connection for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new hybrid connection configuration (PUT), or updates an
 * existing one (PATCH).
 *
 * Creates a new hybrid connection configuration (PUT), or updates an existing
 * one (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {object} connectionEnvelope Details of the hybrid connection
 * configuration.
 *
 * @param {string} [connectionEnvelope.entityName]
 *
 * @param {string} [connectionEnvelope.entityConnectionString]
 *
 * @param {string} [connectionEnvelope.resourceType]
 *
 * @param {string} [connectionEnvelope.resourceConnectionString]
 *
 * @param {string} [connectionEnvelope.hostname]
 *
 * @param {number} [connectionEnvelope.port]
 *
 * @param {string} [connectionEnvelope.biztalkUri]
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will create or update a hybrid connection for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['RelayServiceConnectionEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all scale-out instances of an app.
 *
 * Gets all scale-out instances of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API gets the production slot instances.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppInstanceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceIdentifiersSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppInstanceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API returns deployments for the production slot.
 *
 * @param {string} instanceId The ID of a specific scaled-out instance. This is
 * the value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get a deployment by its ID for an app, a specific deployment slot,
 * and/or a specific scaled-out instance.
 *
 * Get a deployment by its ID for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API gets a deployment for the production slot.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Create a deployment for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * Create a deployment for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id ID of an existing deployment.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API creates a deployment for the production slot.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} deployment Deployment details.
 *
 * @param {string} [deployment.deploymentId] ID.
 *
 * @param {number} [deployment.status] Status.
 *
 * @param {string} [deployment.message] Message.
 *
 * @param {string} [deployment.author] Author.
 *
 * @param {string} [deployment.deployer] Deployer.
 *
 * @param {string} [deployment.authorEmail] Author email.
 *
 * @param {date} [deployment.startTime] Start time.
 *
 * @param {date} [deployment.endTime] End time.
 *
 * @param {boolean} [deployment.active] Active.
 *
 * @param {string} [deployment.details] Detail.
 *
 * @param {string} [deployment.name] Resource Name.
 *
 * @param {string} [deployment.kind] Kind of resource.
 *
 * @param {string} deployment.location Resource Location.
 *
 * @param {string} [deployment.type] Resource type.
 *
 * @param {object} [deployment.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, deployment, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (deployment === null || deployment === undefined) {
      throw new Error('deployment cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deployment !== null &amp;&amp; deployment !== undefined) {
      let requestModelMapper = new client.models['Deployment']().mapper();
      requestModel = client.serialize(requestModelMapper, deployment, 'deployment');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deployment, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a deployment by its ID for an app, a specific deployment
 * slot, and/or a specific scaled-out instance.
 *
 * Delete a deployment by its ID for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API deletes a deployment for the production slot.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Shows whether an app can be cloned to another resource group or
 * subscription.
 *
 * Shows whether an app can be cloned to another resource group or
 * subscription.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. By default, this API
 * returns information on the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteCloneability} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _isCloneableSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteCloneability']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all metric definitions of an app (or deployment slot, if
 * specified).
 *
 * Gets all metric definitions of an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get metric definitions of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricDefinitionCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricDefinitionsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metricdefinitions';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricDefinitionCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets performance metrics of an app (or deployment slot, if
 * specified).
 *
 * Gets performance metrics of an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get metrics of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.details] Specify "true" to include metric details
 * in the response. It is "false" by default.
 *
 * @param {string} [options.filter] Return only metrics specified in the filter
 * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
 * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
 * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let details = (options &amp;&amp; options.details !== undefined) ? options.details : undefined;
  let filter = (options &amp;&amp; options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (details !== null &amp;&amp; details !== undefined &amp;&amp; typeof details !== 'boolean') {
      throw new Error('details must be of type boolean.');
    }
    if (filter !== null &amp;&amp; filter !== undefined &amp;&amp; typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metrics';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (details !== null &amp;&amp; details !== undefined) {
    queryParameters.push('details=' + encodeURIComponent(details.toString()));
  }
  if (filter !== null &amp;&amp; filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Returns the status of MySql in app migration, if one is active, and
 * whether or not MySql in app is enabled
 *
 * Returns the status of MySql in app migration, if one is active, and whether
 * or not MySql in app is enabled
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of the deployment slot
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MigrateMySqlStatus} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['MigrateMySqlStatus']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all network features used by the app (or deployment slot, if
 * specified).
 *
 * Gets all network features used by the app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} view The type of view. This can either be "summary" or
 * "detailed".
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get network features for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NetworkFeatures} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (view === null || view === undefined || typeof view.valueOf() !== 'string') {
      throw new Error('view cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{view}', encodeURIComponent(view));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['NetworkFeatures']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Start capturing network packets for the site.
 *
 * Start capturing network packets for the site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app.
 *
 * @param {string} slot The name of the slot for this web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.durationInSeconds] The duration to keep capturing
 * in seconds.
 *
 * @param {number} [options.maxFrameLength] The maximum frame length in bytes
 * (Optional).
 *
 * @param {string} [options.sasUrl] The Blob URL to store capture file.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let durationInSeconds = (options &amp;&amp; options.durationInSeconds !== undefined) ? options.durationInSeconds : undefined;
  let maxFrameLength = (options &amp;&amp; options.maxFrameLength !== undefined) ? options.maxFrameLength : undefined;
  let sasUrl = (options &amp;&amp; options.sasUrl !== undefined) ? options.sasUrl : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (durationInSeconds !== null &amp;&amp; durationInSeconds !== undefined &amp;&amp; typeof durationInSeconds !== 'number') {
      throw new Error('durationInSeconds must be of type number.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (maxFrameLength !== null &amp;&amp; maxFrameLength !== undefined &amp;&amp; typeof maxFrameLength !== 'number') {
      throw new Error('maxFrameLength must be of type number.');
    }
    if (sasUrl !== null &amp;&amp; sasUrl !== undefined &amp;&amp; typeof sasUrl.valueOf() !== 'string') {
      throw new Error('sasUrl must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (durationInSeconds !== null &amp;&amp; durationInSeconds !== undefined) {
    queryParameters.push('durationInSeconds=' + encodeURIComponent(durationInSeconds.toString()));
  }
  if (maxFrameLength !== null &amp;&amp; maxFrameLength !== undefined) {
    queryParameters.push('maxFrameLength=' + encodeURIComponent(maxFrameLength.toString()));
  }
  if (sasUrl !== null &amp;&amp; sasUrl !== undefined) {
    queryParameters.push('sasUrl=' + encodeURIComponent(sasUrl));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stop ongoing capturing network packets for the site.
 *
 * Stop ongoing capturing network packets for the site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app.
 *
 * @param {string} slot The name of the slot for this web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Generates a new publishing password for an app (or deployment slot,
 * if specified).
 *
 * Generates a new publishing password for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API generate a new publishing password for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets perfmon counters for web app.
 *
 * Gets perfmon counters for web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot. **** CURRENTLY UNUSED *****
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filter] Return only usages/metrics specified in the
 * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
 * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
 * eq duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PerfMonCounterCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPerfMonCountersSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filter = (options &amp;&amp; options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (filter !== null &amp;&amp; filter !== undefined &amp;&amp; typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (filter !== null &amp;&amp; filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PerfMonCounterCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets web app's event logs.
 *
 * Gets web app's event logs.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SitePhpErrorLogFlag} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SitePhpErrorLogFlag']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the premier add-ons of an app.
 *
 * Gets the premier add-ons of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the premier add-ons for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPremierAddOnsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a named add-on of an app.
 *
 * Gets a named add-on of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the named add-on for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a named add-on of an app.
 *
 * Updates a named add-on of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {object} premierAddOn A JSON representation of the edited premier
 * add-on.
 *
 * @param {string} [premierAddOn.sku] SKU.
 *
 * @param {string} [premierAddOn.product] Product.
 *
 * @param {string} [premierAddOn.vendor] Vendor.
 *
 * @param {string} [premierAddOn.premierAddOnName] Name.
 *
 * @param {string} [premierAddOn.premierAddOnLocation] Location.
 *
 * @param {object} [premierAddOn.premierAddOnTags] Tags.
 *
 * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
 *
 * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
 *
 * @param {string} [premierAddOn.name] Resource Name.
 *
 * @param {string} [premierAddOn.kind] Kind of resource.
 *
 * @param {string} premierAddOn.location Resource Location.
 *
 * @param {string} [premierAddOn.type] Resource type.
 *
 * @param {object} [premierAddOn.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the named add-on for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOn === null || premierAddOn === undefined) {
      throw new Error('premierAddOn cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (premierAddOn !== null &amp;&amp; premierAddOn !== undefined) {
      let requestModelMapper = new client.models['PremierAddOn']().mapper();
      requestModel = client.serialize(requestModelMapper, premierAddOn, 'premierAddOn');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(premierAddOn, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a premier add-on from an app.
 *
 * Delete a premier add-on from an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the named add-on for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the publishing profile for an app (or deployment slot, if
 * specified).
 *
 * Gets the publishing profile for an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the publishing profile for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.format] Name of the format. Valid values are:
 * FileZilla3
 * WebDeploy -- default
 * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let format = (options &amp;&amp; options.format !== undefined) ? options.format : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (format !== null &amp;&amp; format !== undefined &amp;&amp; typeof format.valueOf() !== 'string') {
      throw new Error('format must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let publishingProfileOptions;
  if (format !== null &amp;&amp; format !== undefined) {
    publishingProfileOptions = new client.models['CsmPublishingProfileOptions']();
    publishingProfileOptions.format = format;
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (publishingProfileOptions !== null &amp;&amp; publishingProfileOptions !== undefined) {
      let requestModelMapper = new client.models['CsmPublishingProfileOptions']().mapper();
      requestModel = client.serialize(requestModelMapper, publishingProfileOptions, 'publishingProfileOptions');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(publishingProfileOptions, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  httpRequest.streamedResponse = true;
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }

    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(`Unexpected status code: ${statusCode}`);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        if (responseBody !== undefined) parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }

    // Create Result
    let result = response;
    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Recovers a deleted web app.
 *
 * Recovers a deleted web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} recoveryEntity Snapshot data used for web app recovery.
 * Snapshot information can be obtained by calling GetDeletedSites or
 * GetSiteSnapshots API.
 *
 * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
 * recovery should be attempted.
 *
 * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
 * into which app should be recovered. This is case when new app should be
 * created instead.
 *
 * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
 * name into which app should be recovered.
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RecoverResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverSlot(resourceGroupName, name, recoveryEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RecoverResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Resets the configuration settings of the current slot if they were
 * previously modified by calling the API with POST.
 *
 * Resets the configuration settings of the current slot if they were
 * previously modified by calling the API with POST.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API resets configuration settings for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resetSlotConfigurationSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restarts an app (or deployment slot, if specified).
 *
 * Restarts an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will restart the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.softRestart] Specify true to apply the
 * configuration settings and restarts the app only if necessary. By default,
 * the API always restarts and reprovisions the app.
 *
 * @param {boolean} [options.synchronous] Specify true to block until the app
 * is restarted. By default, it is set to false, and the API responds
 * immediately (asynchronous).
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restartSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let softRestart = (options &amp;&amp; options.softRestart !== undefined) ? options.softRestart : undefined;
  let synchronous = (options &amp;&amp; options.synchronous !== undefined) ? options.synchronous : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (softRestart !== null &amp;&amp; softRestart !== undefined &amp;&amp; typeof softRestart !== 'boolean') {
      throw new Error('softRestart must be of type boolean.');
    }
    if (synchronous !== null &amp;&amp; synchronous !== undefined &amp;&amp; typeof synchronous !== 'boolean') {
      throw new Error('synchronous must be of type boolean.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (softRestart !== null &amp;&amp; softRestart !== undefined) {
    queryParameters.push('softRestart=' + encodeURIComponent(softRestart.toString()));
  }
  if (synchronous !== null &amp;&amp; synchronous !== undefined) {
    queryParameters.push('synchronous=' + encodeURIComponent(synchronous.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the difference in configuration settings between two web app
 * slots.
 *
 * Get the difference in configuration settings between two web app slots.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
 * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} slot Name of the source slot. If a slot is not specified,
 * the production slot is used as the source slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotDifferenceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotDifferencesSlot(resourceGroupName, name, slotSwapEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null &amp;&amp; slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotDifferenceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Swaps two deployment slots of an app.
 *
 * Swaps two deployment slots of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
 * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} slot Name of the source slot. If a slot is not specified,
 * the production slot is used as the source slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _swapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Returns all Snapshots to the user.
 *
 * Returns all Snapshots to the user.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Website Name
 *
 * @param {string} slot Website Slot
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SnapshotCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSnapshotsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SnapshotCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the source control configuration of an app.
 *
 * Gets the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the source control configuration for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSourceControlSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Updates the source control configuration of an app.
 *
 * Updates the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteSourceControl JSON representation of a SiteSourceControl
 * object. See example.
 *
 * @param {string} [siteSourceControl.repoUrl] Repository or source control
 * URL.
 *
 * @param {string} [siteSourceControl.branch] Name of branch to use for
 * deployment.
 *
 * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
 * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
 * integration (which configures webhooks into online repos like GitHub).
 *
 * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
 * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
 * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
 *
 * @param {string} [siteSourceControl.name] Resource Name.
 *
 * @param {string} [siteSourceControl.kind] Kind of resource.
 *
 * @param {string} siteSourceControl.location Resource Location.
 *
 * @param {string} [siteSourceControl.type] Resource type.
 *
 * @param {object} [siteSourceControl.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the source control configuration for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Deletes the source control configuration of an app.
 *
 * Deletes the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the source control configuration for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSourceControlSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 202 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts an app (or deployment slot, if specified).
 *
 * Starts an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will start the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stops an app (or deployment slot, if specified).
 *
 * Stops an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will stop the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stopSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sync web app repository.
 *
 * Sync web app repository.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _syncRepositorySlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get quota information of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filter] Return only information specified in the
 * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
 * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
 * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
 * duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CsmUsageQuotaCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsagesSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filter = (options &amp;&amp; options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (filter !== null &amp;&amp; filter !== undefined &amp;&amp; typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (filter !== null &amp;&amp; filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['CsmUsageQuotaCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the virtual networks the app (or deployment slot) is connected
 * to.
 *
 * Gets the virtual networks the app (or deployment slot) is connected to.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get virtual network connections for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listVnetConnectionsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'VnetInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'VnetInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a virtual network the app (or deployment slot) is connected to
 * by name.
 *
 * Gets a virtual network the app (or deployment slot) is connected to by name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the virtual network.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the named virtual network for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a Virtual Network connection to an app or slot (PUT) or
 * updates the connection properties (PATCH).
 *
 * Adds a Virtual Network connection to an app or slot (PUT) or updates the
 * connection properties (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of an existing Virtual Network.
 *
 * @param {object} connectionEnvelope Properties of the Virtual Network
 * connection. See example.
 *
 * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
 * resource ID.
 *
 * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
 * containing the public key of the private key used to authenticate a
 * Point-To-Site VPN connection.
 *
 * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
 * this Virtual Network. This should be a comma-separated list of IP addresses.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will add or update connections for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetInfo']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a connection from an app (or deployment slot to a named
 * virtual network.
 *
 * Deletes a connection from an app (or deployment slot to a named virtual
 * network.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the virtual network.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the connection for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a Virtual Network connection to an app or slot (PUT) or
 * updates the connection properties (PATCH).
 *
 * Adds a Virtual Network connection to an app or slot (PUT) or updates the
 * connection properties (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of an existing Virtual Network.
 *
 * @param {object} connectionEnvelope Properties of the Virtual Network
 * connection. See example.
 *
 * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
 * resource ID.
 *
 * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
 * containing the public key of the private key used to authenticate a
 * Point-To-Site VPN connection.
 *
 * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
 * this Virtual Network. This should be a comma-separated list of IP addresses.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will add or update connections for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetInfo']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets an app's Virtual Network gateway.
 *
 * Gets an app's Virtual Network gateway.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get a gateway for the production slot's Virtual
 * Network.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
 * (PATCH).
 *
 * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {object} connectionEnvelope The properties to update this gateway
 * with.
 *
 * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
 *
 * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
 * package can be downloaded.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will add or update a gateway for the production slot's
 * Virtual Network.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetGateway']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
 * (PATCH).
 *
 * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {object} connectionEnvelope The properties to update this gateway
 * with.
 *
 * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
 *
 * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
 * package can be downloaded.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will add or update a gateway for the production slot's
 * Virtual Network.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetGateway']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the difference in configuration settings between two web app
 * slots.
 *
 * Get the difference in configuration settings between two web app slots.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
 * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotDifferenceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null &amp;&amp; slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotDifferenceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Swaps two deployment slots of an app.
 *
 * Swaps two deployment slots of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
 * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _swapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Returns all Snapshots to the user.
 *
 * Returns all Snapshots to the user.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Website Name
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SnapshotCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSnapshots(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SnapshotCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the source control configuration of an app.
 *
 * Gets the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSourceControl(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Updates the source control configuration of an app.
 *
 * Updates the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteSourceControl JSON representation of a SiteSourceControl
 * object. See example.
 *
 * @param {string} [siteSourceControl.repoUrl] Repository or source control
 * URL.
 *
 * @param {string} [siteSourceControl.branch] Name of branch to use for
 * deployment.
 *
 * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
 * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
 * integration (which configures webhooks into online repos like GitHub).
 *
 * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
 * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
 * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
 *
 * @param {string} [siteSourceControl.name] Resource Name.
 *
 * @param {string} [siteSourceControl.kind] Kind of resource.
 *
 * @param {string} siteSourceControl.location Resource Location.
 *
 * @param {string} [siteSourceControl.type] Resource type.
 *
 * @param {object} [siteSourceControl.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Deletes the source control configuration of an app.
 *
 * Deletes the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSourceControl(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 202 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts an app (or deployment slot, if specified).
 *
 * Starts an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _start(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stops an app (or deployment slot, if specified).
 *
 * Stops an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stop(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sync web app repository.
 *
 * Sync web app repository.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _syncRepository(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filter] Return only information specified in the
 * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
 * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
 * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
 * duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CsmUsageQuotaCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsages(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filter = (options &amp;&amp; options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (filter !== null &amp;&amp; filter !== undefined &amp;&amp; typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (filter !== null &amp;&amp; filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['CsmUsageQuotaCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the virtual networks the app (or deployment slot) is connected
 * to.
 *
 * Gets the virtual networks the app (or deployment slot) is connected to.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listVnetConnections(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'VnetInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'VnetInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a virtual network the app (or deployment slot) is connected to
 * by name.
 *
 * Gets a virtual network the app (or deployment slot) is connected to by name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the virtual network.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVnetConnection(resourceGroupName, name, vnetName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a Virtual Network connection to an app or slot (PUT) or
 * updates the connection properties (PATCH).
 *
 * Adds a Virtual Network connection to an app or slot (PUT) or updates the
 * connection properties (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of an existing Virtual Network.
 *
 * @param {object} connectionEnvelope Properties of the Virtual Network
 * connection. See example.
 *
 * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
 * resource ID.
 *
 * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
 * containing the public key of the private key used to authenticate a
 * Point-To-Site VPN connection.
 *
 * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
 * this Virtual Network. This should be a comma-separated list of IP addresses.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetInfo']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a connection from an app (or deployment slot to a named
 * virtual network.
 *
 * Deletes a connection from an app (or deployment slot to a named virtual
 * network.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the virtual network.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteVnetConnection(resourceGroupName, name, vnetName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a Virtual Network connection to an app or slot (PUT) or
 * updates the connection properties (PATCH).
 *
 * Adds a Virtual Network connection to an app or slot (PUT) or updates the
 * connection properties (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of an existing Virtual Network.
 *
 * @param {object} connectionEnvelope Properties of the Virtual Network
 * connection. See example.
 *
 * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
 * resource ID.
 *
 * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
 * containing the public key of the private key used to authenticate a
 * Point-To-Site VPN connection.
 *
 * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
 * this Virtual Network. This should be a comma-separated list of IP addresses.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetInfo']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets an app's Virtual Network gateway.
 *
 * Gets an app's Virtual Network gateway.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
 * (PATCH).
 *
 * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {object} connectionEnvelope The properties to update this gateway
 * with.
 *
 * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
 *
 * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
 * package can be downloaded.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetGateway']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
 * (PATCH).
 *
 * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {object} connectionEnvelope The properties to update this gateway
 * with.
 *
 * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
 *
 * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
 * package can be downloaded.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null &amp;&amp; connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetGateway']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new web, mobile, or API app in an existing resource
 * group, or updates an existing app.
 *
 * Creates a new web, mobile, or API app in an existing resource group, or
 * updates an existing app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Unique name of the app to create or update. To create
 * or update a deployment slot, use the {slot} parameter.
 *
 * @param {object} siteEnvelope A JSON representation of the app properties.
 * See example.
 *
 * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
 * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
 * the app (takes the app offline).
 *
 * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
 * to manage the SSL bindings for app's hostnames.
 *
 * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
 * App Service plan, formatted as:
 * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
 *
 * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
 * otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
 *
 * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
 * version.
 *
 * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
 * and version
 *
 * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
 * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
 * tracing expiration time.
 *
 * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
 * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
 * debugging version.
 *
 * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
 * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
 * directory size limit.
 *
 * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
 * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
 * name.
 *
 * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
 * strings.
 *
 * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
 * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
 * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
 * 'OneDrive', 'VSO'
 *
 * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
 * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
 * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
 * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
 * container version.
 *
 * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
 * launch.
 *
 * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
 * pipeline mode. Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
 * applications.
 *
 * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
 * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
 * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
 * for polymophic types.
 *
 * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
 * ramp-up rules.
 *
 * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
 * allowed CPU usage percentage.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
 * allowed memory usage in MB.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
 * allowed disk size usage in MB.
 *
 * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
 * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
 * that describe when to execute the auto-heal actions.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
 * rule based on total requests.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
 * interval.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
 * A rule based on status codes.
 *
 * @param {object}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
 * on request execution time.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
 * taken.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
 * Time interval.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
 * be executed when a rule is triggered.
 *
 * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
 * Predefined action to be taken. Possible values include: 'Recycle',
 * 'LogEvent', 'CustomAction'
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
 * Custom action to be taken.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
 * to be run.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
 * (CORS) settings.
 *
 * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
 * the list of origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
 * flag indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
 * a JSON string containing a list of tags that are whitelisted for use by the
 * push registration endpoint.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
 * sets a JSON string containing a list of tags that require user
 * authentication to be used in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
 * a JSON string containing a list of dynamic tags that will be evaluated from
 * user claims in the push registration endpoint.
 *
 * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
 * the formal API definition for the app.
 *
 * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
 * API definition.
 *
 * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
 * name.
 *
 * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
 * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
 * restrictions.
 *
 * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
 * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
 * default is &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
 * Environment to use for the app.
 *
 * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
 * the App Service Environment.
 *
 * @param {string} [siteEnvelope.microService] Micro services like apps, logic
 * apps.
 *
 * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
 * associated with the app.
 *
 * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
 * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
 * cookies, which route client requests in the same session to the same
 * instance. Default is &lt;code>true&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
 * enable client certificate authentication (TLS mutual authentication);
 * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
 * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
 * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
 *
 * @param {number} [siteEnvelope.containerSize] Size of the function container.
 *
 * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
 * memory-time quota (applicable on dynamic apps only).
 *
 * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
 * the app is cloned from a source app.
 *
 * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
 * cloning operation. This ID ties multiple cloning operations
 * together to use the same snapshot.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
 * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
 * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
 * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
 * the source app. App resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
 * for production slots and
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
 * for other slots.
 *
 * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
 * Environment.
 *
 * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
 * setting overrides for cloned app. If specified, these settings override the
 * settings cloned
 * from source app. Otherwise, application settings from source app are
 * retained.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
 * &lt;code>true&lt;/code> to configure load balancing for source and destination
 * app.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
 * resource ID of the Traffic Manager profile to use, if it exists. Traffic
 * Manager resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
 * Traffic Manager profile to create. This is only needed if Traffic Manager
 * profile does not already exist.
 *
 * @param {string} [siteEnvelope.name] Resource Name.
 *
 * @param {string} [siteEnvelope.kind] Kind of resource.
 *
 * @param {string} siteEnvelope.location Resource Location.
 *
 * @param {string} [siteEnvelope.type] Resource type.
 *
 * @param {object} [siteEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
 * not registered with DNS on creation. This parameter is
 * only used for app creation
 *
 * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
 * *.azurewebsites.net) domains associated with web app are not verified.
 *
 * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
 * force registered with DNS
 *
 * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
 * default domain name
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let skipDnsRegistration = (options &amp;&amp; options.skipDnsRegistration !== undefined) ? options.skipDnsRegistration : undefined;
  let skipCustomDomainVerification = (options &amp;&amp; options.skipCustomDomainVerification !== undefined) ? options.skipCustomDomainVerification : undefined;
  let forceDnsRegistration = (options &amp;&amp; options.forceDnsRegistration !== undefined) ? options.forceDnsRegistration : undefined;
  let ttlInSeconds = (options &amp;&amp; options.ttlInSeconds !== undefined) ? options.ttlInSeconds : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteEnvelope === null || siteEnvelope === undefined) {
      throw new Error('siteEnvelope cannot be null or undefined.');
    }
    if (skipDnsRegistration !== null &amp;&amp; skipDnsRegistration !== undefined &amp;&amp; typeof skipDnsRegistration !== 'boolean') {
      throw new Error('skipDnsRegistration must be of type boolean.');
    }
    if (skipCustomDomainVerification !== null &amp;&amp; skipCustomDomainVerification !== undefined &amp;&amp; typeof skipCustomDomainVerification !== 'boolean') {
      throw new Error('skipCustomDomainVerification must be of type boolean.');
    }
    if (forceDnsRegistration !== null &amp;&amp; forceDnsRegistration !== undefined &amp;&amp; typeof forceDnsRegistration !== 'boolean') {
      throw new Error('forceDnsRegistration must be of type boolean.');
    }
    if (ttlInSeconds !== null &amp;&amp; ttlInSeconds !== undefined &amp;&amp; typeof ttlInSeconds.valueOf() !== 'string') {
      throw new Error('ttlInSeconds must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (skipDnsRegistration !== null &amp;&amp; skipDnsRegistration !== undefined) {
    queryParameters.push('skipDnsRegistration=' + encodeURIComponent(skipDnsRegistration.toString()));
  }
  if (skipCustomDomainVerification !== null &amp;&amp; skipCustomDomainVerification !== undefined) {
    queryParameters.push('skipCustomDomainVerification=' + encodeURIComponent(skipCustomDomainVerification.toString()));
  }
  if (forceDnsRegistration !== null &amp;&amp; forceDnsRegistration !== undefined) {
    queryParameters.push('forceDnsRegistration=' + encodeURIComponent(forceDnsRegistration.toString()));
  }
  if (ttlInSeconds !== null &amp;&amp; ttlInSeconds !== undefined) {
    queryParameters.push('ttlInSeconds=' + encodeURIComponent(ttlInSeconds));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteEnvelope !== null &amp;&amp; siteEnvelope !== undefined) {
      let requestModelMapper = new client.models['Site']().mapper();
      requestModel = client.serialize(requestModelMapper, siteEnvelope, 'siteEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 202) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} request Information on restore request
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
 * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
 * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
 * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginRestore(resourceGroupName, name, backupId, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null &amp;&amp; request !== undefined) {
      let requestModelMapper = new client.models['RestoreRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Git/FTP publishing credentials of an app.
 *
 * Gets the Git/FTP publishing credentials of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link User} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginListPublishingCredentials(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['User']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restores a web app.
 *
 * Restores a web app.
 *
 * @param {string} subscriptionName Azure subscription
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} migrationOptions Migration migrationOptions
 *
 * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
 * connection string.
 *
 * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
 *
 * @param {boolean} [migrationOptions.switchSiteAfterMigration]
 * &lt;code>true&lt;/code>if the app should be switched over; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [migrationOptions.blockWriteAccessToSite] &lt;code>true&lt;/code>
 * if the app should be read only during copy operation; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [migrationOptions.name] Resource Name.
 *
 * @param {string} [migrationOptions.kind] Kind of resource.
 *
 * @param {string} migrationOptions.location Resource Location.
 *
 * @param {string} [migrationOptions.type] Resource type.
 *
 * @param {object} [migrationOptions.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageMigrationResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (subscriptionName === null || subscriptionName === undefined || typeof subscriptionName.valueOf() !== 'string') {
      throw new Error('subscriptionName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (migrationOptions === null || migrationOptions === undefined) {
      throw new Error('migrationOptions cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('subscriptionName=' + encodeURIComponent(subscriptionName));
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (migrationOptions !== null &amp;&amp; migrationOptions !== undefined) {
      let requestModelMapper = new client.models['StorageMigrationOptions']().mapper();
      requestModel = client.serialize(requestModelMapper, migrationOptions, 'migrationOptions');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(migrationOptions, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageMigrationResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Migrates a local (in-app) MySql database to a remote MySql
 * database.
 *
 * Migrates a local (in-app) MySql database to a remote MySql database.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} migrationRequestEnvelope MySql migration options
 *
 * @param {string} [migrationRequestEnvelope.connectionString] Connection
 * string to the remote MySQL database to which data should be migrated.
 *
 * @param {string} [migrationRequestEnvelope.name] Resource Name.
 *
 * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
 *
 * @param {string} migrationRequestEnvelope.location Resource Location.
 *
 * @param {string} [migrationRequestEnvelope.type] Resource type.
 *
 * @param {object} [migrationRequestEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Operation} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (migrationRequestEnvelope === null || migrationRequestEnvelope === undefined) {
      throw new Error('migrationRequestEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (migrationRequestEnvelope !== null &amp;&amp; migrationRequestEnvelope !== undefined) {
      let requestModelMapper = new client.models['MigrateMySqlRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, migrationRequestEnvelope, 'migrationRequestEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(migrationRequestEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Operation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Recovers a deleted web app.
 *
 * Recovers a deleted web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} recoveryEntity Snapshot data used for web app recovery.
 * Snapshot information can be obtained by calling GetDeletedSites or
 * GetSiteSnapshots API.
 *
 * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
 * recovery should be attempted.
 *
 * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
 * into which app should be recovered. This is case when new app should be
 * created instead.
 *
 * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
 * name into which app should be recovered.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RecoverResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginRecover(resourceGroupName, name, recoveryEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (recoveryEntity === null || recoveryEntity === undefined) {
      throw new Error('recoveryEntity cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (recoveryEntity !== null &amp;&amp; recoveryEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSiteRecoveryEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, recoveryEntity, 'recoveryEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(recoveryEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RecoverResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new web, mobile, or API app in an existing resource
 * group, or updates an existing app.
 *
 * Creates a new web, mobile, or API app in an existing resource group, or
 * updates an existing app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Unique name of the app to create or update. To create
 * or update a deployment slot, use the {slot} parameter.
 *
 * @param {object} siteEnvelope A JSON representation of the app properties.
 * See example.
 *
 * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
 * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
 * the app (takes the app offline).
 *
 * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
 * to manage the SSL bindings for app's hostnames.
 *
 * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
 * App Service plan, formatted as:
 * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
 *
 * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
 * otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
 *
 * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
 * version.
 *
 * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
 * and version
 *
 * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
 * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
 * tracing expiration time.
 *
 * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
 * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
 * debugging version.
 *
 * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
 * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
 * directory size limit.
 *
 * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
 * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
 * name.
 *
 * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
 * strings.
 *
 * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
 * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
 * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
 * 'OneDrive', 'VSO'
 *
 * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
 * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
 * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
 * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
 * container version.
 *
 * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
 * launch.
 *
 * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
 * pipeline mode. Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
 * applications.
 *
 * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
 * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
 * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
 * for polymophic types.
 *
 * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
 * ramp-up rules.
 *
 * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
 * allowed CPU usage percentage.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
 * allowed memory usage in MB.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
 * allowed disk size usage in MB.
 *
 * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
 * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
 * that describe when to execute the auto-heal actions.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
 * rule based on total requests.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
 * interval.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
 * A rule based on status codes.
 *
 * @param {object}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
 * on request execution time.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
 * taken.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
 * Time interval.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
 * be executed when a rule is triggered.
 *
 * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
 * Predefined action to be taken. Possible values include: 'Recycle',
 * 'LogEvent', 'CustomAction'
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
 * Custom action to be taken.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
 * to be run.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
 * (CORS) settings.
 *
 * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
 * the list of origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
 * flag indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
 * a JSON string containing a list of tags that are whitelisted for use by the
 * push registration endpoint.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
 * sets a JSON string containing a list of tags that require user
 * authentication to be used in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
 * a JSON string containing a list of dynamic tags that will be evaluated from
 * user claims in the push registration endpoint.
 *
 * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
 * the formal API definition for the app.
 *
 * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
 * API definition.
 *
 * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
 * name.
 *
 * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
 * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
 * restrictions.
 *
 * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
 * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
 * default is &lt;code>false&lt;/code>.
 *
 * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
 * Environment to use for the app.
 *
 * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
 * the App Service Environment.
 *
 * @param {string} [siteEnvelope.microService] Micro services like apps, logic
 * apps.
 *
 * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
 * associated with the app.
 *
 * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
 * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
 * cookies, which route client requests in the same session to the same
 * instance. Default is &lt;code>true&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
 * enable client certificate authentication (TLS mutual authentication);
 * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
 * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
 * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
 *
 * @param {number} [siteEnvelope.containerSize] Size of the function container.
 *
 * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
 * memory-time quota (applicable on dynamic apps only).
 *
 * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
 * the app is cloned from a source app.
 *
 * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
 * cloning operation. This ID ties multiple cloning operations
 * together to use the same snapshot.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
 * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
 * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
 * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
 * the source app. App resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
 * for production slots and
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
 * for other slots.
 *
 * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
 * Environment.
 *
 * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
 * setting overrides for cloned app. If specified, these settings override the
 * settings cloned
 * from source app. Otherwise, application settings from source app are
 * retained.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
 * &lt;code>true&lt;/code> to configure load balancing for source and destination
 * app.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
 * resource ID of the Traffic Manager profile to use, if it exists. Traffic
 * Manager resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
 * Traffic Manager profile to create. This is only needed if Traffic Manager
 * profile does not already exist.
 *
 * @param {string} [siteEnvelope.name] Resource Name.
 *
 * @param {string} [siteEnvelope.kind] Kind of resource.
 *
 * @param {string} siteEnvelope.location Resource Location.
 *
 * @param {string} [siteEnvelope.type] Resource type.
 *
 * @param {object} [siteEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot to create or update. By
 * default, this API attempts to create or modify the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
 * not registered with DNS on creation. This parameter is
 * only used for app creation
 *
 * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
 * *.azurewebsites.net) domains associated with web app are not verified.
 *
 * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
 * force registered with DNS
 *
 * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
 * default domain name
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let skipDnsRegistration = (options &amp;&amp; options.skipDnsRegistration !== undefined) ? options.skipDnsRegistration : undefined;
  let skipCustomDomainVerification = (options &amp;&amp; options.skipCustomDomainVerification !== undefined) ? options.skipCustomDomainVerification : undefined;
  let forceDnsRegistration = (options &amp;&amp; options.forceDnsRegistration !== undefined) ? options.forceDnsRegistration : undefined;
  let ttlInSeconds = (options &amp;&amp; options.ttlInSeconds !== undefined) ? options.ttlInSeconds : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteEnvelope === null || siteEnvelope === undefined) {
      throw new Error('siteEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (skipDnsRegistration !== null &amp;&amp; skipDnsRegistration !== undefined &amp;&amp; typeof skipDnsRegistration !== 'boolean') {
      throw new Error('skipDnsRegistration must be of type boolean.');
    }
    if (skipCustomDomainVerification !== null &amp;&amp; skipCustomDomainVerification !== undefined &amp;&amp; typeof skipCustomDomainVerification !== 'boolean') {
      throw new Error('skipCustomDomainVerification must be of type boolean.');
    }
    if (forceDnsRegistration !== null &amp;&amp; forceDnsRegistration !== undefined &amp;&amp; typeof forceDnsRegistration !== 'boolean') {
      throw new Error('forceDnsRegistration must be of type boolean.');
    }
    if (ttlInSeconds !== null &amp;&amp; ttlInSeconds !== undefined &amp;&amp; typeof ttlInSeconds.valueOf() !== 'string') {
      throw new Error('ttlInSeconds must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (skipDnsRegistration !== null &amp;&amp; skipDnsRegistration !== undefined) {
    queryParameters.push('skipDnsRegistration=' + encodeURIComponent(skipDnsRegistration.toString()));
  }
  if (skipCustomDomainVerification !== null &amp;&amp; skipCustomDomainVerification !== undefined) {
    queryParameters.push('skipCustomDomainVerification=' + encodeURIComponent(skipCustomDomainVerification.toString()));
  }
  if (forceDnsRegistration !== null &amp;&amp; forceDnsRegistration !== undefined) {
    queryParameters.push('forceDnsRegistration=' + encodeURIComponent(forceDnsRegistration.toString()));
  }
  if (ttlInSeconds !== null &amp;&amp; ttlInSeconds !== undefined) {
    queryParameters.push('ttlInSeconds=' + encodeURIComponent(ttlInSeconds));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteEnvelope !== null &amp;&amp; siteEnvelope !== undefined) {
      let requestModelMapper = new client.models['Site']().mapper();
      requestModel = client.serialize(requestModelMapper, siteEnvelope, 'siteEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 202) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} request Information on restore request
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
 * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
 * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
 * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will restore a backup of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null &amp;&amp; request !== undefined) {
      let requestModelMapper = new client.models['RestoreRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Git/FTP publishing credentials of an app.
 *
 * Gets the Git/FTP publishing credentials of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the publishing credentials for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link User} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['User']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Recovers a deleted web app.
 *
 * Recovers a deleted web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} recoveryEntity Snapshot data used for web app recovery.
 * Snapshot information can be obtained by calling GetDeletedSites or
 * GetSiteSnapshots API.
 *
 * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
 * recovery should be attempted.
 *
 * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
 * into which app should be recovered. This is case when new app should be
 * created instead.
 *
 * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
 * name into which app should be recovered.
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RecoverResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (recoveryEntity === null || recoveryEntity === undefined) {
      throw new Error('recoveryEntity cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (recoveryEntity !== null &amp;&amp; recoveryEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSiteRecoveryEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, recoveryEntity, 'recoveryEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(recoveryEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['RecoverResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Swaps two deployment slots of an app.
 *
 * Swaps two deployment slots of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
 * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {string} slot Name of the source slot. If a slot is not specified,
 * the production slot is used as the source slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null &amp;&amp; slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the source control configuration of an app.
 *
 * Updates the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteSourceControl JSON representation of a SiteSourceControl
 * object. See example.
 *
 * @param {string} [siteSourceControl.repoUrl] Repository or source control
 * URL.
 *
 * @param {string} [siteSourceControl.branch] Name of branch to use for
 * deployment.
 *
 * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
 * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
 * integration (which configures webhooks into online repos like GitHub).
 *
 * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
 * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
 * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
 *
 * @param {string} [siteSourceControl.name] Resource Name.
 *
 * @param {string} [siteSourceControl.kind] Kind of resource.
 *
 * @param {string} siteSourceControl.location Resource Location.
 *
 * @param {string} [siteSourceControl.type] Resource type.
 *
 * @param {object} [siteSourceControl.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the source control configuration for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteSourceControl === null || siteSourceControl === undefined) {
      throw new Error('siteSourceControl cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteSourceControl !== null &amp;&amp; siteSourceControl !== undefined) {
      let requestModelMapper = new client.models['SiteSourceControl']().mapper();
      requestModel = client.serialize(requestModelMapper, siteSourceControl, 'siteSourceControl');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteSourceControl, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Swaps two deployment slots of an app.
 *
 * Swaps two deployment slots of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
 * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null &amp;&amp; slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the source control configuration of an app.
 *
 * Updates the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteSourceControl JSON representation of a SiteSourceControl
 * object. See example.
 *
 * @param {string} [siteSourceControl.repoUrl] Repository or source control
 * URL.
 *
 * @param {string} [siteSourceControl.branch] Name of branch to use for
 * deployment.
 *
 * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
 * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
 * integration (which configures webhooks into online repos like GitHub).
 *
 * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
 * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
 * &lt;code>false&lt;/code>.
 *
 * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
 * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
 *
 * @param {string} [siteSourceControl.name] Resource Name.
 *
 * @param {string} [siteSourceControl.kind] Kind of resource.
 *
 * @param {string} siteSourceControl.location Resource Location.
 *
 * @param {string} [siteSourceControl.type] Resource type.
 *
 * @param {object} [siteSourceControl.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null &amp;&amp; resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length &lt; 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteSourceControl === null || siteSourceControl === undefined) {
      throw new Error('siteSourceControl cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&amp;');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteSourceControl !== null &amp;&amp; siteSourceControl !== undefined) {
      let requestModelMapper = new client.models['SiteSourceControl']().mapper();
      requestModel = client.serialize(requestModelMapper, siteSourceControl, 'siteSourceControl');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteSourceControl, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 &amp;&amp; statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get all apps for a subscription.
 *
 * Get all apps for a subscription.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all web, mobile, and API apps in the specified resource group.
 *
 * Gets all web, mobile, and API apps in the specified resource group.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listByResourceGroupNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets existing backups of an app.
 *
 * Gets existing backups of an app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItemCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackupsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItemCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDeploymentsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists ownership identifiers for domain associated with web app.
 *
 * Lists ownership identifiers for domain associated with web app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IdentifierCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDomainOwnershipIdentifiersNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['IdentifierCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get hostname bindings for an app or a deployment slot.
 *
 * Get hostname bindings for an app or a deployment slot.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBindingCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHostNameBindingsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBindingCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all scale-out instances of an app.
 *
 * Gets all scale-out instances of an app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppInstanceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceIdentifiersNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppInstanceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceDeploymentsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all metric definitions of an app (or deployment slot, if
 * specified).
 *
 * Gets all metric definitions of an app (or deployment slot, if specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricDefinitionCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricDefinitionsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricDefinitionCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets performance metrics of an app (or deployment slot, if
 * specified).
 *
 * Gets performance metrics of an app (or deployment slot, if specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets perfmon counters for web app.
 *
 * Gets perfmon counters for web app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PerfMonCounterCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPerfMonCountersNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PerfMonCounterCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets an app's deployment slots.
 *
 * Gets an app's deployment slots.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets existing backups of an app.
 *
 * Gets existing backups of an app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItemCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackupsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItemCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDeploymentsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists ownership identifiers for domain associated with web app.
 *
 * Lists ownership identifiers for domain associated with web app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IdentifierCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDomainOwnershipIdentifiersSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['IdentifierCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get hostname bindings for an app or a deployment slot.
 *
 * Get hostname bindings for an app or a deployment slot.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBindingCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHostNameBindingsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBindingCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all scale-out instances of an app.
 *
 * Gets all scale-out instances of an app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppInstanceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceIdentifiersSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppInstanceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceDeploymentsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all metric definitions of an app (or deployment slot, if
 * specified).
 *
 * Gets all metric definitions of an app (or deployment slot, if specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricDefinitionCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricDefinitionsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricDefinitionCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets performance metrics of an app (or deployment slot, if
 * specified).
 *
 * Gets performance metrics of an app (or deployment slot, if specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets perfmon counters for web app.
 *
 * Gets perfmon counters for web app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PerfMonCounterCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPerfMonCountersSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['PerfMonCounterCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the difference in configuration settings between two web app
 * slots.
 *
 * Get the difference in configuration settings between two web app slots.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotDifferenceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotDifferencesSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotDifferenceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Returns all Snapshots to the user.
 *
 * Returns all Snapshots to the user.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SnapshotCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSnapshotsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SnapshotCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CsmUsageQuotaCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsagesSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['CsmUsageQuotaCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the difference in configuration settings between two web app
 * slots.
 *
 * Get the difference in configuration settings between two web app slots.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotDifferenceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotDifferencesFromProductionNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotDifferenceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Returns all Snapshots to the user.
 *
 * Returns all Snapshots to the user.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SnapshotCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSnapshotsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['SnapshotCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CsmUsageQuotaCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsagesNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null &amp;&amp; this.client.acceptLanguage !== undefined &amp;&amp; typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined &amp;&amp; this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null &amp;&amp; parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null &amp;&amp; parsedResponse !== undefined) {
          let resultMapper = new client.models['CsmUsageQuotaCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @class
 * WebApps
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the WebSiteManagementClient.
 * Initializes a new instance of the WebApps class.
 * @constructor
 *
 * @param {WebSiteManagementClient} client Reference to the service client.
 */
class WebApps {
  constructor(client) {
    this.client = client;
    this._list = _list;
    this._listByResourceGroup = _listByResourceGroup;
    this._get = _get;
    this._createOrUpdate = _createOrUpdate;
    this._deleteMethod = _deleteMethod;
    this._analyzeCustomHostname = _analyzeCustomHostname;
    this._applySlotConfigToProduction = _applySlotConfigToProduction;
    this._backup = _backup;
    this._listBackups = _listBackups;
    this._discoverRestore = _discoverRestore;
    this._getBackupStatus = _getBackupStatus;
    this._deleteBackup = _deleteBackup;
    this._listBackupStatusSecrets = _listBackupStatusSecrets;
    this._restore = _restore;
    this._updateApplicationSettings = _updateApplicationSettings;
    this._listApplicationSettings = _listApplicationSettings;
    this._updateAuthSettings = _updateAuthSettings;
    this._getAuthSettings = _getAuthSettings;
    this._updateBackupConfiguration = _updateBackupConfiguration;
    this._deleteBackupConfiguration = _deleteBackupConfiguration;
    this._getBackupConfiguration = _getBackupConfiguration;
    this._updateConnectionStrings = _updateConnectionStrings;
    this._listConnectionStrings = _listConnectionStrings;
    this._getDiagnosticLogsConfiguration = _getDiagnosticLogsConfiguration;
    this._updateDiagnosticLogsConfig = _updateDiagnosticLogsConfig;
    this._updateMetadata = _updateMetadata;
    this._listMetadata = _listMetadata;
    this._listPublishingCredentials = _listPublishingCredentials;
    this._updateSitePushSettings = _updateSitePushSettings;
    this._listSitePushSettings = _listSitePushSettings;
    this._listSlotConfigurationNames = _listSlotConfigurationNames;
    this._updateSlotConfigurationNames = _updateSlotConfigurationNames;
    this._getConfiguration = _getConfiguration;
    this._createOrUpdateConfiguration = _createOrUpdateConfiguration;
    this._updateConfiguration = _updateConfiguration;
    this._listConfigurationSnapshotInfo = _listConfigurationSnapshotInfo;
    this._getConfigurationSnapshot = _getConfigurationSnapshot;
    this._recoverSiteConfigurationSnapshot = _recoverSiteConfigurationSnapshot;
    this._listDeployments = _listDeployments;
    this._getDeployment = _getDeployment;
    this._createDeployment = _createDeployment;
    this._deleteDeployment = _deleteDeployment;
    this._listDomainOwnershipIdentifiers = _listDomainOwnershipIdentifiers;
    this._getDomainOwnershipIdentifier = _getDomainOwnershipIdentifier;
    this._createOrUpdateDomainOwnershipIdentifier = _createOrUpdateDomainOwnershipIdentifier;
    this._deleteDomainOwnershipIdentifier = _deleteDomainOwnershipIdentifier;
    this._updateDomainOwnershipIdentifier = _updateDomainOwnershipIdentifier;
    this._listHostNameBindings = _listHostNameBindings;
    this._getHostNameBinding = _getHostNameBinding;
    this._createOrUpdateHostNameBinding = _createOrUpdateHostNameBinding;
    this._deleteHostNameBinding = _deleteHostNameBinding;
    this._getHybridConnection = _getHybridConnection;
    this._createOrUpdateHybridConnection = _createOrUpdateHybridConnection;
    this._deleteHybridConnection = _deleteHybridConnection;
    this._updateHybridConnection = _updateHybridConnection;
    this._listHybridConnectionKeys = _listHybridConnectionKeys;
    this._listHybridConnections = _listHybridConnections;
    this._listRelayServiceConnections = _listRelayServiceConnections;
    this._getRelayServiceConnection = _getRelayServiceConnection;
    this._createOrUpdateRelayServiceConnection = _createOrUpdateRelayServiceConnection;
    this._deleteRelayServiceConnection = _deleteRelayServiceConnection;
    this._updateRelayServiceConnection = _updateRelayServiceConnection;
    this._listInstanceIdentifiers = _listInstanceIdentifiers;
    this._listInstanceDeployments = _listInstanceDeployments;
    this._getInstanceDeployment = _getInstanceDeployment;
    this._createInstanceDeployment = _createInstanceDeployment;
    this._deleteInstanceDeployment = _deleteInstanceDeployment;
    this._isCloneable = _isCloneable;
    this._listMetricDefinitions = _listMetricDefinitions;
    this._listMetrics = _listMetrics;
    this._migrateStorage = _migrateStorage;
    this._migrateMySql = _migrateMySql;
    this._getMigrateMySqlStatus = _getMigrateMySqlStatus;
    this._listNetworkFeatures = _listNetworkFeatures;
    this._startWebSiteNetworkTrace = _startWebSiteNetworkTrace;
    this._stopWebSiteNetworkTrace = _stopWebSiteNetworkTrace;
    this._generateNewSitePublishingPassword = _generateNewSitePublishingPassword;
    this._listPerfMonCounters = _listPerfMonCounters;
    this._getSitePhpErrorLogFlag = _getSitePhpErrorLogFlag;
    this._listPremierAddOns = _listPremierAddOns;
    this._getPremierAddOn = _getPremierAddOn;
    this._addPremierAddOn = _addPremierAddOn;
    this._deletePremierAddOn = _deletePremierAddOn;
    this._listPublishingProfileXmlWithSecrets = _listPublishingProfileXmlWithSecrets;
    this._recover = _recover;
    this._resetProductionSlotConfig = _resetProductionSlotConfig;
    this._restart = _restart;
    this._listSlots = _listSlots;
    this._getSlot = _getSlot;
    this._createOrUpdateSlot = _createOrUpdateSlot;
    this._deleteSlot = _deleteSlot;
    this._analyzeCustomHostnameSlot = _analyzeCustomHostnameSlot;
    this._applySlotConfigurationSlot = _applySlotConfigurationSlot;
    this._backupSlot = _backupSlot;
    this._listBackupsSlot = _listBackupsSlot;
    this._discoverRestoreSlot = _discoverRestoreSlot;
    this._getBackupStatusSlot = _getBackupStatusSlot;
    this._deleteBackupSlot = _deleteBackupSlot;
    this._listBackupStatusSecretsSlot = _listBackupStatusSecretsSlot;
    this._restoreSlot = _restoreSlot;
    this._updateApplicationSettingsSlot = _updateApplicationSettingsSlot;
    this._listApplicationSettingsSlot = _listApplicationSettingsSlot;
    this._updateAuthSettingsSlot = _updateAuthSettingsSlot;
    this._getAuthSettingsSlot = _getAuthSettingsSlot;
    this._updateBackupConfigurationSlot = _updateBackupConfigurationSlot;
    this._deleteBackupConfigurationSlot = _deleteBackupConfigurationSlot;
    this._getBackupConfigurationSlot = _getBackupConfigurationSlot;
    this._updateConnectionStringsSlot = _updateConnectionStringsSlot;
    this._listConnectionStringsSlot = _listConnectionStringsSlot;
    this._getDiagnosticLogsConfigurationSlot = _getDiagnosticLogsConfigurationSlot;
    this._updateDiagnosticLogsConfigSlot = _updateDiagnosticLogsConfigSlot;
    this._updateMetadataSlot = _updateMetadataSlot;
    this._listMetadataSlot = _listMetadataSlot;
    this._listPublishingCredentialsSlot = _listPublishingCredentialsSlot;
    this._updateSitePushSettingsSlot = _updateSitePushSettingsSlot;
    this._listSitePushSettingsSlot = _listSitePushSettingsSlot;
    this._getConfigurationSlot = _getConfigurationSlot;
    this._createOrUpdateConfigurationSlot = _createOrUpdateConfigurationSlot;
    this._updateConfigurationSlot = _updateConfigurationSlot;
    this._listConfigurationSnapshotInfoSlot = _listConfigurationSnapshotInfoSlot;
    this._getConfigurationSnapshotSlot = _getConfigurationSnapshotSlot;
    this._recoverSiteConfigurationSnapshotSlot = _recoverSiteConfigurationSnapshotSlot;
    this._listDeploymentsSlot = _listDeploymentsSlot;
    this._getDeploymentSlot = _getDeploymentSlot;
    this._createDeploymentSlot = _createDeploymentSlot;
    this._deleteDeploymentSlot = _deleteDeploymentSlot;
    this._listDomainOwnershipIdentifiersSlot = _listDomainOwnershipIdentifiersSlot;
    this._getDomainOwnershipIdentifierSlot = _getDomainOwnershipIdentifierSlot;
    this._createOrUpdateDomainOwnershipIdentifierSlot = _createOrUpdateDomainOwnershipIdentifierSlot;
    this._deleteDomainOwnershipIdentifierSlot = _deleteDomainOwnershipIdentifierSlot;
    this._updateDomainOwnershipIdentifierSlot = _updateDomainOwnershipIdentifierSlot;
    this._listHostNameBindingsSlot = _listHostNameBindingsSlot;
    this._getHostNameBindingSlot = _getHostNameBindingSlot;
    this._createOrUpdateHostNameBindingSlot = _createOrUpdateHostNameBindingSlot;
    this._deleteHostNameBindingSlot = _deleteHostNameBindingSlot;
    this._getHybridConnectionSlot = _getHybridConnectionSlot;
    this._createOrUpdateHybridConnectionSlot = _createOrUpdateHybridConnectionSlot;
    this._deleteHybridConnectionSlot = _deleteHybridConnectionSlot;
    this._updateHybridConnectionSlot = _updateHybridConnectionSlot;
    this._listHybridConnectionKeysSlot = _listHybridConnectionKeysSlot;
    this._listHybridConnectionsSlot = _listHybridConnectionsSlot;
    this._listRelayServiceConnectionsSlot = _listRelayServiceConnectionsSlot;
    this._getRelayServiceConnectionSlot = _getRelayServiceConnectionSlot;
    this._createOrUpdateRelayServiceConnectionSlot = _createOrUpdateRelayServiceConnectionSlot;
    this._deleteRelayServiceConnectionSlot = _deleteRelayServiceConnectionSlot;
    this._updateRelayServiceConnectionSlot = _updateRelayServiceConnectionSlot;
    this._listInstanceIdentifiersSlot = _listInstanceIdentifiersSlot;
    this._listInstanceDeploymentsSlot = _listInstanceDeploymentsSlot;
    this._getInstanceDeploymentSlot = _getInstanceDeploymentSlot;
    this._createInstanceDeploymentSlot = _createInstanceDeploymentSlot;
    this._deleteInstanceDeploymentSlot = _deleteInstanceDeploymentSlot;
    this._isCloneableSlot = _isCloneableSlot;
    this._listMetricDefinitionsSlot = _listMetricDefinitionsSlot;
    this._listMetricsSlot = _listMetricsSlot;
    this._getMigrateMySqlStatusSlot = _getMigrateMySqlStatusSlot;
    this._listNetworkFeaturesSlot = _listNetworkFeaturesSlot;
    this._startWebSiteNetworkTraceSlot = _startWebSiteNetworkTraceSlot;
    this._stopWebSiteNetworkTraceSlot = _stopWebSiteNetworkTraceSlot;
    this._generateNewSitePublishingPasswordSlot = _generateNewSitePublishingPasswordSlot;
    this._listPerfMonCountersSlot = _listPerfMonCountersSlot;
    this._getSitePhpErrorLogFlagSlot = _getSitePhpErrorLogFlagSlot;
    this._listPremierAddOnsSlot = _listPremierAddOnsSlot;
    this._getPremierAddOnSlot = _getPremierAddOnSlot;
    this._addPremierAddOnSlot = _addPremierAddOnSlot;
    this._deletePremierAddOnSlot = _deletePremierAddOnSlot;
    this._listPublishingProfileXmlWithSecretsSlot = _listPublishingProfileXmlWithSecretsSlot;
    this._recoverSlot = _recoverSlot;
    this._resetSlotConfigurationSlot = _resetSlotConfigurationSlot;
    this._restartSlot = _restartSlot;
    this._listSlotDifferencesSlot = _listSlotDifferencesSlot;
    this._swapSlotSlot = _swapSlotSlot;
    this._listSnapshotsSlot = _listSnapshotsSlot;
    this._getSourceControlSlot = _getSourceControlSlot;
    this._createOrUpdateSourceControlSlot = _createOrUpdateSourceControlSlot;
    this._deleteSourceControlSlot = _deleteSourceControlSlot;
    this._startSlot = _startSlot;
    this._stopSlot = _stopSlot;
    this._syncRepositorySlot = _syncRepositorySlot;
    this._listUsagesSlot = _listUsagesSlot;
    this._listVnetConnectionsSlot = _listVnetConnectionsSlot;
    this._getVnetConnectionSlot = _getVnetConnectionSlot;
    this._createOrUpdateVnetConnectionSlot = _createOrUpdateVnetConnectionSlot;
    this._deleteVnetConnectionSlot = _deleteVnetConnectionSlot;
    this._updateVnetConnectionSlot = _updateVnetConnectionSlot;
    this._getVnetConnectionGatewaySlot = _getVnetConnectionGatewaySlot;
    this._createOrUpdateVnetConnectionGatewaySlot = _createOrUpdateVnetConnectionGatewaySlot;
    this._updateVnetConnectionGatewaySlot = _updateVnetConnectionGatewaySlot;
    this._listSlotDifferencesFromProduction = _listSlotDifferencesFromProduction;
    this._swapSlotWithProduction = _swapSlotWithProduction;
    this._listSnapshots = _listSnapshots;
    this._getSourceControl = _getSourceControl;
    this._createOrUpdateSourceControl = _createOrUpdateSourceControl;
    this._deleteSourceControl = _deleteSourceControl;
    this._start = _start;
    this._stop = _stop;
    this._syncRepository = _syncRepository;
    this._listUsages = _listUsages;
    this._listVnetConnections = _listVnetConnections;
    this._getVnetConnection = _getVnetConnection;
    this._createOrUpdateVnetConnection = _createOrUpdateVnetConnection;
    this._deleteVnetConnection = _deleteVnetConnection;
    this._updateVnetConnection = _updateVnetConnection;
    this._getVnetConnectionGateway = _getVnetConnectionGateway;
    this._createOrUpdateVnetConnectionGateway = _createOrUpdateVnetConnectionGateway;
    this._updateVnetConnectionGateway = _updateVnetConnectionGateway;
    this._beginCreateOrUpdate = _beginCreateOrUpdate;
    this._beginRestore = _beginRestore;
    this._beginListPublishingCredentials = _beginListPublishingCredentials;
    this._beginMigrateStorage = _beginMigrateStorage;
    this._beginMigrateMySql = _beginMigrateMySql;
    this._beginRecover = _beginRecover;
    this._beginCreateOrUpdateSlot = _beginCreateOrUpdateSlot;
    this._beginRestoreSlot = _beginRestoreSlot;
    this._beginListPublishingCredentialsSlot = _beginListPublishingCredentialsSlot;
    this._beginRecoverSlot = _beginRecoverSlot;
    this._beginSwapSlotSlot = _beginSwapSlotSlot;
    this._beginCreateOrUpdateSourceControlSlot = _beginCreateOrUpdateSourceControlSlot;
    this._beginSwapSlotWithProduction = _beginSwapSlotWithProduction;
    this._beginCreateOrUpdateSourceControl = _beginCreateOrUpdateSourceControl;
    this._listNext = _listNext;
    this._listByResourceGroupNext = _listByResourceGroupNext;
    this._listBackupsNext = _listBackupsNext;
    this._listDeploymentsNext = _listDeploymentsNext;
    this._listDomainOwnershipIdentifiersNext = _listDomainOwnershipIdentifiersNext;
    this._listHostNameBindingsNext = _listHostNameBindingsNext;
    this._listInstanceIdentifiersNext = _listInstanceIdentifiersNext;
    this._listInstanceDeploymentsNext = _listInstanceDeploymentsNext;
    this._listMetricDefinitionsNext = _listMetricDefinitionsNext;
    this._listMetricsNext = _listMetricsNext;
    this._listPerfMonCountersNext = _listPerfMonCountersNext;
    this._listSlotsNext = _listSlotsNext;
    this._listBackupsSlotNext = _listBackupsSlotNext;
    this._listDeploymentsSlotNext = _listDeploymentsSlotNext;
    this._listDomainOwnershipIdentifiersSlotNext = _listDomainOwnershipIdentifiersSlotNext;
    this._listHostNameBindingsSlotNext = _listHostNameBindingsSlotNext;
    this._listInstanceIdentifiersSlotNext = _listInstanceIdentifiersSlotNext;
    this._listInstanceDeploymentsSlotNext = _listInstanceDeploymentsSlotNext;
    this._listMetricDefinitionsSlotNext = _listMetricDefinitionsSlotNext;
    this._listMetricsSlotNext = _listMetricsSlotNext;
    this._listPerfMonCountersSlotNext = _listPerfMonCountersSlotNext;
    this._listSlotDifferencesSlotNext = _listSlotDifferencesSlotNext;
    this._listSnapshotsSlotNext = _listSnapshotsSlotNext;
    this._listUsagesSlotNext = _listUsagesSlotNext;
    this._listSlotDifferencesFromProductionNext = _listSlotDifferencesFromProductionNext;
    this._listSnapshotsNext = _listSnapshotsNext;
    this._listUsagesNext = _listUsagesNext;
  }

  /**
   * @summary Get all apps for a subscription.
   *
   * Get all apps for a subscription.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listWithHttpOperationResponse(options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._list(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get all apps for a subscription.
   *
   * Get all apps for a subscription.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  list(options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._list(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._list(options, optionalCallback);
    }
  }

  /**
   * @summary Gets all web, mobile, and API apps in the specified resource group.
   *
   * Gets all web, mobile, and API apps in the specified resource group.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeSlots] Specify &lt;strong>true&lt;/strong> to
   * include deployment slots in results. The default is false, which only gives
   * you the production slot of all apps.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listByResourceGroupWithHttpOperationResponse(resourceGroupName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listByResourceGroup(resourceGroupName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all web, mobile, and API apps in the specified resource group.
   *
   * Gets all web, mobile, and API apps in the specified resource group.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeSlots] Specify &lt;strong>true&lt;/strong> to
   * include deployment slots in results. The default is false, which only gives
   * you the production slot of all apps.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listByResourceGroup(resourceGroupName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listByResourceGroup(resourceGroupName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listByResourceGroup(resourceGroupName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the details of a web, mobile, or API app.
   *
   * Gets the details of a web, mobile, or API app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._get(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the details of a web, mobile, or API app.
   *
   * Gets the details of a web, mobile, or API app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  get(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._get(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._get(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
   * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
   * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
   * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
   * default is &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
   * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is &lt;code>true&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
   * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
   * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
   * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * &lt;code>true&lt;/code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateWithHttpOperationResponse(resourceGroupName, name, siteEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdate(resourceGroupName, name, siteEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
   * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
   * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
   * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
   * default is &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
   * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is &lt;code>true&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
   * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
   * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
   * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * &lt;code>true&lt;/code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdate(resourceGroupName, name, siteEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdate(resourceGroupName, name, siteEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdate(resourceGroupName, name, siteEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
   * deleted
   *
   * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
   * Service plan will be empty after app deletion and you want to delete the
   * empty App Service plan. By default, the empty App Service plan is not
   * deleted.
   *
   * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
   * skipped
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMethodWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMethod(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
   * deleted
   *
   * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
   * Service plan will be empty after app deletion and you want to delete the
   * empty App Service plan. By default, the empty App Service plan is not
   * deleted.
   *
   * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
   * skipped
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMethod(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMethod(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMethod(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Analyze a custom hostname.
   *
   * Analyze a custom hostname.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.hostName] Custom hostname
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;CustomHostnameAnalysisResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  analyzeCustomHostnameWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._analyzeCustomHostname(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Analyze a custom hostname.
   *
   * Analyze a custom hostname.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.hostName] Custom hostname
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CustomHostnameAnalysisResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CustomHostnameAnalysisResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  analyzeCustomHostname(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._analyzeCustomHostname(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._analyzeCustomHostname(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Applies the configuration settings from the target slot onto the
   * current slot.
   *
   * Applies the configuration settings from the target slot onto the current
   * slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  applySlotConfigToProductionWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Applies the configuration settings from the target slot onto the
   * current slot.
   *
   * Applies the configuration settings from the target slot onto the current
   * slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a backup of an app.
   *
   * Creates a backup of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Backup configuration. You can use the JSON response
   * from the POST action as input here.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  backupWithHttpOperationResponse(resourceGroupName, name, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._backup(resourceGroupName, name, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a backup of an app.
   *
   * Creates a backup of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Backup configuration. You can use the JSON response
   * from the POST action as input here.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  backup(resourceGroupName, name, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._backup(resourceGroupName, name, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._backup(resourceGroupName, name, request, options, optionalCallback);
    }
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupItemCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackups(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItemCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItemCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackups(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackups(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackups(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Discovers an existing app backup that can be restored from a blob
   * in Azure storage.
   *
   * Discovers an existing app backup that can be restored from a blob in Azure
   * storage.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request A RestoreRequest object that includes Azure storage
   * URL and blog name for discovery of backup.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RestoreRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  discoverRestoreWithHttpOperationResponse(resourceGroupName, name, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._discoverRestore(resourceGroupName, name, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Discovers an existing app backup that can be restored from a blob
   * in Azure storage.
   *
   * Discovers an existing app backup that can be restored from a blob in Azure
   * storage.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request A RestoreRequest object that includes Azure storage
   * URL and blog name for discovery of backup.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  discoverRestore(resourceGroupName, name, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._discoverRestore(resourceGroupName, name, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._discoverRestore(resourceGroupName, name, request, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a backup of an app by its ID.
   *
   * Gets a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupStatusWithHttpOperationResponse(resourceGroupName, name, backupId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupStatus(resourceGroupName, name, backupId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a backup of an app by its ID.
   *
   * Gets a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupStatus(resourceGroupName, name, backupId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupStatus(resourceGroupName, name, backupId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupStatus(resourceGroupName, name, backupId, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a backup of an app by its ID.
   *
   * Deletes a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteBackupWithHttpOperationResponse(resourceGroupName, name, backupId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteBackup(resourceGroupName, name, backupId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a backup of an app by its ID.
   *
   * Deletes a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteBackup(resourceGroupName, name, backupId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteBackup(resourceGroupName, name, backupId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteBackup(resourceGroupName, name, backupId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets status of a web app backup that may be in progress, including
   * secrets associated with the backup, such as the Azure Storage SAS URL. Also
   * can be used to update the SAS URL for the backup if a new URL is passed in
   * the request body.
   *
   * Gets status of a web app backup that may be in progress, including secrets
   * associated with the backup, such as the Azure Storage SAS URL. Also can be
   * used to update the SAS URL for the backup if a new URL is passed in the
   * request body.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} backupId Id of backup
   *
   * @param {object} request Information on backup request
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupStatusSecretsWithHttpOperationResponse(resourceGroupName, name, backupId, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackupStatusSecrets(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets status of a web app backup that may be in progress, including
   * secrets associated with the backup, such as the Azure Storage SAS URL. Also
   * can be used to update the SAS URL for the backup if a new URL is passed in
   * the request body.
   *
   * Gets status of a web app backup that may be in progress, including secrets
   * associated with the backup, such as the Azure Storage SAS URL. Also can be
   * used to update the SAS URL for the backup if a new URL is passed in the
   * request body.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} backupId Id of backup
   *
   * @param {object} request Information on backup request
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackupStatusSecrets(resourceGroupName, name, backupId, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackupStatusSecrets(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackupStatusSecrets(resourceGroupName, name, backupId, request, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RestoreResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restoreWithHttpOperationResponse(resourceGroupName, name, backupId, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restore(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restore(resourceGroupName, name, backupId, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restore(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restore(resourceGroupName, name, backupId, request, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the application settings of an app.
   *
   * Replaces the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} appSettings Application settings of the app.
   *
   * @param {object} [appSettings.properties] Settings.
   *
   * @param {string} [appSettings.name] Resource Name.
   *
   * @param {string} [appSettings.kind] Kind of resource.
   *
   * @param {string} appSettings.location Resource Location.
   *
   * @param {string} [appSettings.type] Resource type.
   *
   * @param {object} [appSettings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateApplicationSettingsWithHttpOperationResponse(resourceGroupName, name, appSettings, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateApplicationSettings(resourceGroupName, name, appSettings, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the application settings of an app.
   *
   * Replaces the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} appSettings Application settings of the app.
   *
   * @param {object} [appSettings.properties] Settings.
   *
   * @param {string} [appSettings.name] Resource Name.
   *
   * @param {string} [appSettings.kind] Kind of resource.
   *
   * @param {string} appSettings.location Resource Location.
   *
   * @param {string} [appSettings.type] Resource type.
   *
   * @param {object} [appSettings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateApplicationSettings(resourceGroupName, name, appSettings, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateApplicationSettings(resourceGroupName, name, appSettings, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateApplicationSettings(resourceGroupName, name, appSettings, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the application settings of an app.
   *
   * Gets the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listApplicationSettingsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listApplicationSettings(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the application settings of an app.
   *
   * Gets the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listApplicationSettings(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listApplicationSettings(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listApplicationSettings(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the Authentication / Authorization settings associated with
   * web app.
   *
   * Updates the Authentication / Authorization settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} siteAuthSettings Auth settings associated with web app
   *
   * @param {boolean} [siteAuthSettings.enabled] &lt;code>true&lt;/code> if the
   * Authentication / Authorization feature is enabled for the current app;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
   * Authentication / Authorization feature in use for the current app.
   * The setting in this value can control the behavior of certain features in
   * the Authentication / Authorization module.
   *
   * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
   * take when an unauthenticated client attempts to access the app. Possible
   * values include: 'RedirectToLoginPage', 'AllowAnonymous'
   *
   * @param {boolean} [siteAuthSettings.tokenStoreEnabled] &lt;code>true&lt;/code> to
   * durably store platform-specific security tokens that are obtained during
   * login flows; otherwise, &lt;code>false&lt;/code>.
   * The default is &lt;code>false&lt;/code>.
   *
   * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
   * that can be redirected to as part of logging in or logging out of the app.
   * Note that the query string part of the URL is ignored.
   * This is an advanced setting typically only needed by Windows Store
   * application backends.
   * Note that URLs within the current domain are always implicitly allowed.
   *
   * @param {string} [siteAuthSettings.defaultProvider] The default
   * authentication provider to use when multiple providers are configured.
   * This setting is only needed if multiple providers are configured and the
   * unauthenticated client
   * action is set to "RedirectToLoginPage". Possible values include:
   * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
   *
   * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
   * hours after session token expiration that a session token can be used to
   * call the token refresh API. The default is 72 hours.
   *
   * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
   * party application, known as the client_id.
   * This setting is required for enabling OpenID Connection authentication with
   * Azure Active Directory or
   * other 3rd party OpenID Connect providers.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
   * relying party application (in Azure Active Directory, this is also referred
   * to as the Key).
   * This setting is optional. If no client secret is configured, the OpenID
   * Connect implicit auth flow is used to authenticate end users.
   * Otherwise, the OpenID Connect Authorization Code Flow is used to
   * authenticate end users.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
   * represents the entity which issues access tokens for this application.
   * When using Azure Active Directory, this value is the URI of the directory
   * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
   * This URI is a case-sensitive identifier for the token issuer.
   * More information on OpenID Connect Discovery:
   * http://openid.net/specs/openid-connect-discovery-1_0.html
   *
   * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
   * to consider when validating JWTs issued by
   * Azure Active Directory. Note that the &lt;code>ClientID&lt;/code> value is always
   * considered an
   * allowed audience, regardless of this setting.
   *
   * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
   * send to the OpenID Connect authorization endpoint when
   * a user logs in. Each parameter must be in the form "key=value".
   *
   * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
   * ID for the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.googleClientSecret] The client secret
   * associated with the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Google Sign-In authentication.
   * This setting is optional. If not specified, "openid", "profile", and "email"
   * are used as default scopes.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
   * app used for login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
   * Facebook app used for Facebook Login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Facebook Login authentication.
   * This setting is optional.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
   * consumer key of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
   * consumer secret of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
   * client ID that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
   * 2.0 client secret that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
   * scopes that will be requested as part of Microsoft Account authentication.
   * This setting is optional. If not specified, "wl.basic" is used as the
   * default scope.
   * Microsoft Account Scopes and permissions documentation:
   * https://msdn.microsoft.com/en-us/library/dn631845.aspx
   *
   * @param {string} [siteAuthSettings.name] Resource Name.
   *
   * @param {string} [siteAuthSettings.kind] Kind of resource.
   *
   * @param {string} siteAuthSettings.location Resource Location.
   *
   * @param {string} [siteAuthSettings.type] Resource type.
   *
   * @param {object} [siteAuthSettings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteAuthSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateAuthSettingsWithHttpOperationResponse(resourceGroupName, name, siteAuthSettings, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateAuthSettings(resourceGroupName, name, siteAuthSettings, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the Authentication / Authorization settings associated with
   * web app.
   *
   * Updates the Authentication / Authorization settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} siteAuthSettings Auth settings associated with web app
   *
   * @param {boolean} [siteAuthSettings.enabled] &lt;code>true&lt;/code> if the
   * Authentication / Authorization feature is enabled for the current app;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
   * Authentication / Authorization feature in use for the current app.
   * The setting in this value can control the behavior of certain features in
   * the Authentication / Authorization module.
   *
   * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
   * take when an unauthenticated client attempts to access the app. Possible
   * values include: 'RedirectToLoginPage', 'AllowAnonymous'
   *
   * @param {boolean} [siteAuthSettings.tokenStoreEnabled] &lt;code>true&lt;/code> to
   * durably store platform-specific security tokens that are obtained during
   * login flows; otherwise, &lt;code>false&lt;/code>.
   * The default is &lt;code>false&lt;/code>.
   *
   * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
   * that can be redirected to as part of logging in or logging out of the app.
   * Note that the query string part of the URL is ignored.
   * This is an advanced setting typically only needed by Windows Store
   * application backends.
   * Note that URLs within the current domain are always implicitly allowed.
   *
   * @param {string} [siteAuthSettings.defaultProvider] The default
   * authentication provider to use when multiple providers are configured.
   * This setting is only needed if multiple providers are configured and the
   * unauthenticated client
   * action is set to "RedirectToLoginPage". Possible values include:
   * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
   *
   * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
   * hours after session token expiration that a session token can be used to
   * call the token refresh API. The default is 72 hours.
   *
   * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
   * party application, known as the client_id.
   * This setting is required for enabling OpenID Connection authentication with
   * Azure Active Directory or
   * other 3rd party OpenID Connect providers.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
   * relying party application (in Azure Active Directory, this is also referred
   * to as the Key).
   * This setting is optional. If no client secret is configured, the OpenID
   * Connect implicit auth flow is used to authenticate end users.
   * Otherwise, the OpenID Connect Authorization Code Flow is used to
   * authenticate end users.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
   * represents the entity which issues access tokens for this application.
   * When using Azure Active Directory, this value is the URI of the directory
   * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
   * This URI is a case-sensitive identifier for the token issuer.
   * More information on OpenID Connect Discovery:
   * http://openid.net/specs/openid-connect-discovery-1_0.html
   *
   * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
   * to consider when validating JWTs issued by
   * Azure Active Directory. Note that the &lt;code>ClientID&lt;/code> value is always
   * considered an
   * allowed audience, regardless of this setting.
   *
   * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
   * send to the OpenID Connect authorization endpoint when
   * a user logs in. Each parameter must be in the form "key=value".
   *
   * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
   * ID for the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.googleClientSecret] The client secret
   * associated with the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Google Sign-In authentication.
   * This setting is optional. If not specified, "openid", "profile", and "email"
   * are used as default scopes.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
   * app used for login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
   * Facebook app used for Facebook Login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Facebook Login authentication.
   * This setting is optional.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
   * consumer key of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
   * consumer secret of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
   * client ID that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
   * 2.0 client secret that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
   * scopes that will be requested as part of Microsoft Account authentication.
   * This setting is optional. If not specified, "wl.basic" is used as the
   * default scope.
   * Microsoft Account Scopes and permissions documentation:
   * https://msdn.microsoft.com/en-us/library/dn631845.aspx
   *
   * @param {string} [siteAuthSettings.name] Resource Name.
   *
   * @param {string} [siteAuthSettings.kind] Kind of resource.
   *
   * @param {string} siteAuthSettings.location Resource Location.
   *
   * @param {string} [siteAuthSettings.type] Resource type.
   *
   * @param {object} [siteAuthSettings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteAuthSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteAuthSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAuthSettings(resourceGroupName, name, siteAuthSettings, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateAuthSettings(resourceGroupName, name, siteAuthSettings, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateAuthSettings(resourceGroupName, name, siteAuthSettings, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Authentication/Authorization settings of an app.
   *
   * Gets the Authentication/Authorization settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteAuthSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAuthSettingsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAuthSettings(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Authentication/Authorization settings of an app.
   *
   * Gets the Authentication/Authorization settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteAuthSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteAuthSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAuthSettings(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAuthSettings(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAuthSettings(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the backup configuration of an app.
   *
   * Updates the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Edited backup configuration.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateBackupConfigurationWithHttpOperationResponse(resourceGroupName, name, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateBackupConfiguration(resourceGroupName, name, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the backup configuration of an app.
   *
   * Updates the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Edited backup configuration.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateBackupConfiguration(resourceGroupName, name, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateBackupConfiguration(resourceGroupName, name, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateBackupConfiguration(resourceGroupName, name, request, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the backup configuration of an app.
   *
   * Deletes the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteBackupConfigurationWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteBackupConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the backup configuration of an app.
   *
   * Deletes the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteBackupConfiguration(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteBackupConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteBackupConfiguration(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the backup configuration of an app.
   *
   * Gets the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupConfigurationWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the backup configuration of an app.
   *
   * Gets the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupConfiguration(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupConfiguration(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the connection strings of an app.
   *
   * Replaces the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} connectionStrings Connection strings of the app or
   * deployment slot. See example.
   *
   * @param {object} [connectionStrings.properties] Connection strings.
   *
   * @param {string} [connectionStrings.name] Resource Name.
   *
   * @param {string} [connectionStrings.kind] Kind of resource.
   *
   * @param {string} connectionStrings.location Resource Location.
   *
   * @param {string} [connectionStrings.type] Resource type.
   *
   * @param {object} [connectionStrings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ConnectionStringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateConnectionStringsWithHttpOperationResponse(resourceGroupName, name, connectionStrings, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateConnectionStrings(resourceGroupName, name, connectionStrings, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the connection strings of an app.
   *
   * Replaces the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} connectionStrings Connection strings of the app or
   * deployment slot. See example.
   *
   * @param {object} [connectionStrings.properties] Connection strings.
   *
   * @param {string} [connectionStrings.name] Resource Name.
   *
   * @param {string} [connectionStrings.kind] Kind of resource.
   *
   * @param {string} connectionStrings.location Resource Location.
   *
   * @param {string} [connectionStrings.type] Resource type.
   *
   * @param {object} [connectionStrings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ConnectionStringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ConnectionStringDictionary} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateConnectionStrings(resourceGroupName, name, connectionStrings, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateConnectionStrings(resourceGroupName, name, connectionStrings, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateConnectionStrings(resourceGroupName, name, connectionStrings, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the connection strings of an app.
   *
   * Gets the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ConnectionStringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listConnectionStringsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listConnectionStrings(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the connection strings of an app.
   *
   * Gets the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ConnectionStringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ConnectionStringDictionary} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listConnectionStrings(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listConnectionStrings(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listConnectionStrings(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the logging configuration of an app.
   *
   * Gets the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteLogsConfig>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDiagnosticLogsConfigurationWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDiagnosticLogsConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the logging configuration of an app.
   *
   * Gets the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteLogsConfig} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteLogsConfig} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDiagnosticLogsConfiguration(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDiagnosticLogsConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDiagnosticLogsConfiguration(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the logging configuration of an app.
   *
   * Updates the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
   * the logging configuration to change in the "properties" property.
   *
   * @param {object} [siteLogsConfig.applicationLogs] Application logs
   * configuration.
   *
   * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
   * to file system configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
   * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
   * Application logs to azure table storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
   * URL to an Azure table with add/query/delete permissions.
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
   * Application logs to blob storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
   * url to a azure blob container with read/write/list/delete permissions.
   *
   * @param {number}
   * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
   * in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
   *
   * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
   * system configuration.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
   * size in megabytes that http log files can use.
   * When reached old log files will be removed to make space for new ones.
   * Value can range between 25 and 100.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
   * Retention in days.
   * Remove files older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
   * azure blob storage configuration.
   *
   * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
   * a azure blob container with read/write/list/delete permissions.
   *
   * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
   * Retention in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
   * tracing configuration.
   *
   * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
   * messages configuration.
   *
   * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
   *
   * @param {string} [siteLogsConfig.name] Resource Name.
   *
   * @param {string} [siteLogsConfig.kind] Kind of resource.
   *
   * @param {string} siteLogsConfig.location Resource Location.
   *
   * @param {string} [siteLogsConfig.type] Resource type.
   *
   * @param {object} [siteLogsConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteLogsConfig>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateDiagnosticLogsConfigWithHttpOperationResponse(resourceGroupName, name, siteLogsConfig, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the logging configuration of an app.
   *
   * Updates the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
   * the logging configuration to change in the "properties" property.
   *
   * @param {object} [siteLogsConfig.applicationLogs] Application logs
   * configuration.
   *
   * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
   * to file system configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
   * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
   * Application logs to azure table storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
   * URL to an Azure table with add/query/delete permissions.
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
   * Application logs to blob storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
   * url to a azure blob container with read/write/list/delete permissions.
   *
   * @param {number}
   * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
   * in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
   *
   * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
   * system configuration.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
   * size in megabytes that http log files can use.
   * When reached old log files will be removed to make space for new ones.
   * Value can range between 25 and 100.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
   * Retention in days.
   * Remove files older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
   * azure blob storage configuration.
   *
   * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
   * a azure blob container with read/write/list/delete permissions.
   *
   * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
   * Retention in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
   * tracing configuration.
   *
   * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
   * messages configuration.
   *
   * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
   *
   * @param {string} [siteLogsConfig.name] Resource Name.
   *
   * @param {string} [siteLogsConfig.kind] Kind of resource.
   *
   * @param {string} siteLogsConfig.location Resource Location.
   *
   * @param {string} [siteLogsConfig.type] Resource type.
   *
   * @param {object} [siteLogsConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteLogsConfig} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteLogsConfig} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the metadata of an app.
   *
   * Replaces the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} metadata Edited metadata of the app or deployment slot. See
   * example.
   *
   * @param {object} [metadata.properties] Settings.
   *
   * @param {string} [metadata.name] Resource Name.
   *
   * @param {string} [metadata.kind] Kind of resource.
   *
   * @param {string} metadata.location Resource Location.
   *
   * @param {string} [metadata.type] Resource type.
   *
   * @param {object} [metadata.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateMetadataWithHttpOperationResponse(resourceGroupName, name, metadata, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateMetadata(resourceGroupName, name, metadata, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the metadata of an app.
   *
   * Replaces the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} metadata Edited metadata of the app or deployment slot. See
   * example.
   *
   * @param {object} [metadata.properties] Settings.
   *
   * @param {string} [metadata.name] Resource Name.
   *
   * @param {string} [metadata.kind] Kind of resource.
   *
   * @param {string} metadata.location Resource Location.
   *
   * @param {string} [metadata.type] Resource type.
   *
   * @param {object} [metadata.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateMetadata(resourceGroupName, name, metadata, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateMetadata(resourceGroupName, name, metadata, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateMetadata(resourceGroupName, name, metadata, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the metadata of an app.
   *
   * Gets the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetadataWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetadata(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the metadata of an app.
   *
   * Gets the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetadata(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetadata(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetadata(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;User>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPublishingCredentialsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPublishingCredentials(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {User} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link User} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPublishingCredentials(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPublishingCredentials(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPublishingCredentials(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the Push settings associated with web app.
   *
   * Updates the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} pushSettings Push settings associated with web app
   *
   * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
   * whether the Push endpoint is enabled.
   *
   * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
   * containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
   * containing a list of tags that require user authentication to be used in the
   * push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PushSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateSitePushSettingsWithHttpOperationResponse(resourceGroupName, name, pushSettings, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateSitePushSettings(resourceGroupName, name, pushSettings, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the Push settings associated with web app.
   *
   * Updates the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} pushSettings Push settings associated with web app
   *
   * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
   * whether the Push endpoint is enabled.
   *
   * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
   * containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
   * containing a list of tags that require user authentication to be used in the
   * push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PushSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PushSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSitePushSettings(resourceGroupName, name, pushSettings, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateSitePushSettings(resourceGroupName, name, pushSettings, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateSitePushSettings(resourceGroupName, name, pushSettings, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Push settings associated with web app.
   *
   * Gets the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PushSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSitePushSettingsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSitePushSettings(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Push settings associated with web app.
   *
   * Gets the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PushSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PushSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSitePushSettings(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSitePushSettings(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSitePushSettings(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the names of app settings and connection strings that stick to
   * the slot (not swapped).
   *
   * Gets the names of app settings and connection strings that stick to the slot
   * (not swapped).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SlotConfigNamesResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotConfigurationNamesWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotConfigurationNames(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the names of app settings and connection strings that stick to
   * the slot (not swapped).
   *
   * Gets the names of app settings and connection strings that stick to the slot
   * (not swapped).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotConfigNamesResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotConfigNamesResource} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotConfigurationNames(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotConfigurationNames(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotConfigurationNames(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the names of application settings and connection string
   * that remain with the slot during swap operation.
   *
   * Updates the names of application settings and connection string that remain
   * with the slot during swap operation.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotConfigNames Names of application settings and connection
   * strings. See example.
   *
   * @param {array} [slotConfigNames.connectionStringNames] List of connection
   * string names.
   *
   * @param {array} [slotConfigNames.appSettingNames] List of application
   * settings names.
   *
   * @param {string} [slotConfigNames.name] Resource Name.
   *
   * @param {string} [slotConfigNames.kind] Kind of resource.
   *
   * @param {string} slotConfigNames.location Resource Location.
   *
   * @param {string} [slotConfigNames.type] Resource type.
   *
   * @param {object} [slotConfigNames.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SlotConfigNamesResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateSlotConfigurationNamesWithHttpOperationResponse(resourceGroupName, name, slotConfigNames, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the names of application settings and connection string
   * that remain with the slot during swap operation.
   *
   * Updates the names of application settings and connection string that remain
   * with the slot during swap operation.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotConfigNames Names of application settings and connection
   * strings. See example.
   *
   * @param {array} [slotConfigNames.connectionStringNames] List of connection
   * string names.
   *
   * @param {array} [slotConfigNames.appSettingNames] List of application
   * settings names.
   *
   * @param {string} [slotConfigNames.name] Resource Name.
   *
   * @param {string} [slotConfigNames.kind] Kind of resource.
   *
   * @param {string} slotConfigNames.location Resource Location.
   *
   * @param {string} [slotConfigNames.type] Resource type.
   *
   * @param {object} [slotConfigNames.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotConfigNamesResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotConfigNamesResource} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the configuration of an app, such as platform version and
   * bitness, default documents, virtual applications, Always On, etc.
   *
   * Gets the configuration of an app, such as platform version and bitness,
   * default documents, virtual applications, Always On, etc.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getConfigurationWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the configuration of an app, such as platform version and
   * bitness, default documents, virtual applications, Always On, etc.
   *
   * Gets the configuration of an app, such as platform version and bitness,
   * default documents, virtual applications, Always On, etc.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getConfiguration(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getConfiguration(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
   * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
   * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
   * logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
   * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
   * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
   * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
   * enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
   * is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
   * local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateConfigurationWithHttpOperationResponse(resourceGroupName, name, siteConfig, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
   * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
   * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
   * logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
   * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
   * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
   * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
   * enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
   * is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
   * local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
   * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
   * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
   * logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
   * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
   * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
   * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
   * enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
   * is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
   * local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateConfigurationWithHttpOperationResponse(resourceGroupName, name, siteConfig, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateConfiguration(resourceGroupName, name, siteConfig, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
   * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
   * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
   * logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
   * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
   * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
   * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
   * enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
   * is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
   * local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateConfiguration(resourceGroupName, name, siteConfig, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateConfiguration(resourceGroupName, name, siteConfig, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateConfiguration(resourceGroupName, name, siteConfig, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of web app configuration snapshots identifiers. Each
   * element of the list contains a timestamp and the ID of the snapshot.
   *
   * Gets a list of web app configuration snapshots identifiers. Each element of
   * the list contains a timestamp and the ID of the snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listConfigurationSnapshotInfoWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listConfigurationSnapshotInfo(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of web app configuration snapshots identifiers. Each
   * element of the list contains a timestamp and the ID of the snapshot.
   *
   * Gets a list of web app configuration snapshots identifiers. Each element of
   * the list contains a timestamp and the ID of the snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listConfigurationSnapshotInfo(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listConfigurationSnapshotInfo(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listConfigurationSnapshotInfo(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a snapshot of the configuration of an app at a previous point
   * in time.
   *
   * Gets a snapshot of the configuration of an app at a previous point in time.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getConfigurationSnapshotWithHttpOperationResponse(resourceGroupName, name, snapshotId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getConfigurationSnapshot(resourceGroupName, name, snapshotId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a snapshot of the configuration of an app at a previous point
   * in time.
   *
   * Gets a snapshot of the configuration of an app at a previous point in time.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getConfigurationSnapshot(resourceGroupName, name, snapshotId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getConfigurationSnapshot(resourceGroupName, name, snapshotId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getConfigurationSnapshot(resourceGroupName, name, snapshotId, options, optionalCallback);
    }
  }

  /**
   * @summary Reverts the configuration of an app to a previous snapshot.
   *
   * Reverts the configuration of an app to a previous snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverSiteConfigurationSnapshotWithHttpOperationResponse(resourceGroupName, name, snapshotId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Reverts the configuration of an app to a previous snapshot.
   *
   * Reverts the configuration of an app to a previous snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDeploymentsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDeployments(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDeployments(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDeployments(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDeployments(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeploymentWithHttpOperationResponse(resourceGroupName, name, id, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployment(resourceGroupName, name, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployment(resourceGroupName, name, id, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployment(resourceGroupName, name, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployment(resourceGroupName, name, id, options, optionalCallback);
    }
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createDeploymentWithHttpOperationResponse(resourceGroupName, name, id, deployment, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createDeployment(resourceGroupName, name, id, deployment, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createDeployment(resourceGroupName, name, id, deployment, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createDeployment(resourceGroupName, name, id, deployment, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createDeployment(resourceGroupName, name, id, deployment, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDeploymentWithHttpOperationResponse(resourceGroupName, name, id, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDeployment(resourceGroupName, name, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDeployment(resourceGroupName, name, id, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDeployment(resourceGroupName, name, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDeployment(resourceGroupName, name, id, options, optionalCallback);
    }
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;IdentifierCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDomainOwnershipIdentifiersWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDomainOwnershipIdentifiers(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IdentifierCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IdentifierCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDomainOwnershipIdentifiers(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDomainOwnershipIdentifiers(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDomainOwnershipIdentifiers(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Get domain ownership identifier for web app.
   *
   * Get domain ownership identifier for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDomainOwnershipIdentifierWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get domain ownership identifier for web app.
   *
   * Get domain ownership identifier for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateDomainOwnershipIdentifierWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a domain ownership identifier for a web app.
   *
   * Deletes a domain ownership identifier for a web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDomainOwnershipIdentifierWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a domain ownership identifier for a web app.
   *
   * Deletes a domain ownership identifier for a web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateDomainOwnershipIdentifierWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, optionalCallback);
    }
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HostNameBindingCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHostNameBindingsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHostNameBindings(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBindingCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBindingCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHostNameBindings(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHostNameBindings(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHostNameBindings(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HostNameBinding>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getHostNameBindingWithHttpOperationResponse(resourceGroupName, name, hostName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getHostNameBinding(resourceGroupName, name, hostName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBinding} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBinding} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getHostNameBinding(resourceGroupName, name, hostName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getHostNameBinding(resourceGroupName, name, hostName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getHostNameBinding(resourceGroupName, name, hostName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a hostname binding for an app.
   *
   * Creates a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} hostNameBinding Binding details. This is the JSON
   * representation of a HostNameBinding object.
   *
   * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
   *
   * @param {string} [hostNameBinding.siteName] App Service app name.
   *
   * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
   * resource URI.
   *
   * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
   *
   * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
   * Possible values include: 'Website', 'TrafficManager'
   *
   * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
   * record type. Possible values include: 'CName', 'A'
   *
   * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
   * values include: 'Verified', 'Managed'
   *
   * @param {string} [hostNameBinding.sslState] SSL type. Possible values
   * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
   *
   * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
   *
   * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
   * the hostname if IP based SSL is enabled.
   *
   * @param {string} [hostNameBinding.name] Resource Name.
   *
   * @param {string} [hostNameBinding.kind] Kind of resource.
   *
   * @param {string} hostNameBinding.location Resource Location.
   *
   * @param {string} [hostNameBinding.type] Resource type.
   *
   * @param {object} [hostNameBinding.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HostNameBinding>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateHostNameBindingWithHttpOperationResponse(resourceGroupName, name, hostName, hostNameBinding, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a hostname binding for an app.
   *
   * Creates a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} hostNameBinding Binding details. This is the JSON
   * representation of a HostNameBinding object.
   *
   * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
   *
   * @param {string} [hostNameBinding.siteName] App Service app name.
   *
   * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
   * resource URI.
   *
   * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
   *
   * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
   * Possible values include: 'Website', 'TrafficManager'
   *
   * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
   * record type. Possible values include: 'CName', 'A'
   *
   * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
   * values include: 'Verified', 'Managed'
   *
   * @param {string} [hostNameBinding.sslState] SSL type. Possible values
   * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
   *
   * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
   *
   * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
   * the hostname if IP based SSL is enabled.
   *
   * @param {string} [hostNameBinding.name] Resource Name.
   *
   * @param {string} [hostNameBinding.kind] Kind of resource.
   *
   * @param {string} hostNameBinding.location Resource Location.
   *
   * @param {string} [hostNameBinding.type] Resource type.
   *
   * @param {object} [hostNameBinding.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBinding} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBinding} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a hostname binding for an app.
   *
   * Deletes a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteHostNameBindingWithHttpOperationResponse(resourceGroupName, name, hostName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteHostNameBinding(resourceGroupName, name, hostName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a hostname binding for an app.
   *
   * Deletes a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHostNameBinding(resourceGroupName, name, hostName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteHostNameBinding(resourceGroupName, name, hostName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteHostNameBinding(resourceGroupName, name, hostName, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
   * App.
   *
   * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getHybridConnectionWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getHybridConnection(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
   * App.
   *
   * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getHybridConnection(resourceGroupName, name, namespaceName, relayName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getHybridConnection(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getHybridConnection(resourceGroupName, name, namespaceName, relayName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateHybridConnectionWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Removes a Hybrid Connection from this site.
   *
   * Removes a Hybrid Connection from this site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteHybridConnectionWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Removes a Hybrid Connection from this site.
   *
   * Removes a Hybrid Connection from this site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateHybridConnectionWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the send key name and value for a Hybrid Connection.
   *
   * Gets the send key name and value for a Hybrid Connection.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HybridConnectionKey>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHybridConnectionKeysWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the send key name and value for a Hybrid Connection.
   *
   * Gets the send key name and value for a Hybrid Connection.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnectionKey} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnectionKey} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHybridConnectionsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHybridConnections(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHybridConnections(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHybridConnections(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHybridConnections(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets hybrid connections configured for an app (or deployment slot,
   * if specified).
   *
   * Gets hybrid connections configured for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listRelayServiceConnectionsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listRelayServiceConnections(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets hybrid connections configured for an app (or deployment slot,
   * if specified).
   *
   * Gets hybrid connections configured for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listRelayServiceConnections(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listRelayServiceConnections(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listRelayServiceConnections(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a hybrid connection configuration by its name.
   *
   * Gets a hybrid connection configuration by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getRelayServiceConnectionWithHttpOperationResponse(resourceGroupName, name, entityName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getRelayServiceConnection(resourceGroupName, name, entityName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a hybrid connection configuration by its name.
   *
   * Gets a hybrid connection configuration by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getRelayServiceConnection(resourceGroupName, name, entityName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getRelayServiceConnection(resourceGroupName, name, entityName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getRelayServiceConnection(resourceGroupName, name, entityName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateRelayServiceConnectionWithHttpOperationResponse(resourceGroupName, name, entityName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a relay service connection by its name.
   *
   * Deletes a relay service connection by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteRelayServiceConnectionWithHttpOperationResponse(resourceGroupName, name, entityName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteRelayServiceConnection(resourceGroupName, name, entityName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a relay service connection by its name.
   *
   * Deletes a relay service connection by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteRelayServiceConnection(resourceGroupName, name, entityName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteRelayServiceConnection(resourceGroupName, name, entityName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteRelayServiceConnection(resourceGroupName, name, entityName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateRelayServiceConnectionWithHttpOperationResponse(resourceGroupName, name, entityName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;WebAppInstanceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceIdentifiersWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceIdentifiers(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppInstanceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppInstanceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceIdentifiers(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceIdentifiers(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceIdentifiers(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} instanceId The ID of a specific scaled-out instance. This is
   * the value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceDeploymentsWithHttpOperationResponse(resourceGroupName, name, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceDeployments(resourceGroupName, name, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} instanceId The ID of a specific scaled-out instance. This is
   * the value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceDeployments(resourceGroupName, name, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceDeployments(resourceGroupName, name, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceDeployments(resourceGroupName, name, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getInstanceDeploymentWithHttpOperationResponse(resourceGroupName, name, id, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getInstanceDeployment(resourceGroupName, name, id, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getInstanceDeployment(resourceGroupName, name, id, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getInstanceDeployment(resourceGroupName, name, id, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getInstanceDeployment(resourceGroupName, name, id, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createInstanceDeploymentWithHttpOperationResponse(resourceGroupName, name, id, instanceId, deployment, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createInstanceDeployment(resourceGroupName, name, id, instanceId, deployment, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createInstanceDeployment(resourceGroupName, name, id, instanceId, deployment, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createInstanceDeployment(resourceGroupName, name, id, instanceId, deployment, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createInstanceDeployment(resourceGroupName, name, id, instanceId, deployment, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteInstanceDeploymentWithHttpOperationResponse(resourceGroupName, name, id, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteInstanceDeployment(resourceGroupName, name, id, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteInstanceDeployment(resourceGroupName, name, id, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteInstanceDeployment(resourceGroupName, name, id, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteInstanceDeployment(resourceGroupName, name, id, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteCloneability>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  isCloneableWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._isCloneable(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteCloneability} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteCloneability} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  isCloneable(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._isCloneable(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._isCloneable(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ResourceMetricDefinitionCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricDefinitionsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricDefinitions(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricDefinitionCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricDefinitionCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricDefinitions(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricDefinitions(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricDefinitions(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.details] Specify "true" to include metric details
   * in the response. It is "false" by default.
   *
   * @param {string} [options.filter] Return only metrics specified in the filter
   * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
   * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
   * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ResourceMetricCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetrics(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.details] Specify "true" to include metric details
   * in the response. It is "false" by default.
   *
   * @param {string} [options.filter] Return only metrics specified in the filter
   * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
   * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
   * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetrics(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetrics(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetrics(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a web app.
   *
   * Restores a web app.
   *
   * @param {string} subscriptionName Azure subscription
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationOptions Migration migrationOptions
   *
   * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
   * connection string.
   *
   * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
   *
   * @param {boolean} [migrationOptions.switchSiteAfterMigration]
   * &lt;code>true&lt;/code>if the app should be switched over; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [migrationOptions.blockWriteAccessToSite] &lt;code>true&lt;/code>
   * if the app should be read only during copy operation; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [migrationOptions.name] Resource Name.
   *
   * @param {string} [migrationOptions.kind] Kind of resource.
   *
   * @param {string} migrationOptions.location Resource Location.
   *
   * @param {string} [migrationOptions.type] Resource type.
   *
   * @param {object} [migrationOptions.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;StorageMigrationResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  migrateStorageWithHttpOperationResponse(subscriptionName, resourceGroupName, name, migrationOptions, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._migrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a web app.
   *
   * Restores a web app.
   *
   * @param {string} subscriptionName Azure subscription
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationOptions Migration migrationOptions
   *
   * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
   * connection string.
   *
   * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
   *
   * @param {boolean} [migrationOptions.switchSiteAfterMigration]
   * &lt;code>true&lt;/code>if the app should be switched over; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [migrationOptions.blockWriteAccessToSite] &lt;code>true&lt;/code>
   * if the app should be read only during copy operation; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [migrationOptions.name] Resource Name.
   *
   * @param {string} [migrationOptions.kind] Kind of resource.
   *
   * @param {string} migrationOptions.location Resource Location.
   *
   * @param {string} [migrationOptions.type] Resource type.
   *
   * @param {object} [migrationOptions.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageMigrationResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageMigrationResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  migrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._migrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._migrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, optionalCallback);
    }
  }

  /**
   * @summary Migrates a local (in-app) MySql database to a remote MySql
   * database.
   *
   * Migrates a local (in-app) MySql database to a remote MySql database.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationRequestEnvelope MySql migration options
   *
   * @param {string} [migrationRequestEnvelope.connectionString] Connection
   * string to the remote MySQL database to which data should be migrated.
   *
   * @param {string} [migrationRequestEnvelope.name] Resource Name.
   *
   * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
   *
   * @param {string} migrationRequestEnvelope.location Resource Location.
   *
   * @param {string} [migrationRequestEnvelope.type] Resource type.
   *
   * @param {object} [migrationRequestEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Operation>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  migrateMySqlWithHttpOperationResponse(resourceGroupName, name, migrationRequestEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._migrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Migrates a local (in-app) MySql database to a remote MySql
   * database.
   *
   * Migrates a local (in-app) MySql database to a remote MySql database.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationRequestEnvelope MySql migration options
   *
   * @param {string} [migrationRequestEnvelope.connectionString] Connection
   * string to the remote MySQL database to which data should be migrated.
   *
   * @param {string} [migrationRequestEnvelope.name] Resource Name.
   *
   * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
   *
   * @param {string} migrationRequestEnvelope.location Resource Location.
   *
   * @param {string} [migrationRequestEnvelope.type] Resource type.
   *
   * @param {object} [migrationRequestEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Operation} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Operation} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  migrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._migrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._migrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Returns the status of MySql in app migration, if one is active, and
   * whether or not MySql in app is enabled
   *
   * Returns the status of MySql in app migration, if one is active, and whether
   * or not MySql in app is enabled
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;MigrateMySqlStatus>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getMigrateMySqlStatusWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getMigrateMySqlStatus(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns the status of MySql in app migration, if one is active, and
   * whether or not MySql in app is enabled
   *
   * Returns the status of MySql in app migration, if one is active, and whether
   * or not MySql in app is enabled
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MigrateMySqlStatus} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MigrateMySqlStatus} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getMigrateMySqlStatus(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getMigrateMySqlStatus(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getMigrateMySqlStatus(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} view The type of view. This can either be "summary" or
   * "detailed".
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;NetworkFeatures>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listNetworkFeaturesWithHttpOperationResponse(resourceGroupName, name, view, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listNetworkFeatures(resourceGroupName, name, view, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} view The type of view. This can either be "summary" or
   * "detailed".
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NetworkFeatures} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NetworkFeatures} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listNetworkFeatures(resourceGroupName, name, view, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listNetworkFeatures(resourceGroupName, name, view, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listNetworkFeatures(resourceGroupName, name, view, options, optionalCallback);
    }
  }

  /**
   * @summary Start capturing network packets for the site.
   *
   * Start capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.durationInSeconds] The duration to keep capturing
   * in seconds.
   *
   * @param {number} [options.maxFrameLength] The maximum frame length in bytes
   * (Optional).
   *
   * @param {string} [options.sasUrl] The Blob URL to store capture file.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startWebSiteNetworkTraceWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startWebSiteNetworkTrace(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Start capturing network packets for the site.
   *
   * Start capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.durationInSeconds] The duration to keep capturing
   * in seconds.
   *
   * @param {number} [options.maxFrameLength] The maximum frame length in bytes
   * (Optional).
   *
   * @param {string} [options.sasUrl] The Blob URL to store capture file.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startWebSiteNetworkTrace(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startWebSiteNetworkTrace(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startWebSiteNetworkTrace(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Stop ongoing capturing network packets for the site.
   *
   * Stop ongoing capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopWebSiteNetworkTraceWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stopWebSiteNetworkTrace(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stop ongoing capturing network packets for the site.
   *
   * Stop ongoing capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stopWebSiteNetworkTrace(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stopWebSiteNetworkTrace(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stopWebSiteNetworkTrace(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Generates a new publishing password for an app (or deployment slot,
   * if specified).
   *
   * Generates a new publishing password for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  generateNewSitePublishingPasswordWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._generateNewSitePublishingPassword(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Generates a new publishing password for an app (or deployment slot,
   * if specified).
   *
   * Generates a new publishing password for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  generateNewSitePublishingPassword(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._generateNewSitePublishingPassword(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._generateNewSitePublishingPassword(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only usages/metrics specified in the
   * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
   * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
   * eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PerfMonCounterCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPerfMonCountersWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPerfMonCounters(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only usages/metrics specified in the
   * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
   * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
   * eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PerfMonCounterCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PerfMonCounterCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPerfMonCounters(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPerfMonCounters(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPerfMonCounters(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets web app's event logs.
   *
   * Gets web app's event logs.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SitePhpErrorLogFlag>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSitePhpErrorLogFlagWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSitePhpErrorLogFlag(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets web app's event logs.
   *
   * Gets web app's event logs.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SitePhpErrorLogFlag} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SitePhpErrorLogFlag} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSitePhpErrorLogFlag(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSitePhpErrorLogFlag(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSitePhpErrorLogFlag(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the premier add-ons of an app.
   *
   * Gets the premier add-ons of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPremierAddOnsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPremierAddOns(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the premier add-ons of an app.
   *
   * Gets the premier add-ons of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPremierAddOns(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPremierAddOns(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPremierAddOns(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a named add-on of an app.
   *
   * Gets a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPremierAddOnWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPremierAddOn(resourceGroupName, name, premierAddOnName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a named add-on of an app.
   *
   * Gets a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPremierAddOn(resourceGroupName, name, premierAddOnName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPremierAddOn(resourceGroupName, name, premierAddOnName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPremierAddOn(resourceGroupName, name, premierAddOnName, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a named add-on of an app.
   *
   * Updates a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} premierAddOn A JSON representation of the edited premier
   * add-on.
   *
   * @param {string} [premierAddOn.sku] SKU.
   *
   * @param {string} [premierAddOn.product] Product.
   *
   * @param {string} [premierAddOn.vendor] Vendor.
   *
   * @param {string} [premierAddOn.premierAddOnName] Name.
   *
   * @param {string} [premierAddOn.premierAddOnLocation] Location.
   *
   * @param {object} [premierAddOn.premierAddOnTags] Tags.
   *
   * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
   *
   * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
   *
   * @param {string} [premierAddOn.name] Resource Name.
   *
   * @param {string} [premierAddOn.kind] Kind of resource.
   *
   * @param {string} premierAddOn.location Resource Location.
   *
   * @param {string} [premierAddOn.type] Resource type.
   *
   * @param {object} [premierAddOn.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addPremierAddOnWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, premierAddOn, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a named add-on of an app.
   *
   * Updates a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} premierAddOn A JSON representation of the edited premier
   * add-on.
   *
   * @param {string} [premierAddOn.sku] SKU.
   *
   * @param {string} [premierAddOn.product] Product.
   *
   * @param {string} [premierAddOn.vendor] Vendor.
   *
   * @param {string} [premierAddOn.premierAddOnName] Name.
   *
   * @param {string} [premierAddOn.premierAddOnLocation] Location.
   *
   * @param {object} [premierAddOn.premierAddOnTags] Tags.
   *
   * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
   *
   * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
   *
   * @param {string} [premierAddOn.name] Resource Name.
   *
   * @param {string} [premierAddOn.kind] Kind of resource.
   *
   * @param {string} premierAddOn.location Resource Location.
   *
   * @param {string} [premierAddOn.type] Resource type.
   *
   * @param {object} [premierAddOn.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a premier add-on from an app.
   *
   * Delete a premier add-on from an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deletePremierAddOnWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deletePremierAddOn(resourceGroupName, name, premierAddOnName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a premier add-on from an app.
   *
   * Delete a premier add-on from an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deletePremierAddOn(resourceGroupName, name, premierAddOnName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deletePremierAddOn(resourceGroupName, name, premierAddOnName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deletePremierAddOn(resourceGroupName, name, premierAddOnName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the publishing profile for an app (or deployment slot, if
   * specified).
   *
   * Gets the publishing profile for an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.format] Name of the format. Valid values are:
   * FileZilla3
   * WebDeploy -- default
   * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPublishingProfileXmlWithSecretsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPublishingProfileXmlWithSecrets(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the publishing profile for an app (or deployment slot, if
   * specified).
   *
   * Gets the publishing profile for an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.format] Name of the format. Valid values are:
   * FileZilla3
   * WebDeploy -- default
   * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPublishingProfileXmlWithSecrets(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPublishingProfileXmlWithSecrets(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPublishingProfileXmlWithSecrets(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RecoverResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverWithHttpOperationResponse(resourceGroupName, name, recoveryEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recover(resourceGroupName, name, recoveryEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RecoverResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RecoverResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recover(resourceGroupName, name, recoveryEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recover(resourceGroupName, name, recoveryEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recover(resourceGroupName, name, recoveryEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resetProductionSlotConfigWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resetProductionSlotConfig(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resetProductionSlotConfig(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resetProductionSlotConfig(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resetProductionSlotConfig(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Restarts an app (or deployment slot, if specified).
   *
   * Restarts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.softRestart] Specify true to apply the
   * configuration settings and restarts the app only if necessary. By default,
   * the API always restarts and reprovisions the app.
   *
   * @param {boolean} [options.synchronous] Specify true to block until the app
   * is restarted. By default, it is set to false, and the API responds
   * immediately (asynchronous).
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restartWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restart(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restarts an app (or deployment slot, if specified).
   *
   * Restarts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.softRestart] Specify true to apply the
   * configuration settings and restarts the app only if necessary. By default,
   * the API always restarts and reprovisions the app.
   *
   * @param {boolean} [options.synchronous] Specify true to block until the app
   * is restarted. By default, it is set to false, and the API responds
   * immediately (asynchronous).
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restart(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restart(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restart(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets an app's deployment slots.
   *
   * Gets an app's deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlots(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets an app's deployment slots.
   *
   * Gets an app's deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlots(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlots(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlots(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the details of a web, mobile, or API app.
   *
   * Gets the details of a web, mobile, or API app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. By default, this API
   * returns the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the details of a web, mobile, or API app.
   *
   * Gets the details of a web, mobile, or API app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. By default, this API
   * returns the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
   * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
   * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
   * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
   * default is &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
   * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is &lt;code>true&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
   * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
   * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
   * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * &lt;code>true&lt;/code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot to create or update. By
   * default, this API attempts to create or modify the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateSlotWithHttpOperationResponse(resourceGroupName, name, siteEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
   * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
   * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
   * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
   * default is &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
   * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is &lt;code>true&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
   * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
   * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
   * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * &lt;code>true&lt;/code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot to create or update. By
   * default, this API attempts to create or modify the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app to delete.
   *
   * @param {string} slot Name of the deployment slot to delete. By default, the
   * API deletes the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
   * deleted
   *
   * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
   * Service plan will be empty after app deletion and you want to delete the
   * empty App Service plan. By default, the empty App Service plan is not
   * deleted.
   *
   * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
   * skipped
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app to delete.
   *
   * @param {string} slot Name of the deployment slot to delete. By default, the
   * API deletes the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
   * deleted
   *
   * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
   * Service plan will be empty after app deletion and you want to delete the
   * empty App Service plan. By default, the empty App Service plan is not
   * deleted.
   *
   * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
   * skipped
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Analyze a custom hostname.
   *
   * Analyze a custom hostname.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.hostName] Custom hostname
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;CustomHostnameAnalysisResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  analyzeCustomHostnameSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._analyzeCustomHostnameSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Analyze a custom hostname.
   *
   * Analyze a custom hostname.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.hostName] Custom hostname
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CustomHostnameAnalysisResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CustomHostnameAnalysisResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  analyzeCustomHostnameSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._analyzeCustomHostnameSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._analyzeCustomHostnameSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Applies the configuration settings from the target slot onto the
   * current slot.
   *
   * Applies the configuration settings from the target slot onto the current
   * slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  applySlotConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._applySlotConfigurationSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Applies the configuration settings from the target slot onto the
   * current slot.
   *
   * Applies the configuration settings from the target slot onto the current
   * slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  applySlotConfigurationSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._applySlotConfigurationSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._applySlotConfigurationSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a backup of an app.
   *
   * Creates a backup of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Backup configuration. You can use the JSON response
   * from the POST action as input here.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create a backup for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  backupSlotWithHttpOperationResponse(resourceGroupName, name, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._backupSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a backup of an app.
   *
   * Creates a backup of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Backup configuration. You can use the JSON response
   * from the POST action as input here.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create a backup for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  backupSlot(resourceGroupName, name, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._backupSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._backupSlot(resourceGroupName, name, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get backups of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupItemCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackupsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get backups of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItemCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItemCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackupsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackupsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackupsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Discovers an existing app backup that can be restored from a blob
   * in Azure storage.
   *
   * Discovers an existing app backup that can be restored from a blob in Azure
   * storage.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request A RestoreRequest object that includes Azure storage
   * URL and blog name for discovery of backup.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will perform discovery for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RestoreRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  discoverRestoreSlotWithHttpOperationResponse(resourceGroupName, name, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._discoverRestoreSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Discovers an existing app backup that can be restored from a blob
   * in Azure storage.
   *
   * Discovers an existing app backup that can be restored from a blob in Azure
   * storage.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request A RestoreRequest object that includes Azure storage
   * URL and blog name for discovery of backup.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will perform discovery for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  discoverRestoreSlot(resourceGroupName, name, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._discoverRestoreSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._discoverRestoreSlot(resourceGroupName, name, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a backup of an app by its ID.
   *
   * Gets a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupStatusSlotWithHttpOperationResponse(resourceGroupName, name, backupId, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupStatusSlot(resourceGroupName, name, backupId, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a backup of an app by its ID.
   *
   * Gets a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupStatusSlot(resourceGroupName, name, backupId, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupStatusSlot(resourceGroupName, name, backupId, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupStatusSlot(resourceGroupName, name, backupId, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a backup of an app by its ID.
   *
   * Deletes a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteBackupSlotWithHttpOperationResponse(resourceGroupName, name, backupId, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteBackupSlot(resourceGroupName, name, backupId, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a backup of an app by its ID.
   *
   * Deletes a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteBackupSlot(resourceGroupName, name, backupId, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteBackupSlot(resourceGroupName, name, backupId, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteBackupSlot(resourceGroupName, name, backupId, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets status of a web app backup that may be in progress, including
   * secrets associated with the backup, such as the Azure Storage SAS URL. Also
   * can be used to update the SAS URL for the backup if a new URL is passed in
   * the request body.
   *
   * Gets status of a web app backup that may be in progress, including secrets
   * associated with the backup, such as the Azure Storage SAS URL. Also can be
   * used to update the SAS URL for the backup if a new URL is passed in the
   * request body.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} backupId Id of backup
   *
   * @param {object} request Information on backup request
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupStatusSecretsSlotWithHttpOperationResponse(resourceGroupName, name, backupId, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackupStatusSecretsSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets status of a web app backup that may be in progress, including
   * secrets associated with the backup, such as the Azure Storage SAS URL. Also
   * can be used to update the SAS URL for the backup if a new URL is passed in
   * the request body.
   *
   * Gets status of a web app backup that may be in progress, including secrets
   * associated with the backup, such as the Azure Storage SAS URL. Also can be
   * used to update the SAS URL for the backup if a new URL is passed in the
   * request body.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} backupId Id of backup
   *
   * @param {object} request Information on backup request
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackupStatusSecretsSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackupStatusSecretsSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackupStatusSecretsSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restore a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RestoreResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restoreSlotWithHttpOperationResponse(resourceGroupName, name, backupId, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restoreSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restore a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restoreSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restoreSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restoreSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the application settings of an app.
   *
   * Replaces the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} appSettings Application settings of the app.
   *
   * @param {object} [appSettings.properties] Settings.
   *
   * @param {string} [appSettings.name] Resource Name.
   *
   * @param {string} [appSettings.kind] Kind of resource.
   *
   * @param {string} appSettings.location Resource Location.
   *
   * @param {string} [appSettings.type] Resource type.
   *
   * @param {object} [appSettings.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the application settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateApplicationSettingsSlotWithHttpOperationResponse(resourceGroupName, name, appSettings, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateApplicationSettingsSlot(resourceGroupName, name, appSettings, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the application settings of an app.
   *
   * Replaces the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} appSettings Application settings of the app.
   *
   * @param {object} [appSettings.properties] Settings.
   *
   * @param {string} [appSettings.name] Resource Name.
   *
   * @param {string} [appSettings.kind] Kind of resource.
   *
   * @param {string} appSettings.location Resource Location.
   *
   * @param {string} [appSettings.type] Resource type.
   *
   * @param {object} [appSettings.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the application settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateApplicationSettingsSlot(resourceGroupName, name, appSettings, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateApplicationSettingsSlot(resourceGroupName, name, appSettings, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateApplicationSettingsSlot(resourceGroupName, name, appSettings, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the application settings of an app.
   *
   * Gets the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the application settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listApplicationSettingsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listApplicationSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the application settings of an app.
   *
   * Gets the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the application settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listApplicationSettingsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listApplicationSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listApplicationSettingsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the Authentication / Authorization settings associated with
   * web app.
   *
   * Updates the Authentication / Authorization settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} siteAuthSettings Auth settings associated with web app
   *
   * @param {boolean} [siteAuthSettings.enabled] &lt;code>true&lt;/code> if the
   * Authentication / Authorization feature is enabled for the current app;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
   * Authentication / Authorization feature in use for the current app.
   * The setting in this value can control the behavior of certain features in
   * the Authentication / Authorization module.
   *
   * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
   * take when an unauthenticated client attempts to access the app. Possible
   * values include: 'RedirectToLoginPage', 'AllowAnonymous'
   *
   * @param {boolean} [siteAuthSettings.tokenStoreEnabled] &lt;code>true&lt;/code> to
   * durably store platform-specific security tokens that are obtained during
   * login flows; otherwise, &lt;code>false&lt;/code>.
   * The default is &lt;code>false&lt;/code>.
   *
   * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
   * that can be redirected to as part of logging in or logging out of the app.
   * Note that the query string part of the URL is ignored.
   * This is an advanced setting typically only needed by Windows Store
   * application backends.
   * Note that URLs within the current domain are always implicitly allowed.
   *
   * @param {string} [siteAuthSettings.defaultProvider] The default
   * authentication provider to use when multiple providers are configured.
   * This setting is only needed if multiple providers are configured and the
   * unauthenticated client
   * action is set to "RedirectToLoginPage". Possible values include:
   * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
   *
   * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
   * hours after session token expiration that a session token can be used to
   * call the token refresh API. The default is 72 hours.
   *
   * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
   * party application, known as the client_id.
   * This setting is required for enabling OpenID Connection authentication with
   * Azure Active Directory or
   * other 3rd party OpenID Connect providers.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
   * relying party application (in Azure Active Directory, this is also referred
   * to as the Key).
   * This setting is optional. If no client secret is configured, the OpenID
   * Connect implicit auth flow is used to authenticate end users.
   * Otherwise, the OpenID Connect Authorization Code Flow is used to
   * authenticate end users.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
   * represents the entity which issues access tokens for this application.
   * When using Azure Active Directory, this value is the URI of the directory
   * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
   * This URI is a case-sensitive identifier for the token issuer.
   * More information on OpenID Connect Discovery:
   * http://openid.net/specs/openid-connect-discovery-1_0.html
   *
   * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
   * to consider when validating JWTs issued by
   * Azure Active Directory. Note that the &lt;code>ClientID&lt;/code> value is always
   * considered an
   * allowed audience, regardless of this setting.
   *
   * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
   * send to the OpenID Connect authorization endpoint when
   * a user logs in. Each parameter must be in the form "key=value".
   *
   * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
   * ID for the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.googleClientSecret] The client secret
   * associated with the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Google Sign-In authentication.
   * This setting is optional. If not specified, "openid", "profile", and "email"
   * are used as default scopes.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
   * app used for login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
   * Facebook app used for Facebook Login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Facebook Login authentication.
   * This setting is optional.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
   * consumer key of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
   * consumer secret of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
   * client ID that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
   * 2.0 client secret that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
   * scopes that will be requested as part of Microsoft Account authentication.
   * This setting is optional. If not specified, "wl.basic" is used as the
   * default scope.
   * Microsoft Account Scopes and permissions documentation:
   * https://msdn.microsoft.com/en-us/library/dn631845.aspx
   *
   * @param {string} [siteAuthSettings.name] Resource Name.
   *
   * @param {string} [siteAuthSettings.kind] Kind of resource.
   *
   * @param {string} siteAuthSettings.location Resource Location.
   *
   * @param {string} [siteAuthSettings.type] Resource type.
   *
   * @param {object} [siteAuthSettings.tags] Resource tags.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteAuthSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateAuthSettingsSlotWithHttpOperationResponse(resourceGroupName, name, siteAuthSettings, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateAuthSettingsSlot(resourceGroupName, name, siteAuthSettings, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the Authentication / Authorization settings associated with
   * web app.
   *
   * Updates the Authentication / Authorization settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} siteAuthSettings Auth settings associated with web app
   *
   * @param {boolean} [siteAuthSettings.enabled] &lt;code>true&lt;/code> if the
   * Authentication / Authorization feature is enabled for the current app;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
   * Authentication / Authorization feature in use for the current app.
   * The setting in this value can control the behavior of certain features in
   * the Authentication / Authorization module.
   *
   * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
   * take when an unauthenticated client attempts to access the app. Possible
   * values include: 'RedirectToLoginPage', 'AllowAnonymous'
   *
   * @param {boolean} [siteAuthSettings.tokenStoreEnabled] &lt;code>true&lt;/code> to
   * durably store platform-specific security tokens that are obtained during
   * login flows; otherwise, &lt;code>false&lt;/code>.
   * The default is &lt;code>false&lt;/code>.
   *
   * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
   * that can be redirected to as part of logging in or logging out of the app.
   * Note that the query string part of the URL is ignored.
   * This is an advanced setting typically only needed by Windows Store
   * application backends.
   * Note that URLs within the current domain are always implicitly allowed.
   *
   * @param {string} [siteAuthSettings.defaultProvider] The default
   * authentication provider to use when multiple providers are configured.
   * This setting is only needed if multiple providers are configured and the
   * unauthenticated client
   * action is set to "RedirectToLoginPage". Possible values include:
   * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
   *
   * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
   * hours after session token expiration that a session token can be used to
   * call the token refresh API. The default is 72 hours.
   *
   * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
   * party application, known as the client_id.
   * This setting is required for enabling OpenID Connection authentication with
   * Azure Active Directory or
   * other 3rd party OpenID Connect providers.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
   * relying party application (in Azure Active Directory, this is also referred
   * to as the Key).
   * This setting is optional. If no client secret is configured, the OpenID
   * Connect implicit auth flow is used to authenticate end users.
   * Otherwise, the OpenID Connect Authorization Code Flow is used to
   * authenticate end users.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
   * represents the entity which issues access tokens for this application.
   * When using Azure Active Directory, this value is the URI of the directory
   * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
   * This URI is a case-sensitive identifier for the token issuer.
   * More information on OpenID Connect Discovery:
   * http://openid.net/specs/openid-connect-discovery-1_0.html
   *
   * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
   * to consider when validating JWTs issued by
   * Azure Active Directory. Note that the &lt;code>ClientID&lt;/code> value is always
   * considered an
   * allowed audience, regardless of this setting.
   *
   * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
   * send to the OpenID Connect authorization endpoint when
   * a user logs in. Each parameter must be in the form "key=value".
   *
   * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
   * ID for the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.googleClientSecret] The client secret
   * associated with the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Google Sign-In authentication.
   * This setting is optional. If not specified, "openid", "profile", and "email"
   * are used as default scopes.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
   * app used for login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
   * Facebook app used for Facebook Login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Facebook Login authentication.
   * This setting is optional.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
   * consumer key of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
   * consumer secret of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
   * client ID that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
   * 2.0 client secret that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
   * scopes that will be requested as part of Microsoft Account authentication.
   * This setting is optional. If not specified, "wl.basic" is used as the
   * default scope.
   * Microsoft Account Scopes and permissions documentation:
   * https://msdn.microsoft.com/en-us/library/dn631845.aspx
   *
   * @param {string} [siteAuthSettings.name] Resource Name.
   *
   * @param {string} [siteAuthSettings.kind] Kind of resource.
   *
   * @param {string} siteAuthSettings.location Resource Location.
   *
   * @param {string} [siteAuthSettings.type] Resource type.
   *
   * @param {object} [siteAuthSettings.tags] Resource tags.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteAuthSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteAuthSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAuthSettingsSlot(resourceGroupName, name, siteAuthSettings, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateAuthSettingsSlot(resourceGroupName, name, siteAuthSettings, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateAuthSettingsSlot(resourceGroupName, name, siteAuthSettings, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Authentication/Authorization settings of an app.
   *
   * Gets the Authentication/Authorization settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteAuthSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAuthSettingsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAuthSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Authentication/Authorization settings of an app.
   *
   * Gets the Authentication/Authorization settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteAuthSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteAuthSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAuthSettingsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAuthSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAuthSettingsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the backup configuration of an app.
   *
   * Updates the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Edited backup configuration.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateBackupConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateBackupConfigurationSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the backup configuration of an app.
   *
   * Updates the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Edited backup configuration.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateBackupConfigurationSlot(resourceGroupName, name, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateBackupConfigurationSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateBackupConfigurationSlot(resourceGroupName, name, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the backup configuration of an app.
   *
   * Deletes the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteBackupConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteBackupConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the backup configuration of an app.
   *
   * Deletes the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteBackupConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteBackupConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteBackupConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the backup configuration of an app.
   *
   * Gets the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the backup configuration of an app.
   *
   * Gets the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the connection strings of an app.
   *
   * Replaces the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} connectionStrings Connection strings of the app or
   * deployment slot. See example.
   *
   * @param {object} [connectionStrings.properties] Connection strings.
   *
   * @param {string} [connectionStrings.name] Resource Name.
   *
   * @param {string} [connectionStrings.kind] Kind of resource.
   *
   * @param {string} connectionStrings.location Resource Location.
   *
   * @param {string} [connectionStrings.type] Resource type.
   *
   * @param {object} [connectionStrings.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the connection settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ConnectionStringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateConnectionStringsSlotWithHttpOperationResponse(resourceGroupName, name, connectionStrings, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateConnectionStringsSlot(resourceGroupName, name, connectionStrings, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the connection strings of an app.
   *
   * Replaces the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} connectionStrings Connection strings of the app or
   * deployment slot. See example.
   *
   * @param {object} [connectionStrings.properties] Connection strings.
   *
   * @param {string} [connectionStrings.name] Resource Name.
   *
   * @param {string} [connectionStrings.kind] Kind of resource.
   *
   * @param {string} connectionStrings.location Resource Location.
   *
   * @param {string} [connectionStrings.type] Resource type.
   *
   * @param {object} [connectionStrings.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the connection settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ConnectionStringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ConnectionStringDictionary} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateConnectionStringsSlot(resourceGroupName, name, connectionStrings, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateConnectionStringsSlot(resourceGroupName, name, connectionStrings, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateConnectionStringsSlot(resourceGroupName, name, connectionStrings, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the connection strings of an app.
   *
   * Gets the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the connection settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ConnectionStringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listConnectionStringsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listConnectionStringsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the connection strings of an app.
   *
   * Gets the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the connection settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ConnectionStringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ConnectionStringDictionary} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listConnectionStringsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listConnectionStringsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listConnectionStringsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the logging configuration of an app.
   *
   * Gets the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the logging configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteLogsConfig>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDiagnosticLogsConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the logging configuration of an app.
   *
   * Gets the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the logging configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteLogsConfig} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteLogsConfig} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the logging configuration of an app.
   *
   * Updates the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
   * the logging configuration to change in the "properties" property.
   *
   * @param {object} [siteLogsConfig.applicationLogs] Application logs
   * configuration.
   *
   * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
   * to file system configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
   * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
   * Application logs to azure table storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
   * URL to an Azure table with add/query/delete permissions.
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
   * Application logs to blob storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
   * url to a azure blob container with read/write/list/delete permissions.
   *
   * @param {number}
   * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
   * in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
   *
   * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
   * system configuration.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
   * size in megabytes that http log files can use.
   * When reached old log files will be removed to make space for new ones.
   * Value can range between 25 and 100.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
   * Retention in days.
   * Remove files older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
   * azure blob storage configuration.
   *
   * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
   * a azure blob container with read/write/list/delete permissions.
   *
   * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
   * Retention in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
   * tracing configuration.
   *
   * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
   * messages configuration.
   *
   * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
   *
   * @param {string} [siteLogsConfig.name] Resource Name.
   *
   * @param {string} [siteLogsConfig.kind] Kind of resource.
   *
   * @param {string} siteLogsConfig.location Resource Location.
   *
   * @param {string} [siteLogsConfig.type] Resource type.
   *
   * @param {object} [siteLogsConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the logging configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteLogsConfig>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateDiagnosticLogsConfigSlotWithHttpOperationResponse(resourceGroupName, name, siteLogsConfig, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateDiagnosticLogsConfigSlot(resourceGroupName, name, siteLogsConfig, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the logging configuration of an app.
   *
   * Updates the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
   * the logging configuration to change in the "properties" property.
   *
   * @param {object} [siteLogsConfig.applicationLogs] Application logs
   * configuration.
   *
   * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
   * to file system configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
   * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
   * Application logs to azure table storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
   * URL to an Azure table with add/query/delete permissions.
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
   * Application logs to blob storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
   * url to a azure blob container with read/write/list/delete permissions.
   *
   * @param {number}
   * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
   * in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
   *
   * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
   * system configuration.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
   * size in megabytes that http log files can use.
   * When reached old log files will be removed to make space for new ones.
   * Value can range between 25 and 100.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
   * Retention in days.
   * Remove files older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
   * azure blob storage configuration.
   *
   * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
   * a azure blob container with read/write/list/delete permissions.
   *
   * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
   * Retention in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
   * tracing configuration.
   *
   * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
   * messages configuration.
   *
   * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
   *
   * @param {string} [siteLogsConfig.name] Resource Name.
   *
   * @param {string} [siteLogsConfig.kind] Kind of resource.
   *
   * @param {string} siteLogsConfig.location Resource Location.
   *
   * @param {string} [siteLogsConfig.type] Resource type.
   *
   * @param {object} [siteLogsConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the logging configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteLogsConfig} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteLogsConfig} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDiagnosticLogsConfigSlot(resourceGroupName, name, siteLogsConfig, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateDiagnosticLogsConfigSlot(resourceGroupName, name, siteLogsConfig, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateDiagnosticLogsConfigSlot(resourceGroupName, name, siteLogsConfig, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the metadata of an app.
   *
   * Replaces the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} metadata Edited metadata of the app or deployment slot. See
   * example.
   *
   * @param {object} [metadata.properties] Settings.
   *
   * @param {string} [metadata.name] Resource Name.
   *
   * @param {string} [metadata.kind] Kind of resource.
   *
   * @param {string} metadata.location Resource Location.
   *
   * @param {string} [metadata.type] Resource type.
   *
   * @param {object} [metadata.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the metadata for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateMetadataSlotWithHttpOperationResponse(resourceGroupName, name, metadata, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateMetadataSlot(resourceGroupName, name, metadata, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the metadata of an app.
   *
   * Replaces the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} metadata Edited metadata of the app or deployment slot. See
   * example.
   *
   * @param {object} [metadata.properties] Settings.
   *
   * @param {string} [metadata.name] Resource Name.
   *
   * @param {string} [metadata.kind] Kind of resource.
   *
   * @param {string} metadata.location Resource Location.
   *
   * @param {string} [metadata.type] Resource type.
   *
   * @param {object} [metadata.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the metadata for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateMetadataSlot(resourceGroupName, name, metadata, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateMetadataSlot(resourceGroupName, name, metadata, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateMetadataSlot(resourceGroupName, name, metadata, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the metadata of an app.
   *
   * Gets the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the metadata for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetadataSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetadataSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the metadata of an app.
   *
   * Gets the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the metadata for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetadataSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetadataSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetadataSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing credentials for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;User>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPublishingCredentialsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPublishingCredentialsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing credentials for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {User} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link User} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPublishingCredentialsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPublishingCredentialsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPublishingCredentialsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the Push settings associated with web app.
   *
   * Updates the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} pushSettings Push settings associated with web app
   *
   * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
   * whether the Push endpoint is enabled.
   *
   * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
   * containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
   * containing a list of tags that require user authentication to be used in the
   * push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PushSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateSitePushSettingsSlotWithHttpOperationResponse(resourceGroupName, name, pushSettings, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateSitePushSettingsSlot(resourceGroupName, name, pushSettings, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the Push settings associated with web app.
   *
   * Updates the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} pushSettings Push settings associated with web app
   *
   * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
   * whether the Push endpoint is enabled.
   *
   * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
   * containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
   * containing a list of tags that require user authentication to be used in the
   * push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PushSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PushSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSitePushSettingsSlot(resourceGroupName, name, pushSettings, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateSitePushSettingsSlot(resourceGroupName, name, pushSettings, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateSitePushSettingsSlot(resourceGroupName, name, pushSettings, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Push settings associated with web app.
   *
   * Gets the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PushSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSitePushSettingsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSitePushSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Push settings associated with web app.
   *
   * Gets the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PushSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PushSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSitePushSettingsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSitePushSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSitePushSettingsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the configuration of an app, such as platform version and
   * bitness, default documents, virtual applications, Always On, etc.
   *
   * Gets the configuration of an app, such as platform version and bitness,
   * default documents, virtual applications, Always On, etc.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the configuration of an app, such as platform version and
   * bitness, default documents, virtual applications, Always On, etc.
   *
   * Gets the configuration of an app, such as platform version and bitness,
   * default documents, virtual applications, Always On, etc.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
   * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
   * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
   * logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
   * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
   * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
   * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
   * enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
   * is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
   * local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, siteConfig, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
   * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
   * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
   * logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
   * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
   * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
   * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
   * enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
   * is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
   * local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
   * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
   * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
   * logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
   * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
   * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
   * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
   * enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
   * is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
   * local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, siteConfig, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] &lt;code>true&lt;/code> if
   * request tracing is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] &lt;code>true&lt;/code> if
   * remote debugging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] &lt;code>true&lt;/code> if HTTP
   * logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] &lt;code>true&lt;/code>
   * if detailed error logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] &lt;code>true&lt;/code> to use
   * 32-bit worker process; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] &lt;code>true&lt;/code> if
   * WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] &lt;code>true&lt;/code> if Always On is
   * enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] &lt;code>true&lt;/code> if Auto Heal
   * is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] &lt;code>true&lt;/code> to enable
   * local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of web app configuration snapshots identifiers. Each
   * element of the list contains a timestamp and the ID of the snapshot.
   *
   * Gets a list of web app configuration snapshots identifiers. Each element of
   * the list contains a timestamp and the ID of the snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listConfigurationSnapshotInfoSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of web app configuration snapshots identifiers. Each
   * element of the list contains a timestamp and the ID of the snapshot.
   *
   * Gets a list of web app configuration snapshots identifiers. Each element of
   * the list contains a timestamp and the ID of the snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a snapshot of the configuration of an app at a previous point
   * in time.
   *
   * Gets a snapshot of the configuration of an app at a previous point in time.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getConfigurationSnapshotSlotWithHttpOperationResponse(resourceGroupName, name, snapshotId, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a snapshot of the configuration of an app at a previous point
   * in time.
   *
   * Gets a snapshot of the configuration of an app at a previous point in time.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Reverts the configuration of an app to a previous snapshot.
   *
   * Reverts the configuration of an app to a previous snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverSiteConfigurationSnapshotSlotWithHttpOperationResponse(resourceGroupName, name, snapshotId, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Reverts the configuration of an app to a previous snapshot.
   *
   * Reverts the configuration of an app to a previous snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API returns deployments for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDeploymentsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDeploymentsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API returns deployments for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDeploymentsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDeploymentsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDeploymentsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets a deployment for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeploymentSlot(resourceGroupName, name, id, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets a deployment for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeploymentSlot(resourceGroupName, name, id, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeploymentSlot(resourceGroupName, name, id, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeploymentSlot(resourceGroupName, name, id, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API creates a deployment for the production slot.
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, deployment, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API creates a deployment for the production slot.
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API deletes a deployment for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDeploymentSlot(resourceGroupName, name, id, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API deletes a deployment for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDeploymentSlot(resourceGroupName, name, id, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDeploymentSlot(resourceGroupName, name, id, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDeploymentSlot(resourceGroupName, name, id, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;IdentifierCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDomainOwnershipIdentifiersSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IdentifierCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IdentifierCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get domain ownership identifier for web app.
   *
   * Get domain ownership identifier for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDomainOwnershipIdentifierSlotWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get domain ownership identifier for web app.
   *
   * Get domain ownership identifier for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateDomainOwnershipIdentifierSlotWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a domain ownership identifier for a web app.
   *
   * Deletes a domain ownership identifier for a web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDomainOwnershipIdentifierSlotWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a domain ownership identifier for a web app.
   *
   * Deletes a domain ownership identifier for a web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateDomainOwnershipIdentifierSlotWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets hostname bindings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HostNameBindingCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHostNameBindingsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHostNameBindingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets hostname bindings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBindingCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBindingCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHostNameBindingsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHostNameBindingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHostNameBindingsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API the named binding for the production slot.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HostNameBinding>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getHostNameBindingSlotWithHttpOperationResponse(resourceGroupName, name, slot, hostName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API the named binding for the production slot.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBinding} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBinding} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a hostname binding for an app.
   *
   * Creates a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} hostNameBinding Binding details. This is the JSON
   * representation of a HostNameBinding object.
   *
   * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
   *
   * @param {string} [hostNameBinding.siteName] App Service app name.
   *
   * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
   * resource URI.
   *
   * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
   *
   * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
   * Possible values include: 'Website', 'TrafficManager'
   *
   * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
   * record type. Possible values include: 'CName', 'A'
   *
   * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
   * values include: 'Verified', 'Managed'
   *
   * @param {string} [hostNameBinding.sslState] SSL type. Possible values
   * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
   *
   * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
   *
   * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
   * the hostname if IP based SSL is enabled.
   *
   * @param {string} [hostNameBinding.name] Resource Name.
   *
   * @param {string} [hostNameBinding.kind] Kind of resource.
   *
   * @param {string} hostNameBinding.location Resource Location.
   *
   * @param {string} [hostNameBinding.type] Resource type.
   *
   * @param {object} [hostNameBinding.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create a binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HostNameBinding>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateHostNameBindingSlotWithHttpOperationResponse(resourceGroupName, name, hostName, hostNameBinding, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, hostNameBinding, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a hostname binding for an app.
   *
   * Creates a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} hostNameBinding Binding details. This is the JSON
   * representation of a HostNameBinding object.
   *
   * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
   *
   * @param {string} [hostNameBinding.siteName] App Service app name.
   *
   * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
   * resource URI.
   *
   * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
   *
   * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
   * Possible values include: 'Website', 'TrafficManager'
   *
   * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
   * record type. Possible values include: 'CName', 'A'
   *
   * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
   * values include: 'Verified', 'Managed'
   *
   * @param {string} [hostNameBinding.sslState] SSL type. Possible values
   * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
   *
   * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
   *
   * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
   * the hostname if IP based SSL is enabled.
   *
   * @param {string} [hostNameBinding.name] Resource Name.
   *
   * @param {string} [hostNameBinding.kind] Kind of resource.
   *
   * @param {string} hostNameBinding.location Resource Location.
   *
   * @param {string} [hostNameBinding.type] Resource type.
   *
   * @param {object} [hostNameBinding.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create a binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBinding} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBinding} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, hostNameBinding, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, hostNameBinding, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, hostNameBinding, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a hostname binding for an app.
   *
   * Deletes a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteHostNameBindingSlotWithHttpOperationResponse(resourceGroupName, name, slot, hostName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a hostname binding for an app.
   *
   * Deletes a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
   * App.
   *
   * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getHybridConnectionSlotWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
   * App.
   *
   * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateHybridConnectionSlotWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Removes a Hybrid Connection from this site.
   *
   * Removes a Hybrid Connection from this site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteHybridConnectionSlotWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Removes a Hybrid Connection from this site.
   *
   * Removes a Hybrid Connection from this site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateHybridConnectionSlotWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the send key name and value for a Hybrid Connection.
   *
   * Gets the send key name and value for a Hybrid Connection.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HybridConnectionKey>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHybridConnectionKeysSlotWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the send key name and value for a Hybrid Connection.
   *
   * Gets the send key name and value for a Hybrid Connection.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnectionKey} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnectionKey} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHybridConnectionsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHybridConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHybridConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHybridConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHybridConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets hybrid connections configured for an app (or deployment slot,
   * if specified).
   *
   * Gets hybrid connections configured for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get hybrid connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listRelayServiceConnectionsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets hybrid connections configured for an app (or deployment slot,
   * if specified).
   *
   * Gets hybrid connections configured for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get hybrid connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a hybrid connection configuration by its name.
   *
   * Gets a hybrid connection configuration by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a hybrid connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getRelayServiceConnectionSlotWithHttpOperationResponse(resourceGroupName, name, entityName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a hybrid connection configuration by its name.
   *
   * Gets a hybrid connection configuration by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a hybrid connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create or update a hybrid connection for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateRelayServiceConnectionSlotWithHttpOperationResponse(resourceGroupName, name, entityName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create or update a hybrid connection for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a relay service connection by its name.
   *
   * Deletes a relay service connection by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete a hybrid connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteRelayServiceConnectionSlotWithHttpOperationResponse(resourceGroupName, name, entityName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a relay service connection by its name.
   *
   * Deletes a relay service connection by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete a hybrid connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create or update a hybrid connection for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateRelayServiceConnectionSlotWithHttpOperationResponse(resourceGroupName, name, entityName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create or update a hybrid connection for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets the production slot instances.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;WebAppInstanceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceIdentifiersSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceIdentifiersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets the production slot instances.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppInstanceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppInstanceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceIdentifiersSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceIdentifiersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceIdentifiersSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API returns deployments for the production slot.
   *
   * @param {string} instanceId The ID of a specific scaled-out instance. This is
   * the value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceDeploymentsSlotWithHttpOperationResponse(resourceGroupName, name, slot, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API returns deployments for the production slot.
   *
   * @param {string} instanceId The ID of a specific scaled-out instance. This is
   * the value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getInstanceDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API creates a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createInstanceDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, instanceId, deployment, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, deployment, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API creates a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, deployment, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, deployment, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, deployment, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API deletes a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteInstanceDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API deletes a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. By default, this API
   * returns information on the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteCloneability>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  isCloneableSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._isCloneableSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. By default, this API
   * returns information on the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteCloneability} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteCloneability} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  isCloneableSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._isCloneableSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._isCloneableSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get metric definitions of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ResourceMetricDefinitionCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricDefinitionsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricDefinitionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get metric definitions of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricDefinitionCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricDefinitionCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricDefinitionsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricDefinitionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricDefinitionsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get metrics of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.details] Specify "true" to include metric details
   * in the response. It is "false" by default.
   *
   * @param {string} [options.filter] Return only metrics specified in the filter
   * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
   * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
   * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ResourceMetricCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get metrics of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.details] Specify "true" to include metric details
   * in the response. It is "false" by default.
   *
   * @param {string} [options.filter] Return only metrics specified in the filter
   * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
   * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
   * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Returns the status of MySql in app migration, if one is active, and
   * whether or not MySql in app is enabled
   *
   * Returns the status of MySql in app migration, if one is active, and whether
   * or not MySql in app is enabled
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of the deployment slot
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;MigrateMySqlStatus>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getMigrateMySqlStatusSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns the status of MySql in app migration, if one is active, and
   * whether or not MySql in app is enabled
   *
   * Returns the status of MySql in app migration, if one is active, and whether
   * or not MySql in app is enabled
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of the deployment slot
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MigrateMySqlStatus} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MigrateMySqlStatus} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} view The type of view. This can either be "summary" or
   * "detailed".
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get network features for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;NetworkFeatures>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listNetworkFeaturesSlotWithHttpOperationResponse(resourceGroupName, name, view, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} view The type of view. This can either be "summary" or
   * "detailed".
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get network features for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NetworkFeatures} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NetworkFeatures} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Start capturing network packets for the site.
   *
   * Start capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {string} slot The name of the slot for this web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.durationInSeconds] The duration to keep capturing
   * in seconds.
   *
   * @param {number} [options.maxFrameLength] The maximum frame length in bytes
   * (Optional).
   *
   * @param {string} [options.sasUrl] The Blob URL to store capture file.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startWebSiteNetworkTraceSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Start capturing network packets for the site.
   *
   * Start capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {string} slot The name of the slot for this web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.durationInSeconds] The duration to keep capturing
   * in seconds.
   *
   * @param {number} [options.maxFrameLength] The maximum frame length in bytes
   * (Optional).
   *
   * @param {string} [options.sasUrl] The Blob URL to store capture file.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Stop ongoing capturing network packets for the site.
   *
   * Stop ongoing capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {string} slot The name of the slot for this web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopWebSiteNetworkTraceSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stop ongoing capturing network packets for the site.
   *
   * Stop ongoing capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {string} slot The name of the slot for this web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Generates a new publishing password for an app (or deployment slot,
   * if specified).
   *
   * Generates a new publishing password for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API generate a new publishing password for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  generateNewSitePublishingPasswordSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Generates a new publishing password for an app (or deployment slot,
   * if specified).
   *
   * Generates a new publishing password for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API generate a new publishing password for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot. **** CURRENTLY UNUSED *****
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only usages/metrics specified in the
   * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
   * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
   * eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PerfMonCounterCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPerfMonCountersSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPerfMonCountersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot. **** CURRENTLY UNUSED *****
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only usages/metrics specified in the
   * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
   * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
   * eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PerfMonCounterCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PerfMonCounterCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPerfMonCountersSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPerfMonCountersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPerfMonCountersSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets web app's event logs.
   *
   * Gets web app's event logs.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SitePhpErrorLogFlag>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSitePhpErrorLogFlagSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets web app's event logs.
   *
   * Gets web app's event logs.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SitePhpErrorLogFlag} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SitePhpErrorLogFlag} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the premier add-ons of an app.
   *
   * Gets the premier add-ons of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the premier add-ons for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPremierAddOnsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPremierAddOnsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the premier add-ons of an app.
   *
   * Gets the premier add-ons of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the premier add-ons for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPremierAddOnsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPremierAddOnsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPremierAddOnsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a named add-on of an app.
   *
   * Gets a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPremierAddOnSlotWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a named add-on of an app.
   *
   * Gets a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a named add-on of an app.
   *
   * Updates a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} premierAddOn A JSON representation of the edited premier
   * add-on.
   *
   * @param {string} [premierAddOn.sku] SKU.
   *
   * @param {string} [premierAddOn.product] Product.
   *
   * @param {string} [premierAddOn.vendor] Vendor.
   *
   * @param {string} [premierAddOn.premierAddOnName] Name.
   *
   * @param {string} [premierAddOn.premierAddOnLocation] Location.
   *
   * @param {object} [premierAddOn.premierAddOnTags] Tags.
   *
   * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
   *
   * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
   *
   * @param {string} [premierAddOn.name] Resource Name.
   *
   * @param {string} [premierAddOn.kind] Kind of resource.
   *
   * @param {string} premierAddOn.location Resource Location.
   *
   * @param {string} [premierAddOn.type] Resource type.
   *
   * @param {object} [premierAddOn.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addPremierAddOnSlotWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a named add-on of an app.
   *
   * Updates a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} premierAddOn A JSON representation of the edited premier
   * add-on.
   *
   * @param {string} [premierAddOn.sku] SKU.
   *
   * @param {string} [premierAddOn.product] Product.
   *
   * @param {string} [premierAddOn.vendor] Vendor.
   *
   * @param {string} [premierAddOn.premierAddOnName] Name.
   *
   * @param {string} [premierAddOn.premierAddOnLocation] Location.
   *
   * @param {object} [premierAddOn.premierAddOnTags] Tags.
   *
   * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
   *
   * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
   *
   * @param {string} [premierAddOn.name] Resource Name.
   *
   * @param {string} [premierAddOn.kind] Kind of resource.
   *
   * @param {string} premierAddOn.location Resource Location.
   *
   * @param {string} [premierAddOn.type] Resource type.
   *
   * @param {object} [premierAddOn.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a premier add-on from an app.
   *
   * Delete a premier add-on from an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deletePremierAddOnSlotWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a premier add-on from an app.
   *
   * Delete a premier add-on from an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the publishing profile for an app (or deployment slot, if
   * specified).
   *
   * Gets the publishing profile for an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing profile for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.format] Name of the format. Valid values are:
   * FileZilla3
   * WebDeploy -- default
   * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPublishingProfileXmlWithSecretsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the publishing profile for an app (or deployment slot, if
   * specified).
   *
   * Gets the publishing profile for an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing profile for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.format] Name of the format. Valid values are:
   * FileZilla3
   * WebDeploy -- default
   * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RecoverResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverSlotWithHttpOperationResponse(resourceGroupName, name, recoveryEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverSlot(resourceGroupName, name, recoveryEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RecoverResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RecoverResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverSlot(resourceGroupName, name, recoveryEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverSlot(resourceGroupName, name, recoveryEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverSlot(resourceGroupName, name, recoveryEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API resets configuration settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resetSlotConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resetSlotConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API resets configuration settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resetSlotConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resetSlotConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resetSlotConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Restarts an app (or deployment slot, if specified).
   *
   * Restarts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restart the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.softRestart] Specify true to apply the
   * configuration settings and restarts the app only if necessary. By default,
   * the API always restarts and reprovisions the app.
   *
   * @param {boolean} [options.synchronous] Specify true to block until the app
   * is restarted. By default, it is set to false, and the API responds
   * immediately (asynchronous).
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restartSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restartSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restarts an app (or deployment slot, if specified).
   *
   * Restarts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restart the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.softRestart] Specify true to apply the
   * configuration settings and restarts the app only if necessary. By default,
   * the API always restarts and reprovisions the app.
   *
   * @param {boolean} [options.synchronous] Specify true to block until the app
   * is restarted. By default, it is set to false, and the API responds
   * immediately (asynchronous).
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restartSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restartSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restartSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SlotDifferenceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotDifferencesSlotWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotDifferencesSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotDifferenceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotDifferenceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotDifferencesSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotDifferencesSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotDifferencesSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  swapSlotSlotWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._swapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  swapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._swapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._swapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Website Name
   *
   * @param {string} slot Website Slot
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SnapshotCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSnapshotsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSnapshotsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Website Name
   *
   * @param {string} slot Website Slot
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SnapshotCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SnapshotCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSnapshotsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSnapshotsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSnapshotsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the source control configuration of an app.
   *
   * Gets the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSourceControlSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSourceControlSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the source control configuration of an app.
   *
   * Gets the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSourceControlSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSourceControlSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSourceControlSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
   * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
   * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateSourceControlSlotWithHttpOperationResponse(resourceGroupName, name, siteSourceControl, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
   * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
   * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the source control configuration of an app.
   *
   * Deletes the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSourceControlSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSourceControlSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the source control configuration of an app.
   *
   * Deletes the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSourceControlSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSourceControlSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSourceControlSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Starts an app (or deployment slot, if specified).
   *
   * Starts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will start the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts an app (or deployment slot, if specified).
   *
   * Starts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will start the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Stops an app (or deployment slot, if specified).
   *
   * Stops an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will stop the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stopSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stops an app (or deployment slot, if specified).
   *
   * Stops an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will stop the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stopSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stopSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stopSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Sync web app repository.
   *
   * Sync web app repository.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  syncRepositorySlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._syncRepositorySlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sync web app repository.
   *
   * Sync web app repository.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  syncRepositorySlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._syncRepositorySlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._syncRepositorySlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get quota information of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only information specified in the
   * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
   * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
   * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
   * duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;CsmUsageQuotaCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsagesSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsagesSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get quota information of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only information specified in the
   * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
   * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
   * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
   * duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CsmUsageQuotaCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CsmUsageQuotaCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsagesSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsagesSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsagesSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the virtual networks the app (or deployment slot) is connected
   * to.
   *
   * Gets the virtual networks the app (or deployment slot) is connected to.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get virtual network connections for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listVnetConnectionsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listVnetConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the virtual networks the app (or deployment slot) is connected
   * to.
   *
   * Gets the virtual networks the app (or deployment slot) is connected to.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get virtual network connections for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listVnetConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listVnetConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listVnetConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a virtual network the app (or deployment slot) is connected to
   * by name.
   *
   * Gets a virtual network the app (or deployment slot) is connected to by name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the named virtual network for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVnetConnectionSlotWithHttpOperationResponse(resourceGroupName, name, vnetName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a virtual network the app (or deployment slot) is connected to
   * by name.
   *
   * Gets a virtual network the app (or deployment slot) is connected to by name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the named virtual network for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateVnetConnectionSlotWithHttpOperationResponse(resourceGroupName, name, vnetName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a connection from an app (or deployment slot to a named
   * virtual network.
   *
   * Deletes a connection from an app (or deployment slot to a named virtual
   * network.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteVnetConnectionSlotWithHttpOperationResponse(resourceGroupName, name, vnetName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a connection from an app (or deployment slot to a named
   * virtual network.
   *
   * Deletes a connection from an app (or deployment slot to a named virtual
   * network.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateVnetConnectionSlotWithHttpOperationResponse(resourceGroupName, name, vnetName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets an app's Virtual Network gateway.
   *
   * Gets an app's Virtual Network gateway.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a gateway for the production slot's Virtual
   * Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVnetConnectionGatewaySlotWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets an app's Virtual Network gateway.
   *
   * Gets an app's Virtual Network gateway.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a gateway for the production slot's Virtual
   * Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update a gateway for the production slot's
   * Virtual Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateVnetConnectionGatewaySlotWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update a gateway for the production slot's
   * Virtual Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update a gateway for the production slot's
   * Virtual Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateVnetConnectionGatewaySlotWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update a gateway for the production slot's
   * Virtual Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SlotDifferenceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotDifferencesFromProductionWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotDifferenceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotDifferenceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  swapSlotWithProductionWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._swapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  swapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._swapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._swapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Website Name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SnapshotCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSnapshotsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSnapshots(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Website Name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SnapshotCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SnapshotCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSnapshots(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSnapshots(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSnapshots(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the source control configuration of an app.
   *
   * Gets the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSourceControlWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSourceControl(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the source control configuration of an app.
   *
   * Gets the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSourceControl(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSourceControl(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSourceControl(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
   * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
   * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateSourceControlWithHttpOperationResponse(resourceGroupName, name, siteSourceControl, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
   * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
   * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the source control configuration of an app.
   *
   * Deletes the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSourceControlWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSourceControl(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the source control configuration of an app.
   *
   * Deletes the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSourceControl(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSourceControl(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSourceControl(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Starts an app (or deployment slot, if specified).
   *
   * Starts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._start(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts an app (or deployment slot, if specified).
   *
   * Starts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  start(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._start(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._start(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Stops an app (or deployment slot, if specified).
   *
   * Stops an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stop(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stops an app (or deployment slot, if specified).
   *
   * Stops an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stop(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stop(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stop(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Sync web app repository.
   *
   * Sync web app repository.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  syncRepositoryWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._syncRepository(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sync web app repository.
   *
   * Sync web app repository.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  syncRepository(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._syncRepository(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._syncRepository(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only information specified in the
   * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
   * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
   * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
   * duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;CsmUsageQuotaCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsagesWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsages(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only information specified in the
   * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
   * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
   * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
   * duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CsmUsageQuotaCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CsmUsageQuotaCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsages(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsages(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsages(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the virtual networks the app (or deployment slot) is connected
   * to.
   *
   * Gets the virtual networks the app (or deployment slot) is connected to.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listVnetConnectionsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listVnetConnections(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the virtual networks the app (or deployment slot) is connected
   * to.
   *
   * Gets the virtual networks the app (or deployment slot) is connected to.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listVnetConnections(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listVnetConnections(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listVnetConnections(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a virtual network the app (or deployment slot) is connected to
   * by name.
   *
   * Gets a virtual network the app (or deployment slot) is connected to by name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVnetConnectionWithHttpOperationResponse(resourceGroupName, name, vnetName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVnetConnection(resourceGroupName, name, vnetName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a virtual network the app (or deployment slot) is connected to
   * by name.
   *
   * Gets a virtual network the app (or deployment slot) is connected to by name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVnetConnection(resourceGroupName, name, vnetName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVnetConnection(resourceGroupName, name, vnetName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVnetConnection(resourceGroupName, name, vnetName, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateVnetConnectionWithHttpOperationResponse(resourceGroupName, name, vnetName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a connection from an app (or deployment slot to a named
   * virtual network.
   *
   * Deletes a connection from an app (or deployment slot to a named virtual
   * network.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteVnetConnectionWithHttpOperationResponse(resourceGroupName, name, vnetName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteVnetConnection(resourceGroupName, name, vnetName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a connection from an app (or deployment slot to a named
   * virtual network.
   *
   * Deletes a connection from an app (or deployment slot to a named virtual
   * network.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteVnetConnection(resourceGroupName, name, vnetName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteVnetConnection(resourceGroupName, name, vnetName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteVnetConnection(resourceGroupName, name, vnetName, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateVnetConnectionWithHttpOperationResponse(resourceGroupName, name, vnetName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Gets an app's Virtual Network gateway.
   *
   * Gets an app's Virtual Network gateway.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVnetConnectionGatewayWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets an app's Virtual Network gateway.
   *
   * Gets an app's Virtual Network gateway.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateVnetConnectionGatewayWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateVnetConnectionGatewayWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
   * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
   * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
   * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
   * default is &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
   * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is &lt;code>true&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
   * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
   * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
   * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * &lt;code>true&lt;/code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateOrUpdateWithHttpOperationResponse(resourceGroupName, name, siteEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
   * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
   * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
   * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
   * default is &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
   * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is &lt;code>true&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
   * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
   * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
   * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * &lt;code>true&lt;/code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RestoreResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginRestoreWithHttpOperationResponse(resourceGroupName, name, backupId, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginRestore(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginRestore(resourceGroupName, name, backupId, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginRestore(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginRestore(resourceGroupName, name, backupId, request, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;User>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginListPublishingCredentialsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginListPublishingCredentials(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {User} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link User} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginListPublishingCredentials(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginListPublishingCredentials(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginListPublishingCredentials(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a web app.
   *
   * Restores a web app.
   *
   * @param {string} subscriptionName Azure subscription
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationOptions Migration migrationOptions
   *
   * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
   * connection string.
   *
   * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
   *
   * @param {boolean} [migrationOptions.switchSiteAfterMigration]
   * &lt;code>true&lt;/code>if the app should be switched over; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [migrationOptions.blockWriteAccessToSite] &lt;code>true&lt;/code>
   * if the app should be read only during copy operation; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [migrationOptions.name] Resource Name.
   *
   * @param {string} [migrationOptions.kind] Kind of resource.
   *
   * @param {string} migrationOptions.location Resource Location.
   *
   * @param {string} [migrationOptions.type] Resource type.
   *
   * @param {object} [migrationOptions.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;StorageMigrationResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginMigrateStorageWithHttpOperationResponse(subscriptionName, resourceGroupName, name, migrationOptions, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a web app.
   *
   * Restores a web app.
   *
   * @param {string} subscriptionName Azure subscription
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationOptions Migration migrationOptions
   *
   * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
   * connection string.
   *
   * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
   *
   * @param {boolean} [migrationOptions.switchSiteAfterMigration]
   * &lt;code>true&lt;/code>if the app should be switched over; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [migrationOptions.blockWriteAccessToSite] &lt;code>true&lt;/code>
   * if the app should be read only during copy operation; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [migrationOptions.name] Resource Name.
   *
   * @param {string} [migrationOptions.kind] Kind of resource.
   *
   * @param {string} migrationOptions.location Resource Location.
   *
   * @param {string} [migrationOptions.type] Resource type.
   *
   * @param {object} [migrationOptions.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageMigrationResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageMigrationResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, optionalCallback);
    }
  }

  /**
   * @summary Migrates a local (in-app) MySql database to a remote MySql
   * database.
   *
   * Migrates a local (in-app) MySql database to a remote MySql database.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationRequestEnvelope MySql migration options
   *
   * @param {string} [migrationRequestEnvelope.connectionString] Connection
   * string to the remote MySQL database to which data should be migrated.
   *
   * @param {string} [migrationRequestEnvelope.name] Resource Name.
   *
   * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
   *
   * @param {string} migrationRequestEnvelope.location Resource Location.
   *
   * @param {string} [migrationRequestEnvelope.type] Resource type.
   *
   * @param {object} [migrationRequestEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Operation>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginMigrateMySqlWithHttpOperationResponse(resourceGroupName, name, migrationRequestEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Migrates a local (in-app) MySql database to a remote MySql
   * database.
   *
   * Migrates a local (in-app) MySql database to a remote MySql database.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationRequestEnvelope MySql migration options
   *
   * @param {string} [migrationRequestEnvelope.connectionString] Connection
   * string to the remote MySQL database to which data should be migrated.
   *
   * @param {string} [migrationRequestEnvelope.name] Resource Name.
   *
   * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
   *
   * @param {string} migrationRequestEnvelope.location Resource Location.
   *
   * @param {string} [migrationRequestEnvelope.type] Resource type.
   *
   * @param {object} [migrationRequestEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Operation} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Operation} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RecoverResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginRecoverWithHttpOperationResponse(resourceGroupName, name, recoveryEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginRecover(resourceGroupName, name, recoveryEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RecoverResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RecoverResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginRecover(resourceGroupName, name, recoveryEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginRecover(resourceGroupName, name, recoveryEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginRecover(resourceGroupName, name, recoveryEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
   * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
   * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
   * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
   * default is &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
   * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is &lt;code>true&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
   * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
   * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
   * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * &lt;code>true&lt;/code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot to create or update. By
   * default, this API attempts to create or modify the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateOrUpdateSlotWithHttpOperationResponse(resourceGroupName, name, siteEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] &lt;code>true&lt;/code> if the app is
   * enabled; otherwise, &lt;code>false&lt;/code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] &lt;code>true&lt;/code> if reserved;
   * otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * &lt;code>true&lt;/code> if request tracing is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * &lt;code>true&lt;/code> if remote debugging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * &lt;code>true&lt;/code> if HTTP logging is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * &lt;code>true&lt;/code> if detailed error logging is enabled; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * &lt;code>true&lt;/code> to use 32-bit worker process; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * &lt;code>true&lt;/code> if WebSocket is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] &lt;code>true&lt;/code> if
   * Always On is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] &lt;code>true&lt;/code>
   * if Auto Heal is enabled; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * &lt;code>true&lt;/code> to enable local MySQL; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] &lt;code>true&lt;/code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, &lt;code>false&lt;/code>. The
   * default is &lt;code>false&lt;/code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] &lt;code>true&lt;/code> to
   * enable client affinity; &lt;code>false&lt;/code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is &lt;code>true&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] &lt;code>true&lt;/code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, &lt;code>false&lt;/code>. Default is &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] &lt;code>true&lt;/code> to
   * disable the public hostnames of the app; otherwise, &lt;code>false&lt;/code>.
   * If &lt;code>true&lt;/code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] &lt;code>true&lt;/code> to
   * overwrite destination app; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * &lt;code>true&lt;/code> to clone custom hostnames from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * &lt;code>true&lt;/code> to clone source control from source app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * &lt;code>true&lt;/code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot to create or update. By
   * default, this API attempts to create or modify the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restore a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RestoreResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginRestoreSlotWithHttpOperationResponse(resourceGroupName, name, backupId, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] &lt;code>true&lt;/code> if the restore
   * operation can overwrite target app; otherwise, &lt;code>false&lt;/code>.
   * &lt;code>true&lt;/code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. &lt;code>true&lt;/code> to remove custom
   * domains automatically. If &lt;code>false&lt;/code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] &lt;code>true&lt;/code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restore a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing credentials for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;User>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginListPublishingCredentialsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing credentials for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {User} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link User} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;RecoverResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginRecoverSlotWithHttpOperationResponse(resourceGroupName, name, recoveryEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RecoverResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RecoverResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginSwapSlotSlotWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
   * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
   * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateOrUpdateSourceControlSlotWithHttpOperationResponse(resourceGroupName, name, siteSourceControl, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
   * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
   * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginSwapSlotWithProductionWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet &lt;code>true&lt;/code> to preserve
   * Virtual Network to the slot during swap; otherwise, &lt;code>false&lt;/code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
   * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
   * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateOrUpdateSourceControlWithHttpOperationResponse(resourceGroupName, name, siteSourceControl, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] &lt;code>true&lt;/code>
   * to limit to manual integration; &lt;code>false&lt;/code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * &lt;code>true&lt;/code> to enable deployment rollback; otherwise,
   * &lt;code>false&lt;/code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] &lt;code>true&lt;/code> for a
   * Mercurial repository; &lt;code>false&lt;/code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, optionalCallback);
    }
  }

  /**
   * @summary Get all apps for a subscription.
   *
   * Get all apps for a subscription.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get all apps for a subscription.
   *
   * Get all apps for a subscription.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all web, mobile, and API apps in the specified resource group.
   *
   * Gets all web, mobile, and API apps in the specified resource group.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listByResourceGroupNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listByResourceGroupNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all web, mobile, and API apps in the specified resource group.
   *
   * Gets all web, mobile, and API apps in the specified resource group.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listByResourceGroupNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listByResourceGroupNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listByResourceGroupNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupItemCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackupsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItemCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItemCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackupsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackupsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackupsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDeploymentsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDeploymentsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDeploymentsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDeploymentsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDeploymentsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;IdentifierCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDomainOwnershipIdentifiersNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDomainOwnershipIdentifiersNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IdentifierCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IdentifierCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDomainOwnershipIdentifiersNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDomainOwnershipIdentifiersNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDomainOwnershipIdentifiersNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HostNameBindingCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHostNameBindingsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHostNameBindingsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBindingCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBindingCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHostNameBindingsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHostNameBindingsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHostNameBindingsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;WebAppInstanceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceIdentifiersNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceIdentifiersNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppInstanceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppInstanceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceIdentifiersNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceIdentifiersNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceIdentifiersNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceDeploymentsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceDeploymentsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceDeploymentsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceDeploymentsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceDeploymentsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ResourceMetricDefinitionCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricDefinitionsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricDefinitionsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricDefinitionCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricDefinitionCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricDefinitionsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricDefinitionsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricDefinitionsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ResourceMetricCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PerfMonCounterCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPerfMonCountersNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPerfMonCountersNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PerfMonCounterCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PerfMonCounterCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPerfMonCountersNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPerfMonCountersNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPerfMonCountersNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets an app's deployment slots.
   *
   * Gets an app's deployment slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets an app's deployment slots.
   *
   * Gets an app's deployment slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;BackupItemCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackupsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItemCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItemCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackupsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackupsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackupsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDeploymentsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDeploymentsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDeploymentsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDeploymentsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDeploymentsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;IdentifierCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDomainOwnershipIdentifiersSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDomainOwnershipIdentifiersSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IdentifierCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IdentifierCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDomainOwnershipIdentifiersSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDomainOwnershipIdentifiersSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDomainOwnershipIdentifiersSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;HostNameBindingCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHostNameBindingsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHostNameBindingsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBindingCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBindingCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHostNameBindingsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHostNameBindingsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHostNameBindingsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;WebAppInstanceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceIdentifiersSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceIdentifiersSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppInstanceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppInstanceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceIdentifiersSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceIdentifiersSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceIdentifiersSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceDeploymentsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceDeploymentsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceDeploymentsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceDeploymentsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceDeploymentsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ResourceMetricDefinitionCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricDefinitionsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricDefinitionsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricDefinitionCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricDefinitionCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricDefinitionsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricDefinitionsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricDefinitionsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;ResourceMetricCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;PerfMonCounterCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPerfMonCountersSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPerfMonCountersSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PerfMonCounterCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PerfMonCounterCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPerfMonCountersSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPerfMonCountersSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPerfMonCountersSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SlotDifferenceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotDifferencesSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotDifferencesSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotDifferenceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotDifferenceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotDifferencesSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotDifferencesSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotDifferencesSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SnapshotCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSnapshotsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSnapshotsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SnapshotCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SnapshotCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSnapshotsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSnapshotsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSnapshotsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;CsmUsageQuotaCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsagesSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsagesSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CsmUsageQuotaCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CsmUsageQuotaCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsagesSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsagesSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsagesSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SlotDifferenceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotDifferencesFromProductionNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotDifferencesFromProductionNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotDifferenceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotDifferenceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotDifferencesFromProductionNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotDifferencesFromProductionNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotDifferencesFromProductionNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;SnapshotCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSnapshotsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSnapshotsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SnapshotCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SnapshotCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSnapshotsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSnapshotsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSnapshotsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse&lt;CsmUsageQuotaCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsagesNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsagesNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CsmUsageQuotaCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CsmUsageQuotaCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsagesNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback &amp;&amp; typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsagesNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsagesNext(nextPageLink, options, optionalCallback);
    }
  }

}

module.exports = WebApps;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Apr 03 2017 13:36:57 GMT-0700 (PDT) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="../../scripts/linenumber.js"></script>
</body>
</html>
